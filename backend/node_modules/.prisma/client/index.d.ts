
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Channel
 * 
 */
export type Channel = $Result.DefaultSelection<Prisma.$ChannelPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model ChannelSubscription
 * 
 */
export type ChannelSubscription = $Result.DefaultSelection<Prisma.$ChannelSubscriptionPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model MessageDelivery
 * 
 */
export type MessageDelivery = $Result.DefaultSelection<Prisma.$MessageDeliveryPayload>
/**
 * Model InvitationLink
 * 
 */
export type InvitationLink = $Result.DefaultSelection<Prisma.$InvitationLinkPayload>
/**
 * Model QrCode
 * 
 */
export type QrCode = $Result.DefaultSelection<Prisma.$QrCodePayload>
/**
 * Model Organization
 * 
 */
export type Organization = $Result.DefaultSelection<Prisma.$OrganizationPayload>
/**
 * Model ChannelApprover
 * 
 */
export type ChannelApprover = $Result.DefaultSelection<Prisma.$ChannelApproverPayload>
/**
 * Model MessageApproval
 * 
 */
export type MessageApproval = $Result.DefaultSelection<Prisma.$MessageApprovalPayload>
/**
 * Model MessageCategory
 * 
 */
export type MessageCategory = $Result.DefaultSelection<Prisma.$MessageCategoryPayload>
/**
 * Model MessageAttachment
 * 
 */
export type MessageAttachment = $Result.DefaultSelection<Prisma.$MessageAttachmentPayload>
/**
 * Model MessageRevision
 * 
 */
export type MessageRevision = $Result.DefaultSelection<Prisma.$MessageRevisionPayload>
/**
 * Model ChannelVerificationDocument
 * 
 */
export type ChannelVerificationDocument = $Result.DefaultSelection<Prisma.$ChannelVerificationDocumentPayload>
/**
 * Model UserProfile
 * 
 */
export type UserProfile = $Result.DefaultSelection<Prisma.$UserProfilePayload>
/**
 * Model UserMessagingSetting
 * 
 */
export type UserMessagingSetting = $Result.DefaultSelection<Prisma.$UserMessagingSettingPayload>
/**
 * Model ChannelCategory
 * 
 */
export type ChannelCategory = $Result.DefaultSelection<Prisma.$ChannelCategoryPayload>
/**
 * Model ChannelCategoryAssignment
 * 
 */
export type ChannelCategoryAssignment = $Result.DefaultSelection<Prisma.$ChannelCategoryAssignmentPayload>
/**
 * Model MessageView
 * 
 */
export type MessageView = $Result.DefaultSelection<Prisma.$MessageViewPayload>
/**
 * Model ChannelVisit
 * 
 */
export type ChannelVisit = $Result.DefaultSelection<Prisma.$ChannelVisitPayload>
/**
 * Model Form
 * 
 */
export type Form = $Result.DefaultSelection<Prisma.$FormPayload>
/**
 * Model FormField
 * 
 */
export type FormField = $Result.DefaultSelection<Prisma.$FormFieldPayload>
/**
 * Model FormSubmission
 * 
 */
export type FormSubmission = $Result.DefaultSelection<Prisma.$FormSubmissionPayload>
/**
 * Model Event
 * 
 */
export type Event = $Result.DefaultSelection<Prisma.$EventPayload>
/**
 * Model EventZone
 * 
 */
export type EventZone = $Result.DefaultSelection<Prisma.$EventZonePayload>
/**
 * Model EventSeat
 * 
 */
export type EventSeat = $Result.DefaultSelection<Prisma.$EventSeatPayload>
/**
 * Model Ticket
 * 
 */
export type Ticket = $Result.DefaultSelection<Prisma.$TicketPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const VerificationStatus: {
  UNVERIFIED: 'UNVERIFIED',
  VERIFIED: 'VERIFIED',
  VERIFIED_CERTIFIED: 'VERIFIED_CERTIFIED'
};

export type VerificationStatus = (typeof VerificationStatus)[keyof typeof VerificationStatus]


export const ApprovalPolicy: {
  REQUIRED: 'REQUIRED',
  OPTIONAL: 'OPTIONAL',
  DISABLED: 'DISABLED'
};

export type ApprovalPolicy = (typeof ApprovalPolicy)[keyof typeof ApprovalPolicy]


export const MessagePriority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH'
};

export type MessagePriority = (typeof MessagePriority)[keyof typeof MessagePriority]


export const DeliveryMethod: {
  PUSH: 'PUSH',
  SMS: 'SMS',
  WHATSAPP: 'WHATSAPP',
  TELEGRAM: 'TELEGRAM',
  EMAIL: 'EMAIL',
  BOTH: 'BOTH'
};

export type DeliveryMethod = (typeof DeliveryMethod)[keyof typeof DeliveryMethod]


export const MessageState: {
  ACTIVE: 'ACTIVE',
  CANCELLED: 'CANCELLED'
};

export type MessageState = (typeof MessageState)[keyof typeof MessageState]


export const DeliveryStatus: {
  PENDING: 'PENDING',
  DELIVERED: 'DELIVERED',
  FAILED: 'FAILED',
  READ: 'READ'
};

export type DeliveryStatus = (typeof DeliveryStatus)[keyof typeof DeliveryStatus]


export const ApprovalStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type ApprovalStatus = (typeof ApprovalStatus)[keyof typeof ApprovalStatus]


export const CategoryScope: {
  GLOBAL: 'GLOBAL',
  CHANNEL: 'CHANNEL'
};

export type CategoryScope = (typeof CategoryScope)[keyof typeof CategoryScope]


export const AttachmentType: {
  FILE: 'FILE',
  LINK: 'LINK',
  MEDIA: 'MEDIA'
};

export type AttachmentType = (typeof AttachmentType)[keyof typeof AttachmentType]


export const MessagingPlatform: {
  WHATSAPP: 'WHATSAPP',
  TELEGRAM: 'TELEGRAM',
  EMAIL: 'EMAIL',
  PUSH: 'PUSH',
  SMS: 'SMS'
};

export type MessagingPlatform = (typeof MessagingPlatform)[keyof typeof MessagingPlatform]


export const EventStatus: {
  DRAFT: 'DRAFT',
  PUBLISHED: 'PUBLISHED',
  CANCELLED: 'CANCELLED',
  ENDED: 'ENDED'
};

export type EventStatus = (typeof EventStatus)[keyof typeof EventStatus]


export const ZoneType: {
  SALE: 'SALE',
  INFO: 'INFO',
  STAGE: 'STAGE'
};

export type ZoneType = (typeof ZoneType)[keyof typeof ZoneType]


export const SeatStatus: {
  AVAILABLE: 'AVAILABLE',
  RESERVED: 'RESERVED',
  SOLD: 'SOLD',
  BLOCKED: 'BLOCKED',
  CHECKED_IN: 'CHECKED_IN'
};

export type SeatStatus = (typeof SeatStatus)[keyof typeof SeatStatus]


export const SeatType: {
  REGULAR: 'REGULAR',
  VIP: 'VIP',
  ACCESSIBLE: 'ACCESSIBLE'
};

export type SeatType = (typeof SeatType)[keyof typeof SeatType]


export const TicketStatus: {
  VALID: 'VALID',
  USED: 'USED',
  CANCELLED: 'CANCELLED',
  REFUNDED: 'REFUNDED'
};

export type TicketStatus = (typeof TicketStatus)[keyof typeof TicketStatus]

}

export type VerificationStatus = $Enums.VerificationStatus

export const VerificationStatus: typeof $Enums.VerificationStatus

export type ApprovalPolicy = $Enums.ApprovalPolicy

export const ApprovalPolicy: typeof $Enums.ApprovalPolicy

export type MessagePriority = $Enums.MessagePriority

export const MessagePriority: typeof $Enums.MessagePriority

export type DeliveryMethod = $Enums.DeliveryMethod

export const DeliveryMethod: typeof $Enums.DeliveryMethod

export type MessageState = $Enums.MessageState

export const MessageState: typeof $Enums.MessageState

export type DeliveryStatus = $Enums.DeliveryStatus

export const DeliveryStatus: typeof $Enums.DeliveryStatus

export type ApprovalStatus = $Enums.ApprovalStatus

export const ApprovalStatus: typeof $Enums.ApprovalStatus

export type CategoryScope = $Enums.CategoryScope

export const CategoryScope: typeof $Enums.CategoryScope

export type AttachmentType = $Enums.AttachmentType

export const AttachmentType: typeof $Enums.AttachmentType

export type MessagingPlatform = $Enums.MessagingPlatform

export const MessagingPlatform: typeof $Enums.MessagingPlatform

export type EventStatus = $Enums.EventStatus

export const EventStatus: typeof $Enums.EventStatus

export type ZoneType = $Enums.ZoneType

export const ZoneType: typeof $Enums.ZoneType

export type SeatStatus = $Enums.SeatStatus

export const SeatStatus: typeof $Enums.SeatStatus

export type SeatType = $Enums.SeatType

export const SeatType: typeof $Enums.SeatType

export type TicketStatus = $Enums.TicketStatus

export const TicketStatus: typeof $Enums.TicketStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.channel`: Exposes CRUD operations for the **Channel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Channels
    * const channels = await prisma.channel.findMany()
    * ```
    */
  get channel(): Prisma.ChannelDelegate<ExtArgs>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs>;

  /**
   * `prisma.channelSubscription`: Exposes CRUD operations for the **ChannelSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChannelSubscriptions
    * const channelSubscriptions = await prisma.channelSubscription.findMany()
    * ```
    */
  get channelSubscription(): Prisma.ChannelSubscriptionDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.messageDelivery`: Exposes CRUD operations for the **MessageDelivery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageDeliveries
    * const messageDeliveries = await prisma.messageDelivery.findMany()
    * ```
    */
  get messageDelivery(): Prisma.MessageDeliveryDelegate<ExtArgs>;

  /**
   * `prisma.invitationLink`: Exposes CRUD operations for the **InvitationLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvitationLinks
    * const invitationLinks = await prisma.invitationLink.findMany()
    * ```
    */
  get invitationLink(): Prisma.InvitationLinkDelegate<ExtArgs>;

  /**
   * `prisma.qrCode`: Exposes CRUD operations for the **QrCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QrCodes
    * const qrCodes = await prisma.qrCode.findMany()
    * ```
    */
  get qrCode(): Prisma.QrCodeDelegate<ExtArgs>;

  /**
   * `prisma.organization`: Exposes CRUD operations for the **Organization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organization.findMany()
    * ```
    */
  get organization(): Prisma.OrganizationDelegate<ExtArgs>;

  /**
   * `prisma.channelApprover`: Exposes CRUD operations for the **ChannelApprover** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChannelApprovers
    * const channelApprovers = await prisma.channelApprover.findMany()
    * ```
    */
  get channelApprover(): Prisma.ChannelApproverDelegate<ExtArgs>;

  /**
   * `prisma.messageApproval`: Exposes CRUD operations for the **MessageApproval** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageApprovals
    * const messageApprovals = await prisma.messageApproval.findMany()
    * ```
    */
  get messageApproval(): Prisma.MessageApprovalDelegate<ExtArgs>;

  /**
   * `prisma.messageCategory`: Exposes CRUD operations for the **MessageCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageCategories
    * const messageCategories = await prisma.messageCategory.findMany()
    * ```
    */
  get messageCategory(): Prisma.MessageCategoryDelegate<ExtArgs>;

  /**
   * `prisma.messageAttachment`: Exposes CRUD operations for the **MessageAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageAttachments
    * const messageAttachments = await prisma.messageAttachment.findMany()
    * ```
    */
  get messageAttachment(): Prisma.MessageAttachmentDelegate<ExtArgs>;

  /**
   * `prisma.messageRevision`: Exposes CRUD operations for the **MessageRevision** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageRevisions
    * const messageRevisions = await prisma.messageRevision.findMany()
    * ```
    */
  get messageRevision(): Prisma.MessageRevisionDelegate<ExtArgs>;

  /**
   * `prisma.channelVerificationDocument`: Exposes CRUD operations for the **ChannelVerificationDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChannelVerificationDocuments
    * const channelVerificationDocuments = await prisma.channelVerificationDocument.findMany()
    * ```
    */
  get channelVerificationDocument(): Prisma.ChannelVerificationDocumentDelegate<ExtArgs>;

  /**
   * `prisma.userProfile`: Exposes CRUD operations for the **UserProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserProfiles
    * const userProfiles = await prisma.userProfile.findMany()
    * ```
    */
  get userProfile(): Prisma.UserProfileDelegate<ExtArgs>;

  /**
   * `prisma.userMessagingSetting`: Exposes CRUD operations for the **UserMessagingSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserMessagingSettings
    * const userMessagingSettings = await prisma.userMessagingSetting.findMany()
    * ```
    */
  get userMessagingSetting(): Prisma.UserMessagingSettingDelegate<ExtArgs>;

  /**
   * `prisma.channelCategory`: Exposes CRUD operations for the **ChannelCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChannelCategories
    * const channelCategories = await prisma.channelCategory.findMany()
    * ```
    */
  get channelCategory(): Prisma.ChannelCategoryDelegate<ExtArgs>;

  /**
   * `prisma.channelCategoryAssignment`: Exposes CRUD operations for the **ChannelCategoryAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChannelCategoryAssignments
    * const channelCategoryAssignments = await prisma.channelCategoryAssignment.findMany()
    * ```
    */
  get channelCategoryAssignment(): Prisma.ChannelCategoryAssignmentDelegate<ExtArgs>;

  /**
   * `prisma.messageView`: Exposes CRUD operations for the **MessageView** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageViews
    * const messageViews = await prisma.messageView.findMany()
    * ```
    */
  get messageView(): Prisma.MessageViewDelegate<ExtArgs>;

  /**
   * `prisma.channelVisit`: Exposes CRUD operations for the **ChannelVisit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChannelVisits
    * const channelVisits = await prisma.channelVisit.findMany()
    * ```
    */
  get channelVisit(): Prisma.ChannelVisitDelegate<ExtArgs>;

  /**
   * `prisma.form`: Exposes CRUD operations for the **Form** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Forms
    * const forms = await prisma.form.findMany()
    * ```
    */
  get form(): Prisma.FormDelegate<ExtArgs>;

  /**
   * `prisma.formField`: Exposes CRUD operations for the **FormField** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FormFields
    * const formFields = await prisma.formField.findMany()
    * ```
    */
  get formField(): Prisma.FormFieldDelegate<ExtArgs>;

  /**
   * `prisma.formSubmission`: Exposes CRUD operations for the **FormSubmission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FormSubmissions
    * const formSubmissions = await prisma.formSubmission.findMany()
    * ```
    */
  get formSubmission(): Prisma.FormSubmissionDelegate<ExtArgs>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.EventDelegate<ExtArgs>;

  /**
   * `prisma.eventZone`: Exposes CRUD operations for the **EventZone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventZones
    * const eventZones = await prisma.eventZone.findMany()
    * ```
    */
  get eventZone(): Prisma.EventZoneDelegate<ExtArgs>;

  /**
   * `prisma.eventSeat`: Exposes CRUD operations for the **EventSeat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventSeats
    * const eventSeats = await prisma.eventSeat.findMany()
    * ```
    */
  get eventSeat(): Prisma.EventSeatDelegate<ExtArgs>;

  /**
   * `prisma.ticket`: Exposes CRUD operations for the **Ticket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tickets
    * const tickets = await prisma.ticket.findMany()
    * ```
    */
  get ticket(): Prisma.TicketDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Channel: 'Channel',
    Message: 'Message',
    ChannelSubscription: 'ChannelSubscription',
    AuditLog: 'AuditLog',
    MessageDelivery: 'MessageDelivery',
    InvitationLink: 'InvitationLink',
    QrCode: 'QrCode',
    Organization: 'Organization',
    ChannelApprover: 'ChannelApprover',
    MessageApproval: 'MessageApproval',
    MessageCategory: 'MessageCategory',
    MessageAttachment: 'MessageAttachment',
    MessageRevision: 'MessageRevision',
    ChannelVerificationDocument: 'ChannelVerificationDocument',
    UserProfile: 'UserProfile',
    UserMessagingSetting: 'UserMessagingSetting',
    ChannelCategory: 'ChannelCategory',
    ChannelCategoryAssignment: 'ChannelCategoryAssignment',
    MessageView: 'MessageView',
    ChannelVisit: 'ChannelVisit',
    Form: 'Form',
    FormField: 'FormField',
    FormSubmission: 'FormSubmission',
    Event: 'Event',
    EventZone: 'EventZone',
    EventSeat: 'EventSeat',
    Ticket: 'Ticket'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "channel" | "message" | "channelSubscription" | "auditLog" | "messageDelivery" | "invitationLink" | "qrCode" | "organization" | "channelApprover" | "messageApproval" | "messageCategory" | "messageAttachment" | "messageRevision" | "channelVerificationDocument" | "userProfile" | "userMessagingSetting" | "channelCategory" | "channelCategoryAssignment" | "messageView" | "channelVisit" | "form" | "formField" | "formSubmission" | "event" | "eventZone" | "eventSeat" | "ticket"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Channel: {
        payload: Prisma.$ChannelPayload<ExtArgs>
        fields: Prisma.ChannelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChannelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChannelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          findFirst: {
            args: Prisma.ChannelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChannelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          findMany: {
            args: Prisma.ChannelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>[]
          }
          create: {
            args: Prisma.ChannelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          createMany: {
            args: Prisma.ChannelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ChannelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          update: {
            args: Prisma.ChannelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          deleteMany: {
            args: Prisma.ChannelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChannelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChannelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          aggregate: {
            args: Prisma.ChannelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChannel>
          }
          groupBy: {
            args: Prisma.ChannelGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChannelGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChannelCountArgs<ExtArgs>
            result: $Utils.Optional<ChannelCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      ChannelSubscription: {
        payload: Prisma.$ChannelSubscriptionPayload<ExtArgs>
        fields: Prisma.ChannelSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChannelSubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChannelSubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.ChannelSubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChannelSubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelSubscriptionPayload>
          }
          findMany: {
            args: Prisma.ChannelSubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelSubscriptionPayload>[]
          }
          create: {
            args: Prisma.ChannelSubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelSubscriptionPayload>
          }
          createMany: {
            args: Prisma.ChannelSubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ChannelSubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelSubscriptionPayload>
          }
          update: {
            args: Prisma.ChannelSubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.ChannelSubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChannelSubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChannelSubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.ChannelSubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChannelSubscription>
          }
          groupBy: {
            args: Prisma.ChannelSubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChannelSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChannelSubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<ChannelSubscriptionCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      MessageDelivery: {
        payload: Prisma.$MessageDeliveryPayload<ExtArgs>
        fields: Prisma.MessageDeliveryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageDeliveryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageDeliveryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageDeliveryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageDeliveryPayload>
          }
          findFirst: {
            args: Prisma.MessageDeliveryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageDeliveryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageDeliveryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageDeliveryPayload>
          }
          findMany: {
            args: Prisma.MessageDeliveryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageDeliveryPayload>[]
          }
          create: {
            args: Prisma.MessageDeliveryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageDeliveryPayload>
          }
          createMany: {
            args: Prisma.MessageDeliveryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MessageDeliveryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageDeliveryPayload>
          }
          update: {
            args: Prisma.MessageDeliveryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageDeliveryPayload>
          }
          deleteMany: {
            args: Prisma.MessageDeliveryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageDeliveryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageDeliveryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageDeliveryPayload>
          }
          aggregate: {
            args: Prisma.MessageDeliveryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageDelivery>
          }
          groupBy: {
            args: Prisma.MessageDeliveryGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageDeliveryGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageDeliveryCountArgs<ExtArgs>
            result: $Utils.Optional<MessageDeliveryCountAggregateOutputType> | number
          }
        }
      }
      InvitationLink: {
        payload: Prisma.$InvitationLinkPayload<ExtArgs>
        fields: Prisma.InvitationLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvitationLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvitationLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationLinkPayload>
          }
          findFirst: {
            args: Prisma.InvitationLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvitationLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationLinkPayload>
          }
          findMany: {
            args: Prisma.InvitationLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationLinkPayload>[]
          }
          create: {
            args: Prisma.InvitationLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationLinkPayload>
          }
          createMany: {
            args: Prisma.InvitationLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InvitationLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationLinkPayload>
          }
          update: {
            args: Prisma.InvitationLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationLinkPayload>
          }
          deleteMany: {
            args: Prisma.InvitationLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvitationLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvitationLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationLinkPayload>
          }
          aggregate: {
            args: Prisma.InvitationLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvitationLink>
          }
          groupBy: {
            args: Prisma.InvitationLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvitationLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvitationLinkCountArgs<ExtArgs>
            result: $Utils.Optional<InvitationLinkCountAggregateOutputType> | number
          }
        }
      }
      QrCode: {
        payload: Prisma.$QrCodePayload<ExtArgs>
        fields: Prisma.QrCodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QrCodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QrCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QrCodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QrCodePayload>
          }
          findFirst: {
            args: Prisma.QrCodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QrCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QrCodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QrCodePayload>
          }
          findMany: {
            args: Prisma.QrCodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QrCodePayload>[]
          }
          create: {
            args: Prisma.QrCodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QrCodePayload>
          }
          createMany: {
            args: Prisma.QrCodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.QrCodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QrCodePayload>
          }
          update: {
            args: Prisma.QrCodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QrCodePayload>
          }
          deleteMany: {
            args: Prisma.QrCodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QrCodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QrCodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QrCodePayload>
          }
          aggregate: {
            args: Prisma.QrCodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQrCode>
          }
          groupBy: {
            args: Prisma.QrCodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<QrCodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.QrCodeCountArgs<ExtArgs>
            result: $Utils.Optional<QrCodeCountAggregateOutputType> | number
          }
        }
      }
      Organization: {
        payload: Prisma.$OrganizationPayload<ExtArgs>
        fields: Prisma.OrganizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findFirst: {
            args: Prisma.OrganizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findMany: {
            args: Prisma.OrganizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          create: {
            args: Prisma.OrganizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          createMany: {
            args: Prisma.OrganizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OrganizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          update: {
            args: Prisma.OrganizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrganizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          aggregate: {
            args: Prisma.OrganizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganization>
          }
          groupBy: {
            args: Prisma.OrganizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationCountAggregateOutputType> | number
          }
        }
      }
      ChannelApprover: {
        payload: Prisma.$ChannelApproverPayload<ExtArgs>
        fields: Prisma.ChannelApproverFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChannelApproverFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelApproverPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChannelApproverFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelApproverPayload>
          }
          findFirst: {
            args: Prisma.ChannelApproverFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelApproverPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChannelApproverFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelApproverPayload>
          }
          findMany: {
            args: Prisma.ChannelApproverFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelApproverPayload>[]
          }
          create: {
            args: Prisma.ChannelApproverCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelApproverPayload>
          }
          createMany: {
            args: Prisma.ChannelApproverCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ChannelApproverDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelApproverPayload>
          }
          update: {
            args: Prisma.ChannelApproverUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelApproverPayload>
          }
          deleteMany: {
            args: Prisma.ChannelApproverDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChannelApproverUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChannelApproverUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelApproverPayload>
          }
          aggregate: {
            args: Prisma.ChannelApproverAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChannelApprover>
          }
          groupBy: {
            args: Prisma.ChannelApproverGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChannelApproverGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChannelApproverCountArgs<ExtArgs>
            result: $Utils.Optional<ChannelApproverCountAggregateOutputType> | number
          }
        }
      }
      MessageApproval: {
        payload: Prisma.$MessageApprovalPayload<ExtArgs>
        fields: Prisma.MessageApprovalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageApprovalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageApprovalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageApprovalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageApprovalPayload>
          }
          findFirst: {
            args: Prisma.MessageApprovalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageApprovalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageApprovalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageApprovalPayload>
          }
          findMany: {
            args: Prisma.MessageApprovalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageApprovalPayload>[]
          }
          create: {
            args: Prisma.MessageApprovalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageApprovalPayload>
          }
          createMany: {
            args: Prisma.MessageApprovalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MessageApprovalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageApprovalPayload>
          }
          update: {
            args: Prisma.MessageApprovalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageApprovalPayload>
          }
          deleteMany: {
            args: Prisma.MessageApprovalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageApprovalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageApprovalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageApprovalPayload>
          }
          aggregate: {
            args: Prisma.MessageApprovalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageApproval>
          }
          groupBy: {
            args: Prisma.MessageApprovalGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageApprovalGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageApprovalCountArgs<ExtArgs>
            result: $Utils.Optional<MessageApprovalCountAggregateOutputType> | number
          }
        }
      }
      MessageCategory: {
        payload: Prisma.$MessageCategoryPayload<ExtArgs>
        fields: Prisma.MessageCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageCategoryPayload>
          }
          findFirst: {
            args: Prisma.MessageCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageCategoryPayload>
          }
          findMany: {
            args: Prisma.MessageCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageCategoryPayload>[]
          }
          create: {
            args: Prisma.MessageCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageCategoryPayload>
          }
          createMany: {
            args: Prisma.MessageCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MessageCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageCategoryPayload>
          }
          update: {
            args: Prisma.MessageCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageCategoryPayload>
          }
          deleteMany: {
            args: Prisma.MessageCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageCategoryPayload>
          }
          aggregate: {
            args: Prisma.MessageCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageCategory>
          }
          groupBy: {
            args: Prisma.MessageCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCategoryCountAggregateOutputType> | number
          }
        }
      }
      MessageAttachment: {
        payload: Prisma.$MessageAttachmentPayload<ExtArgs>
        fields: Prisma.MessageAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>
          }
          findFirst: {
            args: Prisma.MessageAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>
          }
          findMany: {
            args: Prisma.MessageAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>[]
          }
          create: {
            args: Prisma.MessageAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>
          }
          createMany: {
            args: Prisma.MessageAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MessageAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>
          }
          update: {
            args: Prisma.MessageAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.MessageAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>
          }
          aggregate: {
            args: Prisma.MessageAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageAttachment>
          }
          groupBy: {
            args: Prisma.MessageAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<MessageAttachmentCountAggregateOutputType> | number
          }
        }
      }
      MessageRevision: {
        payload: Prisma.$MessageRevisionPayload<ExtArgs>
        fields: Prisma.MessageRevisionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageRevisionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageRevisionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageRevisionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageRevisionPayload>
          }
          findFirst: {
            args: Prisma.MessageRevisionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageRevisionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageRevisionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageRevisionPayload>
          }
          findMany: {
            args: Prisma.MessageRevisionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageRevisionPayload>[]
          }
          create: {
            args: Prisma.MessageRevisionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageRevisionPayload>
          }
          createMany: {
            args: Prisma.MessageRevisionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MessageRevisionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageRevisionPayload>
          }
          update: {
            args: Prisma.MessageRevisionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageRevisionPayload>
          }
          deleteMany: {
            args: Prisma.MessageRevisionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageRevisionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageRevisionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageRevisionPayload>
          }
          aggregate: {
            args: Prisma.MessageRevisionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageRevision>
          }
          groupBy: {
            args: Prisma.MessageRevisionGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageRevisionGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageRevisionCountArgs<ExtArgs>
            result: $Utils.Optional<MessageRevisionCountAggregateOutputType> | number
          }
        }
      }
      ChannelVerificationDocument: {
        payload: Prisma.$ChannelVerificationDocumentPayload<ExtArgs>
        fields: Prisma.ChannelVerificationDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChannelVerificationDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelVerificationDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChannelVerificationDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelVerificationDocumentPayload>
          }
          findFirst: {
            args: Prisma.ChannelVerificationDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelVerificationDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChannelVerificationDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelVerificationDocumentPayload>
          }
          findMany: {
            args: Prisma.ChannelVerificationDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelVerificationDocumentPayload>[]
          }
          create: {
            args: Prisma.ChannelVerificationDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelVerificationDocumentPayload>
          }
          createMany: {
            args: Prisma.ChannelVerificationDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ChannelVerificationDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelVerificationDocumentPayload>
          }
          update: {
            args: Prisma.ChannelVerificationDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelVerificationDocumentPayload>
          }
          deleteMany: {
            args: Prisma.ChannelVerificationDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChannelVerificationDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChannelVerificationDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelVerificationDocumentPayload>
          }
          aggregate: {
            args: Prisma.ChannelVerificationDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChannelVerificationDocument>
          }
          groupBy: {
            args: Prisma.ChannelVerificationDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChannelVerificationDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChannelVerificationDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<ChannelVerificationDocumentCountAggregateOutputType> | number
          }
        }
      }
      UserProfile: {
        payload: Prisma.$UserProfilePayload<ExtArgs>
        fields: Prisma.UserProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          findFirst: {
            args: Prisma.UserProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          findMany: {
            args: Prisma.UserProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          create: {
            args: Prisma.UserProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          createMany: {
            args: Prisma.UserProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          update: {
            args: Prisma.UserProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          deleteMany: {
            args: Prisma.UserProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          aggregate: {
            args: Prisma.UserProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserProfile>
          }
          groupBy: {
            args: Prisma.UserProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserProfileCountArgs<ExtArgs>
            result: $Utils.Optional<UserProfileCountAggregateOutputType> | number
          }
        }
      }
      UserMessagingSetting: {
        payload: Prisma.$UserMessagingSettingPayload<ExtArgs>
        fields: Prisma.UserMessagingSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserMessagingSettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMessagingSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserMessagingSettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMessagingSettingPayload>
          }
          findFirst: {
            args: Prisma.UserMessagingSettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMessagingSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserMessagingSettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMessagingSettingPayload>
          }
          findMany: {
            args: Prisma.UserMessagingSettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMessagingSettingPayload>[]
          }
          create: {
            args: Prisma.UserMessagingSettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMessagingSettingPayload>
          }
          createMany: {
            args: Prisma.UserMessagingSettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserMessagingSettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMessagingSettingPayload>
          }
          update: {
            args: Prisma.UserMessagingSettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMessagingSettingPayload>
          }
          deleteMany: {
            args: Prisma.UserMessagingSettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserMessagingSettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserMessagingSettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMessagingSettingPayload>
          }
          aggregate: {
            args: Prisma.UserMessagingSettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserMessagingSetting>
          }
          groupBy: {
            args: Prisma.UserMessagingSettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserMessagingSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserMessagingSettingCountArgs<ExtArgs>
            result: $Utils.Optional<UserMessagingSettingCountAggregateOutputType> | number
          }
        }
      }
      ChannelCategory: {
        payload: Prisma.$ChannelCategoryPayload<ExtArgs>
        fields: Prisma.ChannelCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChannelCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChannelCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelCategoryPayload>
          }
          findFirst: {
            args: Prisma.ChannelCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChannelCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelCategoryPayload>
          }
          findMany: {
            args: Prisma.ChannelCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelCategoryPayload>[]
          }
          create: {
            args: Prisma.ChannelCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelCategoryPayload>
          }
          createMany: {
            args: Prisma.ChannelCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ChannelCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelCategoryPayload>
          }
          update: {
            args: Prisma.ChannelCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ChannelCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChannelCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChannelCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelCategoryPayload>
          }
          aggregate: {
            args: Prisma.ChannelCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChannelCategory>
          }
          groupBy: {
            args: Prisma.ChannelCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChannelCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChannelCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ChannelCategoryCountAggregateOutputType> | number
          }
        }
      }
      ChannelCategoryAssignment: {
        payload: Prisma.$ChannelCategoryAssignmentPayload<ExtArgs>
        fields: Prisma.ChannelCategoryAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChannelCategoryAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelCategoryAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChannelCategoryAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelCategoryAssignmentPayload>
          }
          findFirst: {
            args: Prisma.ChannelCategoryAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelCategoryAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChannelCategoryAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelCategoryAssignmentPayload>
          }
          findMany: {
            args: Prisma.ChannelCategoryAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelCategoryAssignmentPayload>[]
          }
          create: {
            args: Prisma.ChannelCategoryAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelCategoryAssignmentPayload>
          }
          createMany: {
            args: Prisma.ChannelCategoryAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ChannelCategoryAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelCategoryAssignmentPayload>
          }
          update: {
            args: Prisma.ChannelCategoryAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelCategoryAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.ChannelCategoryAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChannelCategoryAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChannelCategoryAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelCategoryAssignmentPayload>
          }
          aggregate: {
            args: Prisma.ChannelCategoryAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChannelCategoryAssignment>
          }
          groupBy: {
            args: Prisma.ChannelCategoryAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChannelCategoryAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChannelCategoryAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<ChannelCategoryAssignmentCountAggregateOutputType> | number
          }
        }
      }
      MessageView: {
        payload: Prisma.$MessageViewPayload<ExtArgs>
        fields: Prisma.MessageViewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageViewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageViewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageViewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageViewPayload>
          }
          findFirst: {
            args: Prisma.MessageViewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageViewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageViewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageViewPayload>
          }
          findMany: {
            args: Prisma.MessageViewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageViewPayload>[]
          }
          create: {
            args: Prisma.MessageViewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageViewPayload>
          }
          createMany: {
            args: Prisma.MessageViewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MessageViewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageViewPayload>
          }
          update: {
            args: Prisma.MessageViewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageViewPayload>
          }
          deleteMany: {
            args: Prisma.MessageViewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageViewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageViewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageViewPayload>
          }
          aggregate: {
            args: Prisma.MessageViewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageView>
          }
          groupBy: {
            args: Prisma.MessageViewGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageViewGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageViewCountArgs<ExtArgs>
            result: $Utils.Optional<MessageViewCountAggregateOutputType> | number
          }
        }
      }
      ChannelVisit: {
        payload: Prisma.$ChannelVisitPayload<ExtArgs>
        fields: Prisma.ChannelVisitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChannelVisitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelVisitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChannelVisitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelVisitPayload>
          }
          findFirst: {
            args: Prisma.ChannelVisitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelVisitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChannelVisitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelVisitPayload>
          }
          findMany: {
            args: Prisma.ChannelVisitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelVisitPayload>[]
          }
          create: {
            args: Prisma.ChannelVisitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelVisitPayload>
          }
          createMany: {
            args: Prisma.ChannelVisitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ChannelVisitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelVisitPayload>
          }
          update: {
            args: Prisma.ChannelVisitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelVisitPayload>
          }
          deleteMany: {
            args: Prisma.ChannelVisitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChannelVisitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChannelVisitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelVisitPayload>
          }
          aggregate: {
            args: Prisma.ChannelVisitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChannelVisit>
          }
          groupBy: {
            args: Prisma.ChannelVisitGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChannelVisitGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChannelVisitCountArgs<ExtArgs>
            result: $Utils.Optional<ChannelVisitCountAggregateOutputType> | number
          }
        }
      }
      Form: {
        payload: Prisma.$FormPayload<ExtArgs>
        fields: Prisma.FormFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FormFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FormFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload>
          }
          findFirst: {
            args: Prisma.FormFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FormFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload>
          }
          findMany: {
            args: Prisma.FormFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload>[]
          }
          create: {
            args: Prisma.FormCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload>
          }
          createMany: {
            args: Prisma.FormCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FormDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload>
          }
          update: {
            args: Prisma.FormUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload>
          }
          deleteMany: {
            args: Prisma.FormDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FormUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FormUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload>
          }
          aggregate: {
            args: Prisma.FormAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateForm>
          }
          groupBy: {
            args: Prisma.FormGroupByArgs<ExtArgs>
            result: $Utils.Optional<FormGroupByOutputType>[]
          }
          count: {
            args: Prisma.FormCountArgs<ExtArgs>
            result: $Utils.Optional<FormCountAggregateOutputType> | number
          }
        }
      }
      FormField: {
        payload: Prisma.$FormFieldPayload<ExtArgs>
        fields: Prisma.FormFieldFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FormFieldFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFieldPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FormFieldFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFieldPayload>
          }
          findFirst: {
            args: Prisma.FormFieldFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFieldPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FormFieldFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFieldPayload>
          }
          findMany: {
            args: Prisma.FormFieldFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFieldPayload>[]
          }
          create: {
            args: Prisma.FormFieldCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFieldPayload>
          }
          createMany: {
            args: Prisma.FormFieldCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FormFieldDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFieldPayload>
          }
          update: {
            args: Prisma.FormFieldUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFieldPayload>
          }
          deleteMany: {
            args: Prisma.FormFieldDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FormFieldUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FormFieldUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFieldPayload>
          }
          aggregate: {
            args: Prisma.FormFieldAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFormField>
          }
          groupBy: {
            args: Prisma.FormFieldGroupByArgs<ExtArgs>
            result: $Utils.Optional<FormFieldGroupByOutputType>[]
          }
          count: {
            args: Prisma.FormFieldCountArgs<ExtArgs>
            result: $Utils.Optional<FormFieldCountAggregateOutputType> | number
          }
        }
      }
      FormSubmission: {
        payload: Prisma.$FormSubmissionPayload<ExtArgs>
        fields: Prisma.FormSubmissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FormSubmissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FormSubmissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>
          }
          findFirst: {
            args: Prisma.FormSubmissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FormSubmissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>
          }
          findMany: {
            args: Prisma.FormSubmissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>[]
          }
          create: {
            args: Prisma.FormSubmissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>
          }
          createMany: {
            args: Prisma.FormSubmissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FormSubmissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>
          }
          update: {
            args: Prisma.FormSubmissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>
          }
          deleteMany: {
            args: Prisma.FormSubmissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FormSubmissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FormSubmissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>
          }
          aggregate: {
            args: Prisma.FormSubmissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFormSubmission>
          }
          groupBy: {
            args: Prisma.FormSubmissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<FormSubmissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.FormSubmissionCountArgs<ExtArgs>
            result: $Utils.Optional<FormSubmissionCountAggregateOutputType> | number
          }
        }
      }
      Event: {
        payload: Prisma.$EventPayload<ExtArgs>
        fields: Prisma.EventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findFirst: {
            args: Prisma.EventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findMany: {
            args: Prisma.EventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          create: {
            args: Prisma.EventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          createMany: {
            args: Prisma.EventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          update: {
            args: Prisma.EventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          deleteMany: {
            args: Prisma.EventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvent>
          }
          groupBy: {
            args: Prisma.EventGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventCountArgs<ExtArgs>
            result: $Utils.Optional<EventCountAggregateOutputType> | number
          }
        }
      }
      EventZone: {
        payload: Prisma.$EventZonePayload<ExtArgs>
        fields: Prisma.EventZoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventZoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventZonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventZoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventZonePayload>
          }
          findFirst: {
            args: Prisma.EventZoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventZonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventZoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventZonePayload>
          }
          findMany: {
            args: Prisma.EventZoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventZonePayload>[]
          }
          create: {
            args: Prisma.EventZoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventZonePayload>
          }
          createMany: {
            args: Prisma.EventZoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EventZoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventZonePayload>
          }
          update: {
            args: Prisma.EventZoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventZonePayload>
          }
          deleteMany: {
            args: Prisma.EventZoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventZoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EventZoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventZonePayload>
          }
          aggregate: {
            args: Prisma.EventZoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventZone>
          }
          groupBy: {
            args: Prisma.EventZoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventZoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventZoneCountArgs<ExtArgs>
            result: $Utils.Optional<EventZoneCountAggregateOutputType> | number
          }
        }
      }
      EventSeat: {
        payload: Prisma.$EventSeatPayload<ExtArgs>
        fields: Prisma.EventSeatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventSeatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventSeatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventSeatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventSeatPayload>
          }
          findFirst: {
            args: Prisma.EventSeatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventSeatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventSeatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventSeatPayload>
          }
          findMany: {
            args: Prisma.EventSeatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventSeatPayload>[]
          }
          create: {
            args: Prisma.EventSeatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventSeatPayload>
          }
          createMany: {
            args: Prisma.EventSeatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EventSeatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventSeatPayload>
          }
          update: {
            args: Prisma.EventSeatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventSeatPayload>
          }
          deleteMany: {
            args: Prisma.EventSeatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventSeatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EventSeatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventSeatPayload>
          }
          aggregate: {
            args: Prisma.EventSeatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventSeat>
          }
          groupBy: {
            args: Prisma.EventSeatGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventSeatGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventSeatCountArgs<ExtArgs>
            result: $Utils.Optional<EventSeatCountAggregateOutputType> | number
          }
        }
      }
      Ticket: {
        payload: Prisma.$TicketPayload<ExtArgs>
        fields: Prisma.TicketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          findFirst: {
            args: Prisma.TicketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          findMany: {
            args: Prisma.TicketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          create: {
            args: Prisma.TicketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          createMany: {
            args: Prisma.TicketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TicketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          update: {
            args: Prisma.TicketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          deleteMany: {
            args: Prisma.TicketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TicketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          aggregate: {
            args: Prisma.TicketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicket>
          }
          groupBy: {
            args: Prisma.TicketGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketCountArgs<ExtArgs>
            result: $Utils.Optional<TicketCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    ownedChannels: number
    messagesSent: number
    messagesOverrideSet: number
    subscriptions: number
    invitationLinks: number
    qrCodes: number
    messageDeliveries: number
    messageApprovals: number
    messageRevisionsEdited: number
    messagingSettings: number
    approverAssignments: number
    createdCategories: number
    messageViews: number
    channelVisits: number
    createdForms: number
    organizedEvents: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ownedChannels?: boolean | UserCountOutputTypeCountOwnedChannelsArgs
    messagesSent?: boolean | UserCountOutputTypeCountMessagesSentArgs
    messagesOverrideSet?: boolean | UserCountOutputTypeCountMessagesOverrideSetArgs
    subscriptions?: boolean | UserCountOutputTypeCountSubscriptionsArgs
    invitationLinks?: boolean | UserCountOutputTypeCountInvitationLinksArgs
    qrCodes?: boolean | UserCountOutputTypeCountQrCodesArgs
    messageDeliveries?: boolean | UserCountOutputTypeCountMessageDeliveriesArgs
    messageApprovals?: boolean | UserCountOutputTypeCountMessageApprovalsArgs
    messageRevisionsEdited?: boolean | UserCountOutputTypeCountMessageRevisionsEditedArgs
    messagingSettings?: boolean | UserCountOutputTypeCountMessagingSettingsArgs
    approverAssignments?: boolean | UserCountOutputTypeCountApproverAssignmentsArgs
    createdCategories?: boolean | UserCountOutputTypeCountCreatedCategoriesArgs
    messageViews?: boolean | UserCountOutputTypeCountMessageViewsArgs
    channelVisits?: boolean | UserCountOutputTypeCountChannelVisitsArgs
    createdForms?: boolean | UserCountOutputTypeCountCreatedFormsArgs
    organizedEvents?: boolean | UserCountOutputTypeCountOrganizedEventsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedChannelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessagesSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessagesOverrideSetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelSubscriptionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvitationLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationLinkWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountQrCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QrCodeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessageDeliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageDeliveryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessageApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageApprovalWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessageRevisionsEditedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageRevisionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessagingSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserMessagingSettingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApproverAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelApproverWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageCategoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessageViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageViewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChannelVisitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelVisitWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedFormsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrganizedEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }


  /**
   * Count Type ChannelCountOutputType
   */

  export type ChannelCountOutputType = {
    subchannels: number
    messages: number
    subscriptions: number
    invitationLinks: number
    qrCodes: number
    approvers: number
    verificationDocs: number
    categories: number
    messageCategories: number
    visits: number
  }

  export type ChannelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subchannels?: boolean | ChannelCountOutputTypeCountSubchannelsArgs
    messages?: boolean | ChannelCountOutputTypeCountMessagesArgs
    subscriptions?: boolean | ChannelCountOutputTypeCountSubscriptionsArgs
    invitationLinks?: boolean | ChannelCountOutputTypeCountInvitationLinksArgs
    qrCodes?: boolean | ChannelCountOutputTypeCountQrCodesArgs
    approvers?: boolean | ChannelCountOutputTypeCountApproversArgs
    verificationDocs?: boolean | ChannelCountOutputTypeCountVerificationDocsArgs
    categories?: boolean | ChannelCountOutputTypeCountCategoriesArgs
    messageCategories?: boolean | ChannelCountOutputTypeCountMessageCategoriesArgs
    visits?: boolean | ChannelCountOutputTypeCountVisitsArgs
  }

  // Custom InputTypes
  /**
   * ChannelCountOutputType without action
   */
  export type ChannelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCountOutputType
     */
    select?: ChannelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChannelCountOutputType without action
   */
  export type ChannelCountOutputTypeCountSubchannelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelWhereInput
  }

  /**
   * ChannelCountOutputType without action
   */
  export type ChannelCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * ChannelCountOutputType without action
   */
  export type ChannelCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelSubscriptionWhereInput
  }

  /**
   * ChannelCountOutputType without action
   */
  export type ChannelCountOutputTypeCountInvitationLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationLinkWhereInput
  }

  /**
   * ChannelCountOutputType without action
   */
  export type ChannelCountOutputTypeCountQrCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QrCodeWhereInput
  }

  /**
   * ChannelCountOutputType without action
   */
  export type ChannelCountOutputTypeCountApproversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelApproverWhereInput
  }

  /**
   * ChannelCountOutputType without action
   */
  export type ChannelCountOutputTypeCountVerificationDocsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelVerificationDocumentWhereInput
  }

  /**
   * ChannelCountOutputType without action
   */
  export type ChannelCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelCategoryAssignmentWhereInput
  }

  /**
   * ChannelCountOutputType without action
   */
  export type ChannelCountOutputTypeCountMessageCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageCategoryWhereInput
  }

  /**
   * ChannelCountOutputType without action
   */
  export type ChannelCountOutputTypeCountVisitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelVisitWhereInput
  }


  /**
   * Count Type MessageCountOutputType
   */

  export type MessageCountOutputType = {
    deliveries: number
    approvals: number
    attachments: number
    revisions: number
    views: number
  }

  export type MessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deliveries?: boolean | MessageCountOutputTypeCountDeliveriesArgs
    approvals?: boolean | MessageCountOutputTypeCountApprovalsArgs
    attachments?: boolean | MessageCountOutputTypeCountAttachmentsArgs
    revisions?: boolean | MessageCountOutputTypeCountRevisionsArgs
    views?: boolean | MessageCountOutputTypeCountViewsArgs
  }

  // Custom InputTypes
  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCountOutputType
     */
    select?: MessageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountDeliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageDeliveryWhereInput
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageApprovalWhereInput
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageAttachmentWhereInput
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountRevisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageRevisionWhereInput
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageViewWhereInput
  }


  /**
   * Count Type OrganizationCountOutputType
   */

  export type OrganizationCountOutputType = {
    channels: number
  }

  export type OrganizationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    channels?: boolean | OrganizationCountOutputTypeCountChannelsArgs
  }

  // Custom InputTypes
  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationCountOutputType
     */
    select?: OrganizationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountChannelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelWhereInput
  }


  /**
   * Count Type MessageCategoryCountOutputType
   */

  export type MessageCategoryCountOutputType = {
    messages: number
  }

  export type MessageCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | MessageCategoryCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * MessageCategoryCountOutputType without action
   */
  export type MessageCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCategoryCountOutputType
     */
    select?: MessageCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessageCategoryCountOutputType without action
   */
  export type MessageCategoryCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Count Type ChannelCategoryCountOutputType
   */

  export type ChannelCategoryCountOutputType = {
    assignments: number
  }

  export type ChannelCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignments?: boolean | ChannelCategoryCountOutputTypeCountAssignmentsArgs
  }

  // Custom InputTypes
  /**
   * ChannelCategoryCountOutputType without action
   */
  export type ChannelCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCategoryCountOutputType
     */
    select?: ChannelCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChannelCategoryCountOutputType without action
   */
  export type ChannelCategoryCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelCategoryAssignmentWhereInput
  }


  /**
   * Count Type FormCountOutputType
   */

  export type FormCountOutputType = {
    fields: number
    submissions: number
  }

  export type FormCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fields?: boolean | FormCountOutputTypeCountFieldsArgs
    submissions?: boolean | FormCountOutputTypeCountSubmissionsArgs
  }

  // Custom InputTypes
  /**
   * FormCountOutputType without action
   */
  export type FormCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormCountOutputType
     */
    select?: FormCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FormCountOutputType without action
   */
  export type FormCountOutputTypeCountFieldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormFieldWhereInput
  }

  /**
   * FormCountOutputType without action
   */
  export type FormCountOutputTypeCountSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormSubmissionWhereInput
  }


  /**
   * Count Type EventCountOutputType
   */

  export type EventCountOutputType = {
    zones: number
    seats: number
    tickets: number
  }

  export type EventCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zones?: boolean | EventCountOutputTypeCountZonesArgs
    seats?: boolean | EventCountOutputTypeCountSeatsArgs
    tickets?: boolean | EventCountOutputTypeCountTicketsArgs
  }

  // Custom InputTypes
  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCountOutputType
     */
    select?: EventCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountZonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventZoneWhereInput
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountSeatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventSeatWhereInput
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }


  /**
   * Count Type EventZoneCountOutputType
   */

  export type EventZoneCountOutputType = {
    seats: number
    tickets: number
  }

  export type EventZoneCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seats?: boolean | EventZoneCountOutputTypeCountSeatsArgs
    tickets?: boolean | EventZoneCountOutputTypeCountTicketsArgs
  }

  // Custom InputTypes
  /**
   * EventZoneCountOutputType without action
   */
  export type EventZoneCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventZoneCountOutputType
     */
    select?: EventZoneCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EventZoneCountOutputType without action
   */
  export type EventZoneCountOutputTypeCountSeatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventSeatWhereInput
  }

  /**
   * EventZoneCountOutputType without action
   */
  export type EventZoneCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }


  /**
   * Count Type EventSeatCountOutputType
   */

  export type EventSeatCountOutputType = {
    tickets: number
  }

  export type EventSeatCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tickets?: boolean | EventSeatCountOutputTypeCountTicketsArgs
  }

  // Custom InputTypes
  /**
   * EventSeatCountOutputType without action
   */
  export type EventSeatCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSeatCountOutputType
     */
    select?: EventSeatCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EventSeatCountOutputType without action
   */
  export type EventSeatCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    fullName: string | null
    avatarUrl: string | null
    passwordHash: string | null
    deviceId: string | null
    isGuest: boolean | null
    phoneNumber: string | null
    isPhoneVerified: boolean | null
    verificationCode: string | null
    verificationCodeExpiresAt: Date | null
    isAdmin: boolean | null
    isCoordinator: boolean | null
    isDisabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    fullName: string | null
    avatarUrl: string | null
    passwordHash: string | null
    deviceId: string | null
    isGuest: boolean | null
    phoneNumber: string | null
    isPhoneVerified: boolean | null
    verificationCode: string | null
    verificationCodeExpiresAt: Date | null
    isAdmin: boolean | null
    isCoordinator: boolean | null
    isDisabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    username: number
    fullName: number
    avatarUrl: number
    passwordHash: number
    deviceId: number
    isGuest: number
    phoneNumber: number
    isPhoneVerified: number
    verificationCode: number
    verificationCodeExpiresAt: number
    isAdmin: number
    isCoordinator: number
    isDisabled: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    username?: true
    fullName?: true
    avatarUrl?: true
    passwordHash?: true
    deviceId?: true
    isGuest?: true
    phoneNumber?: true
    isPhoneVerified?: true
    verificationCode?: true
    verificationCodeExpiresAt?: true
    isAdmin?: true
    isCoordinator?: true
    isDisabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    username?: true
    fullName?: true
    avatarUrl?: true
    passwordHash?: true
    deviceId?: true
    isGuest?: true
    phoneNumber?: true
    isPhoneVerified?: true
    verificationCode?: true
    verificationCodeExpiresAt?: true
    isAdmin?: true
    isCoordinator?: true
    isDisabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    username?: true
    fullName?: true
    avatarUrl?: true
    passwordHash?: true
    deviceId?: true
    isGuest?: true
    phoneNumber?: true
    isPhoneVerified?: true
    verificationCode?: true
    verificationCodeExpiresAt?: true
    isAdmin?: true
    isCoordinator?: true
    isDisabled?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    username: string
    fullName: string | null
    avatarUrl: string | null
    passwordHash: string | null
    deviceId: string | null
    isGuest: boolean
    phoneNumber: string | null
    isPhoneVerified: boolean
    verificationCode: string | null
    verificationCodeExpiresAt: Date | null
    isAdmin: boolean
    isCoordinator: boolean
    isDisabled: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    fullName?: boolean
    avatarUrl?: boolean
    passwordHash?: boolean
    deviceId?: boolean
    isGuest?: boolean
    phoneNumber?: boolean
    isPhoneVerified?: boolean
    verificationCode?: boolean
    verificationCodeExpiresAt?: boolean
    isAdmin?: boolean
    isCoordinator?: boolean
    isDisabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ownedChannels?: boolean | User$ownedChannelsArgs<ExtArgs>
    messagesSent?: boolean | User$messagesSentArgs<ExtArgs>
    messagesOverrideSet?: boolean | User$messagesOverrideSetArgs<ExtArgs>
    subscriptions?: boolean | User$subscriptionsArgs<ExtArgs>
    invitationLinks?: boolean | User$invitationLinksArgs<ExtArgs>
    qrCodes?: boolean | User$qrCodesArgs<ExtArgs>
    messageDeliveries?: boolean | User$messageDeliveriesArgs<ExtArgs>
    messageApprovals?: boolean | User$messageApprovalsArgs<ExtArgs>
    messageRevisionsEdited?: boolean | User$messageRevisionsEditedArgs<ExtArgs>
    profile?: boolean | User$profileArgs<ExtArgs>
    messagingSettings?: boolean | User$messagingSettingsArgs<ExtArgs>
    approverAssignments?: boolean | User$approverAssignmentsArgs<ExtArgs>
    createdCategories?: boolean | User$createdCategoriesArgs<ExtArgs>
    messageViews?: boolean | User$messageViewsArgs<ExtArgs>
    channelVisits?: boolean | User$channelVisitsArgs<ExtArgs>
    createdForms?: boolean | User$createdFormsArgs<ExtArgs>
    organizedEvents?: boolean | User$organizedEventsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>


  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    username?: boolean
    fullName?: boolean
    avatarUrl?: boolean
    passwordHash?: boolean
    deviceId?: boolean
    isGuest?: boolean
    phoneNumber?: boolean
    isPhoneVerified?: boolean
    verificationCode?: boolean
    verificationCodeExpiresAt?: boolean
    isAdmin?: boolean
    isCoordinator?: boolean
    isDisabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ownedChannels?: boolean | User$ownedChannelsArgs<ExtArgs>
    messagesSent?: boolean | User$messagesSentArgs<ExtArgs>
    messagesOverrideSet?: boolean | User$messagesOverrideSetArgs<ExtArgs>
    subscriptions?: boolean | User$subscriptionsArgs<ExtArgs>
    invitationLinks?: boolean | User$invitationLinksArgs<ExtArgs>
    qrCodes?: boolean | User$qrCodesArgs<ExtArgs>
    messageDeliveries?: boolean | User$messageDeliveriesArgs<ExtArgs>
    messageApprovals?: boolean | User$messageApprovalsArgs<ExtArgs>
    messageRevisionsEdited?: boolean | User$messageRevisionsEditedArgs<ExtArgs>
    profile?: boolean | User$profileArgs<ExtArgs>
    messagingSettings?: boolean | User$messagingSettingsArgs<ExtArgs>
    approverAssignments?: boolean | User$approverAssignmentsArgs<ExtArgs>
    createdCategories?: boolean | User$createdCategoriesArgs<ExtArgs>
    messageViews?: boolean | User$messageViewsArgs<ExtArgs>
    channelVisits?: boolean | User$channelVisitsArgs<ExtArgs>
    createdForms?: boolean | User$createdFormsArgs<ExtArgs>
    organizedEvents?: boolean | User$organizedEventsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      ownedChannels: Prisma.$ChannelPayload<ExtArgs>[]
      messagesSent: Prisma.$MessagePayload<ExtArgs>[]
      messagesOverrideSet: Prisma.$MessagePayload<ExtArgs>[]
      subscriptions: Prisma.$ChannelSubscriptionPayload<ExtArgs>[]
      invitationLinks: Prisma.$InvitationLinkPayload<ExtArgs>[]
      qrCodes: Prisma.$QrCodePayload<ExtArgs>[]
      messageDeliveries: Prisma.$MessageDeliveryPayload<ExtArgs>[]
      messageApprovals: Prisma.$MessageApprovalPayload<ExtArgs>[]
      messageRevisionsEdited: Prisma.$MessageRevisionPayload<ExtArgs>[]
      profile: Prisma.$UserProfilePayload<ExtArgs> | null
      messagingSettings: Prisma.$UserMessagingSettingPayload<ExtArgs>[]
      approverAssignments: Prisma.$ChannelApproverPayload<ExtArgs>[]
      createdCategories: Prisma.$MessageCategoryPayload<ExtArgs>[]
      messageViews: Prisma.$MessageViewPayload<ExtArgs>[]
      channelVisits: Prisma.$ChannelVisitPayload<ExtArgs>[]
      createdForms: Prisma.$FormPayload<ExtArgs>[]
      organizedEvents: Prisma.$EventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      username: string
      fullName: string | null
      avatarUrl: string | null
      passwordHash: string | null
      deviceId: string | null
      isGuest: boolean
      phoneNumber: string | null
      isPhoneVerified: boolean
      verificationCode: string | null
      verificationCodeExpiresAt: Date | null
      isAdmin: boolean
      isCoordinator: boolean
      isDisabled: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ownedChannels<T extends User$ownedChannelsArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedChannelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findMany"> | Null>
    messagesSent<T extends User$messagesSentArgs<ExtArgs> = {}>(args?: Subset<T, User$messagesSentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    messagesOverrideSet<T extends User$messagesOverrideSetArgs<ExtArgs> = {}>(args?: Subset<T, User$messagesOverrideSetArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    subscriptions<T extends User$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, User$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelSubscriptionPayload<ExtArgs>, T, "findMany"> | Null>
    invitationLinks<T extends User$invitationLinksArgs<ExtArgs> = {}>(args?: Subset<T, User$invitationLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationLinkPayload<ExtArgs>, T, "findMany"> | Null>
    qrCodes<T extends User$qrCodesArgs<ExtArgs> = {}>(args?: Subset<T, User$qrCodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QrCodePayload<ExtArgs>, T, "findMany"> | Null>
    messageDeliveries<T extends User$messageDeliveriesArgs<ExtArgs> = {}>(args?: Subset<T, User$messageDeliveriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageDeliveryPayload<ExtArgs>, T, "findMany"> | Null>
    messageApprovals<T extends User$messageApprovalsArgs<ExtArgs> = {}>(args?: Subset<T, User$messageApprovalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageApprovalPayload<ExtArgs>, T, "findMany"> | Null>
    messageRevisionsEdited<T extends User$messageRevisionsEditedArgs<ExtArgs> = {}>(args?: Subset<T, User$messageRevisionsEditedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageRevisionPayload<ExtArgs>, T, "findMany"> | Null>
    profile<T extends User$profileArgs<ExtArgs> = {}>(args?: Subset<T, User$profileArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    messagingSettings<T extends User$messagingSettingsArgs<ExtArgs> = {}>(args?: Subset<T, User$messagingSettingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserMessagingSettingPayload<ExtArgs>, T, "findMany"> | Null>
    approverAssignments<T extends User$approverAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$approverAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelApproverPayload<ExtArgs>, T, "findMany"> | Null>
    createdCategories<T extends User$createdCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageCategoryPayload<ExtArgs>, T, "findMany"> | Null>
    messageViews<T extends User$messageViewsArgs<ExtArgs> = {}>(args?: Subset<T, User$messageViewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageViewPayload<ExtArgs>, T, "findMany"> | Null>
    channelVisits<T extends User$channelVisitsArgs<ExtArgs> = {}>(args?: Subset<T, User$channelVisitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelVisitPayload<ExtArgs>, T, "findMany"> | Null>
    createdForms<T extends User$createdFormsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdFormsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "findMany"> | Null>
    organizedEvents<T extends User$organizedEventsArgs<ExtArgs> = {}>(args?: Subset<T, User$organizedEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly fullName: FieldRef<"User", 'String'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly deviceId: FieldRef<"User", 'String'>
    readonly isGuest: FieldRef<"User", 'Boolean'>
    readonly phoneNumber: FieldRef<"User", 'String'>
    readonly isPhoneVerified: FieldRef<"User", 'Boolean'>
    readonly verificationCode: FieldRef<"User", 'String'>
    readonly verificationCodeExpiresAt: FieldRef<"User", 'DateTime'>
    readonly isAdmin: FieldRef<"User", 'Boolean'>
    readonly isCoordinator: FieldRef<"User", 'Boolean'>
    readonly isDisabled: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.ownedChannels
   */
  export type User$ownedChannelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    where?: ChannelWhereInput
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    cursor?: ChannelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * User.messagesSent
   */
  export type User$messagesSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.messagesOverrideSet
   */
  export type User$messagesOverrideSetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.subscriptions
   */
  export type User$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelSubscription
     */
    select?: ChannelSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelSubscriptionInclude<ExtArgs> | null
    where?: ChannelSubscriptionWhereInput
    orderBy?: ChannelSubscriptionOrderByWithRelationInput | ChannelSubscriptionOrderByWithRelationInput[]
    cursor?: ChannelSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChannelSubscriptionScalarFieldEnum | ChannelSubscriptionScalarFieldEnum[]
  }

  /**
   * User.invitationLinks
   */
  export type User$invitationLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationLink
     */
    select?: InvitationLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationLinkInclude<ExtArgs> | null
    where?: InvitationLinkWhereInput
    orderBy?: InvitationLinkOrderByWithRelationInput | InvitationLinkOrderByWithRelationInput[]
    cursor?: InvitationLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvitationLinkScalarFieldEnum | InvitationLinkScalarFieldEnum[]
  }

  /**
   * User.qrCodes
   */
  export type User$qrCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QrCode
     */
    select?: QrCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QrCodeInclude<ExtArgs> | null
    where?: QrCodeWhereInput
    orderBy?: QrCodeOrderByWithRelationInput | QrCodeOrderByWithRelationInput[]
    cursor?: QrCodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QrCodeScalarFieldEnum | QrCodeScalarFieldEnum[]
  }

  /**
   * User.messageDeliveries
   */
  export type User$messageDeliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageDelivery
     */
    select?: MessageDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageDeliveryInclude<ExtArgs> | null
    where?: MessageDeliveryWhereInput
    orderBy?: MessageDeliveryOrderByWithRelationInput | MessageDeliveryOrderByWithRelationInput[]
    cursor?: MessageDeliveryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageDeliveryScalarFieldEnum | MessageDeliveryScalarFieldEnum[]
  }

  /**
   * User.messageApprovals
   */
  export type User$messageApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageApproval
     */
    select?: MessageApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageApprovalInclude<ExtArgs> | null
    where?: MessageApprovalWhereInput
    orderBy?: MessageApprovalOrderByWithRelationInput | MessageApprovalOrderByWithRelationInput[]
    cursor?: MessageApprovalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageApprovalScalarFieldEnum | MessageApprovalScalarFieldEnum[]
  }

  /**
   * User.messageRevisionsEdited
   */
  export type User$messageRevisionsEditedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRevision
     */
    select?: MessageRevisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageRevisionInclude<ExtArgs> | null
    where?: MessageRevisionWhereInput
    orderBy?: MessageRevisionOrderByWithRelationInput | MessageRevisionOrderByWithRelationInput[]
    cursor?: MessageRevisionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageRevisionScalarFieldEnum | MessageRevisionScalarFieldEnum[]
  }

  /**
   * User.profile
   */
  export type User$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    where?: UserProfileWhereInput
  }

  /**
   * User.messagingSettings
   */
  export type User$messagingSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMessagingSetting
     */
    select?: UserMessagingSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMessagingSettingInclude<ExtArgs> | null
    where?: UserMessagingSettingWhereInput
    orderBy?: UserMessagingSettingOrderByWithRelationInput | UserMessagingSettingOrderByWithRelationInput[]
    cursor?: UserMessagingSettingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserMessagingSettingScalarFieldEnum | UserMessagingSettingScalarFieldEnum[]
  }

  /**
   * User.approverAssignments
   */
  export type User$approverAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelApprover
     */
    select?: ChannelApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelApproverInclude<ExtArgs> | null
    where?: ChannelApproverWhereInput
    orderBy?: ChannelApproverOrderByWithRelationInput | ChannelApproverOrderByWithRelationInput[]
    cursor?: ChannelApproverWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChannelApproverScalarFieldEnum | ChannelApproverScalarFieldEnum[]
  }

  /**
   * User.createdCategories
   */
  export type User$createdCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCategory
     */
    select?: MessageCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageCategoryInclude<ExtArgs> | null
    where?: MessageCategoryWhereInput
    orderBy?: MessageCategoryOrderByWithRelationInput | MessageCategoryOrderByWithRelationInput[]
    cursor?: MessageCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageCategoryScalarFieldEnum | MessageCategoryScalarFieldEnum[]
  }

  /**
   * User.messageViews
   */
  export type User$messageViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageView
     */
    select?: MessageViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageViewInclude<ExtArgs> | null
    where?: MessageViewWhereInput
    orderBy?: MessageViewOrderByWithRelationInput | MessageViewOrderByWithRelationInput[]
    cursor?: MessageViewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageViewScalarFieldEnum | MessageViewScalarFieldEnum[]
  }

  /**
   * User.channelVisits
   */
  export type User$channelVisitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelVisit
     */
    select?: ChannelVisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelVisitInclude<ExtArgs> | null
    where?: ChannelVisitWhereInput
    orderBy?: ChannelVisitOrderByWithRelationInput | ChannelVisitOrderByWithRelationInput[]
    cursor?: ChannelVisitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChannelVisitScalarFieldEnum | ChannelVisitScalarFieldEnum[]
  }

  /**
   * User.createdForms
   */
  export type User$createdFormsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    where?: FormWhereInput
    orderBy?: FormOrderByWithRelationInput | FormOrderByWithRelationInput[]
    cursor?: FormWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormScalarFieldEnum | FormScalarFieldEnum[]
  }

  /**
   * User.organizedEvents
   */
  export type User$organizedEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Channel
   */

  export type AggregateChannel = {
    _count: ChannelCountAggregateOutputType | null
    _avg: ChannelAvgAggregateOutputType | null
    _sum: ChannelSumAggregateOutputType | null
    _min: ChannelMinAggregateOutputType | null
    _max: ChannelMaxAggregateOutputType | null
  }

  export type ChannelAvgAggregateOutputType = {
    memberCount: number | null
  }

  export type ChannelSumAggregateOutputType = {
    memberCount: number | null
  }

  export type ChannelMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    websiteUrl: string | null
    logoUrl: string | null
    icon: string | null
    parentId: string | null
    ownerId: string | null
    organizationId: string | null
    isPublic: boolean | null
    isHidden: boolean | null
    searchExactOnly: boolean | null
    passwordHash: string | null
    referenceCode: string | null
    verificationStatus: $Enums.VerificationStatus | null
    approvalPolicy: $Enums.ApprovalPolicy | null
    memberCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChannelMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    websiteUrl: string | null
    logoUrl: string | null
    icon: string | null
    parentId: string | null
    ownerId: string | null
    organizationId: string | null
    isPublic: boolean | null
    isHidden: boolean | null
    searchExactOnly: boolean | null
    passwordHash: string | null
    referenceCode: string | null
    verificationStatus: $Enums.VerificationStatus | null
    approvalPolicy: $Enums.ApprovalPolicy | null
    memberCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChannelCountAggregateOutputType = {
    id: number
    title: number
    description: number
    websiteUrl: number
    socialLinks: number
    logoUrl: number
    icon: number
    parentId: number
    ownerId: number
    organizationId: number
    isPublic: number
    isHidden: number
    searchExactOnly: number
    passwordHash: number
    referenceCode: number
    verificationStatus: number
    approvalPolicy: number
    memberCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChannelAvgAggregateInputType = {
    memberCount?: true
  }

  export type ChannelSumAggregateInputType = {
    memberCount?: true
  }

  export type ChannelMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    websiteUrl?: true
    logoUrl?: true
    icon?: true
    parentId?: true
    ownerId?: true
    organizationId?: true
    isPublic?: true
    isHidden?: true
    searchExactOnly?: true
    passwordHash?: true
    referenceCode?: true
    verificationStatus?: true
    approvalPolicy?: true
    memberCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChannelMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    websiteUrl?: true
    logoUrl?: true
    icon?: true
    parentId?: true
    ownerId?: true
    organizationId?: true
    isPublic?: true
    isHidden?: true
    searchExactOnly?: true
    passwordHash?: true
    referenceCode?: true
    verificationStatus?: true
    approvalPolicy?: true
    memberCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChannelCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    websiteUrl?: true
    socialLinks?: true
    logoUrl?: true
    icon?: true
    parentId?: true
    ownerId?: true
    organizationId?: true
    isPublic?: true
    isHidden?: true
    searchExactOnly?: true
    passwordHash?: true
    referenceCode?: true
    verificationStatus?: true
    approvalPolicy?: true
    memberCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChannelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Channel to aggregate.
     */
    where?: ChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Channels to fetch.
     */
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Channels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Channels
    **/
    _count?: true | ChannelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChannelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChannelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChannelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChannelMaxAggregateInputType
  }

  export type GetChannelAggregateType<T extends ChannelAggregateArgs> = {
        [P in keyof T & keyof AggregateChannel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChannel[P]>
      : GetScalarType<T[P], AggregateChannel[P]>
  }




  export type ChannelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelWhereInput
    orderBy?: ChannelOrderByWithAggregationInput | ChannelOrderByWithAggregationInput[]
    by: ChannelScalarFieldEnum[] | ChannelScalarFieldEnum
    having?: ChannelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChannelCountAggregateInputType | true
    _avg?: ChannelAvgAggregateInputType
    _sum?: ChannelSumAggregateInputType
    _min?: ChannelMinAggregateInputType
    _max?: ChannelMaxAggregateInputType
  }

  export type ChannelGroupByOutputType = {
    id: string
    title: string
    description: string | null
    websiteUrl: string | null
    socialLinks: JsonValue | null
    logoUrl: string | null
    icon: string
    parentId: string | null
    ownerId: string
    organizationId: string
    isPublic: boolean
    isHidden: boolean
    searchExactOnly: boolean
    passwordHash: string | null
    referenceCode: string | null
    verificationStatus: $Enums.VerificationStatus
    approvalPolicy: $Enums.ApprovalPolicy
    memberCount: number
    createdAt: Date
    updatedAt: Date
    _count: ChannelCountAggregateOutputType | null
    _avg: ChannelAvgAggregateOutputType | null
    _sum: ChannelSumAggregateOutputType | null
    _min: ChannelMinAggregateOutputType | null
    _max: ChannelMaxAggregateOutputType | null
  }

  type GetChannelGroupByPayload<T extends ChannelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChannelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChannelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChannelGroupByOutputType[P]>
            : GetScalarType<T[P], ChannelGroupByOutputType[P]>
        }
      >
    >


  export type ChannelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    websiteUrl?: boolean
    socialLinks?: boolean
    logoUrl?: boolean
    icon?: boolean
    parentId?: boolean
    ownerId?: boolean
    organizationId?: boolean
    isPublic?: boolean
    isHidden?: boolean
    searchExactOnly?: boolean
    passwordHash?: boolean
    referenceCode?: boolean
    verificationStatus?: boolean
    approvalPolicy?: boolean
    memberCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    parent?: boolean | Channel$parentArgs<ExtArgs>
    subchannels?: boolean | Channel$subchannelsArgs<ExtArgs>
    messages?: boolean | Channel$messagesArgs<ExtArgs>
    subscriptions?: boolean | Channel$subscriptionsArgs<ExtArgs>
    invitationLinks?: boolean | Channel$invitationLinksArgs<ExtArgs>
    qrCodes?: boolean | Channel$qrCodesArgs<ExtArgs>
    approvers?: boolean | Channel$approversArgs<ExtArgs>
    verificationDocs?: boolean | Channel$verificationDocsArgs<ExtArgs>
    categories?: boolean | Channel$categoriesArgs<ExtArgs>
    messageCategories?: boolean | Channel$messageCategoriesArgs<ExtArgs>
    visits?: boolean | Channel$visitsArgs<ExtArgs>
    _count?: boolean | ChannelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["channel"]>


  export type ChannelSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    websiteUrl?: boolean
    socialLinks?: boolean
    logoUrl?: boolean
    icon?: boolean
    parentId?: boolean
    ownerId?: boolean
    organizationId?: boolean
    isPublic?: boolean
    isHidden?: boolean
    searchExactOnly?: boolean
    passwordHash?: boolean
    referenceCode?: boolean
    verificationStatus?: boolean
    approvalPolicy?: boolean
    memberCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChannelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    parent?: boolean | Channel$parentArgs<ExtArgs>
    subchannels?: boolean | Channel$subchannelsArgs<ExtArgs>
    messages?: boolean | Channel$messagesArgs<ExtArgs>
    subscriptions?: boolean | Channel$subscriptionsArgs<ExtArgs>
    invitationLinks?: boolean | Channel$invitationLinksArgs<ExtArgs>
    qrCodes?: boolean | Channel$qrCodesArgs<ExtArgs>
    approvers?: boolean | Channel$approversArgs<ExtArgs>
    verificationDocs?: boolean | Channel$verificationDocsArgs<ExtArgs>
    categories?: boolean | Channel$categoriesArgs<ExtArgs>
    messageCategories?: boolean | Channel$messageCategoriesArgs<ExtArgs>
    visits?: boolean | Channel$visitsArgs<ExtArgs>
    _count?: boolean | ChannelCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ChannelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Channel"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      organization: Prisma.$OrganizationPayload<ExtArgs>
      parent: Prisma.$ChannelPayload<ExtArgs> | null
      subchannels: Prisma.$ChannelPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
      subscriptions: Prisma.$ChannelSubscriptionPayload<ExtArgs>[]
      invitationLinks: Prisma.$InvitationLinkPayload<ExtArgs>[]
      qrCodes: Prisma.$QrCodePayload<ExtArgs>[]
      approvers: Prisma.$ChannelApproverPayload<ExtArgs>[]
      verificationDocs: Prisma.$ChannelVerificationDocumentPayload<ExtArgs>[]
      categories: Prisma.$ChannelCategoryAssignmentPayload<ExtArgs>[]
      messageCategories: Prisma.$MessageCategoryPayload<ExtArgs>[]
      visits: Prisma.$ChannelVisitPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      websiteUrl: string | null
      socialLinks: Prisma.JsonValue | null
      logoUrl: string | null
      icon: string
      parentId: string | null
      ownerId: string
      organizationId: string
      isPublic: boolean
      isHidden: boolean
      searchExactOnly: boolean
      passwordHash: string | null
      referenceCode: string | null
      verificationStatus: $Enums.VerificationStatus
      approvalPolicy: $Enums.ApprovalPolicy
      memberCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["channel"]>
    composites: {}
  }

  type ChannelGetPayload<S extends boolean | null | undefined | ChannelDefaultArgs> = $Result.GetResult<Prisma.$ChannelPayload, S>

  type ChannelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChannelFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChannelCountAggregateInputType | true
    }

  export interface ChannelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Channel'], meta: { name: 'Channel' } }
    /**
     * Find zero or one Channel that matches the filter.
     * @param {ChannelFindUniqueArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChannelFindUniqueArgs>(args: SelectSubset<T, ChannelFindUniqueArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Channel that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChannelFindUniqueOrThrowArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChannelFindUniqueOrThrowArgs>(args: SelectSubset<T, ChannelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Channel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelFindFirstArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChannelFindFirstArgs>(args?: SelectSubset<T, ChannelFindFirstArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Channel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelFindFirstOrThrowArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChannelFindFirstOrThrowArgs>(args?: SelectSubset<T, ChannelFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Channels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Channels
     * const channels = await prisma.channel.findMany()
     * 
     * // Get first 10 Channels
     * const channels = await prisma.channel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const channelWithIdOnly = await prisma.channel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChannelFindManyArgs>(args?: SelectSubset<T, ChannelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Channel.
     * @param {ChannelCreateArgs} args - Arguments to create a Channel.
     * @example
     * // Create one Channel
     * const Channel = await prisma.channel.create({
     *   data: {
     *     // ... data to create a Channel
     *   }
     * })
     * 
     */
    create<T extends ChannelCreateArgs>(args: SelectSubset<T, ChannelCreateArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Channels.
     * @param {ChannelCreateManyArgs} args - Arguments to create many Channels.
     * @example
     * // Create many Channels
     * const channel = await prisma.channel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChannelCreateManyArgs>(args?: SelectSubset<T, ChannelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Channel.
     * @param {ChannelDeleteArgs} args - Arguments to delete one Channel.
     * @example
     * // Delete one Channel
     * const Channel = await prisma.channel.delete({
     *   where: {
     *     // ... filter to delete one Channel
     *   }
     * })
     * 
     */
    delete<T extends ChannelDeleteArgs>(args: SelectSubset<T, ChannelDeleteArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Channel.
     * @param {ChannelUpdateArgs} args - Arguments to update one Channel.
     * @example
     * // Update one Channel
     * const channel = await prisma.channel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChannelUpdateArgs>(args: SelectSubset<T, ChannelUpdateArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Channels.
     * @param {ChannelDeleteManyArgs} args - Arguments to filter Channels to delete.
     * @example
     * // Delete a few Channels
     * const { count } = await prisma.channel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChannelDeleteManyArgs>(args?: SelectSubset<T, ChannelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Channels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Channels
     * const channel = await prisma.channel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChannelUpdateManyArgs>(args: SelectSubset<T, ChannelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Channel.
     * @param {ChannelUpsertArgs} args - Arguments to update or create a Channel.
     * @example
     * // Update or create a Channel
     * const channel = await prisma.channel.upsert({
     *   create: {
     *     // ... data to create a Channel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Channel we want to update
     *   }
     * })
     */
    upsert<T extends ChannelUpsertArgs>(args: SelectSubset<T, ChannelUpsertArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Channels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelCountArgs} args - Arguments to filter Channels to count.
     * @example
     * // Count the number of Channels
     * const count = await prisma.channel.count({
     *   where: {
     *     // ... the filter for the Channels we want to count
     *   }
     * })
    **/
    count<T extends ChannelCountArgs>(
      args?: Subset<T, ChannelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChannelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Channel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChannelAggregateArgs>(args: Subset<T, ChannelAggregateArgs>): Prisma.PrismaPromise<GetChannelAggregateType<T>>

    /**
     * Group by Channel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChannelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChannelGroupByArgs['orderBy'] }
        : { orderBy?: ChannelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChannelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChannelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Channel model
   */
  readonly fields: ChannelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Channel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChannelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    parent<T extends Channel$parentArgs<ExtArgs> = {}>(args?: Subset<T, Channel$parentArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    subchannels<T extends Channel$subchannelsArgs<ExtArgs> = {}>(args?: Subset<T, Channel$subchannelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findMany"> | Null>
    messages<T extends Channel$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Channel$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    subscriptions<T extends Channel$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Channel$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelSubscriptionPayload<ExtArgs>, T, "findMany"> | Null>
    invitationLinks<T extends Channel$invitationLinksArgs<ExtArgs> = {}>(args?: Subset<T, Channel$invitationLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationLinkPayload<ExtArgs>, T, "findMany"> | Null>
    qrCodes<T extends Channel$qrCodesArgs<ExtArgs> = {}>(args?: Subset<T, Channel$qrCodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QrCodePayload<ExtArgs>, T, "findMany"> | Null>
    approvers<T extends Channel$approversArgs<ExtArgs> = {}>(args?: Subset<T, Channel$approversArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelApproverPayload<ExtArgs>, T, "findMany"> | Null>
    verificationDocs<T extends Channel$verificationDocsArgs<ExtArgs> = {}>(args?: Subset<T, Channel$verificationDocsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelVerificationDocumentPayload<ExtArgs>, T, "findMany"> | Null>
    categories<T extends Channel$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, Channel$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelCategoryAssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    messageCategories<T extends Channel$messageCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, Channel$messageCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageCategoryPayload<ExtArgs>, T, "findMany"> | Null>
    visits<T extends Channel$visitsArgs<ExtArgs> = {}>(args?: Subset<T, Channel$visitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelVisitPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Channel model
   */ 
  interface ChannelFieldRefs {
    readonly id: FieldRef<"Channel", 'String'>
    readonly title: FieldRef<"Channel", 'String'>
    readonly description: FieldRef<"Channel", 'String'>
    readonly websiteUrl: FieldRef<"Channel", 'String'>
    readonly socialLinks: FieldRef<"Channel", 'Json'>
    readonly logoUrl: FieldRef<"Channel", 'String'>
    readonly icon: FieldRef<"Channel", 'String'>
    readonly parentId: FieldRef<"Channel", 'String'>
    readonly ownerId: FieldRef<"Channel", 'String'>
    readonly organizationId: FieldRef<"Channel", 'String'>
    readonly isPublic: FieldRef<"Channel", 'Boolean'>
    readonly isHidden: FieldRef<"Channel", 'Boolean'>
    readonly searchExactOnly: FieldRef<"Channel", 'Boolean'>
    readonly passwordHash: FieldRef<"Channel", 'String'>
    readonly referenceCode: FieldRef<"Channel", 'String'>
    readonly verificationStatus: FieldRef<"Channel", 'VerificationStatus'>
    readonly approvalPolicy: FieldRef<"Channel", 'ApprovalPolicy'>
    readonly memberCount: FieldRef<"Channel", 'Int'>
    readonly createdAt: FieldRef<"Channel", 'DateTime'>
    readonly updatedAt: FieldRef<"Channel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Channel findUnique
   */
  export type ChannelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter, which Channel to fetch.
     */
    where: ChannelWhereUniqueInput
  }

  /**
   * Channel findUniqueOrThrow
   */
  export type ChannelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter, which Channel to fetch.
     */
    where: ChannelWhereUniqueInput
  }

  /**
   * Channel findFirst
   */
  export type ChannelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter, which Channel to fetch.
     */
    where?: ChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Channels to fetch.
     */
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Channels.
     */
    cursor?: ChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Channels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Channels.
     */
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * Channel findFirstOrThrow
   */
  export type ChannelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter, which Channel to fetch.
     */
    where?: ChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Channels to fetch.
     */
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Channels.
     */
    cursor?: ChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Channels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Channels.
     */
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * Channel findMany
   */
  export type ChannelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter, which Channels to fetch.
     */
    where?: ChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Channels to fetch.
     */
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Channels.
     */
    cursor?: ChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Channels.
     */
    skip?: number
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * Channel create
   */
  export type ChannelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * The data needed to create a Channel.
     */
    data: XOR<ChannelCreateInput, ChannelUncheckedCreateInput>
  }

  /**
   * Channel createMany
   */
  export type ChannelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Channels.
     */
    data: ChannelCreateManyInput | ChannelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Channel update
   */
  export type ChannelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * The data needed to update a Channel.
     */
    data: XOR<ChannelUpdateInput, ChannelUncheckedUpdateInput>
    /**
     * Choose, which Channel to update.
     */
    where: ChannelWhereUniqueInput
  }

  /**
   * Channel updateMany
   */
  export type ChannelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Channels.
     */
    data: XOR<ChannelUpdateManyMutationInput, ChannelUncheckedUpdateManyInput>
    /**
     * Filter which Channels to update
     */
    where?: ChannelWhereInput
  }

  /**
   * Channel upsert
   */
  export type ChannelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * The filter to search for the Channel to update in case it exists.
     */
    where: ChannelWhereUniqueInput
    /**
     * In case the Channel found by the `where` argument doesn't exist, create a new Channel with this data.
     */
    create: XOR<ChannelCreateInput, ChannelUncheckedCreateInput>
    /**
     * In case the Channel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChannelUpdateInput, ChannelUncheckedUpdateInput>
  }

  /**
   * Channel delete
   */
  export type ChannelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter which Channel to delete.
     */
    where: ChannelWhereUniqueInput
  }

  /**
   * Channel deleteMany
   */
  export type ChannelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Channels to delete
     */
    where?: ChannelWhereInput
  }

  /**
   * Channel.parent
   */
  export type Channel$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    where?: ChannelWhereInput
  }

  /**
   * Channel.subchannels
   */
  export type Channel$subchannelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    where?: ChannelWhereInput
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    cursor?: ChannelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * Channel.messages
   */
  export type Channel$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Channel.subscriptions
   */
  export type Channel$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelSubscription
     */
    select?: ChannelSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelSubscriptionInclude<ExtArgs> | null
    where?: ChannelSubscriptionWhereInput
    orderBy?: ChannelSubscriptionOrderByWithRelationInput | ChannelSubscriptionOrderByWithRelationInput[]
    cursor?: ChannelSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChannelSubscriptionScalarFieldEnum | ChannelSubscriptionScalarFieldEnum[]
  }

  /**
   * Channel.invitationLinks
   */
  export type Channel$invitationLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationLink
     */
    select?: InvitationLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationLinkInclude<ExtArgs> | null
    where?: InvitationLinkWhereInput
    orderBy?: InvitationLinkOrderByWithRelationInput | InvitationLinkOrderByWithRelationInput[]
    cursor?: InvitationLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvitationLinkScalarFieldEnum | InvitationLinkScalarFieldEnum[]
  }

  /**
   * Channel.qrCodes
   */
  export type Channel$qrCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QrCode
     */
    select?: QrCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QrCodeInclude<ExtArgs> | null
    where?: QrCodeWhereInput
    orderBy?: QrCodeOrderByWithRelationInput | QrCodeOrderByWithRelationInput[]
    cursor?: QrCodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QrCodeScalarFieldEnum | QrCodeScalarFieldEnum[]
  }

  /**
   * Channel.approvers
   */
  export type Channel$approversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelApprover
     */
    select?: ChannelApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelApproverInclude<ExtArgs> | null
    where?: ChannelApproverWhereInput
    orderBy?: ChannelApproverOrderByWithRelationInput | ChannelApproverOrderByWithRelationInput[]
    cursor?: ChannelApproverWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChannelApproverScalarFieldEnum | ChannelApproverScalarFieldEnum[]
  }

  /**
   * Channel.verificationDocs
   */
  export type Channel$verificationDocsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelVerificationDocument
     */
    select?: ChannelVerificationDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelVerificationDocumentInclude<ExtArgs> | null
    where?: ChannelVerificationDocumentWhereInput
    orderBy?: ChannelVerificationDocumentOrderByWithRelationInput | ChannelVerificationDocumentOrderByWithRelationInput[]
    cursor?: ChannelVerificationDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChannelVerificationDocumentScalarFieldEnum | ChannelVerificationDocumentScalarFieldEnum[]
  }

  /**
   * Channel.categories
   */
  export type Channel$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCategoryAssignment
     */
    select?: ChannelCategoryAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelCategoryAssignmentInclude<ExtArgs> | null
    where?: ChannelCategoryAssignmentWhereInput
    orderBy?: ChannelCategoryAssignmentOrderByWithRelationInput | ChannelCategoryAssignmentOrderByWithRelationInput[]
    cursor?: ChannelCategoryAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChannelCategoryAssignmentScalarFieldEnum | ChannelCategoryAssignmentScalarFieldEnum[]
  }

  /**
   * Channel.messageCategories
   */
  export type Channel$messageCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCategory
     */
    select?: MessageCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageCategoryInclude<ExtArgs> | null
    where?: MessageCategoryWhereInput
    orderBy?: MessageCategoryOrderByWithRelationInput | MessageCategoryOrderByWithRelationInput[]
    cursor?: MessageCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageCategoryScalarFieldEnum | MessageCategoryScalarFieldEnum[]
  }

  /**
   * Channel.visits
   */
  export type Channel$visitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelVisit
     */
    select?: ChannelVisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelVisitInclude<ExtArgs> | null
    where?: ChannelVisitWhereInput
    orderBy?: ChannelVisitOrderByWithRelationInput | ChannelVisitOrderByWithRelationInput[]
    cursor?: ChannelVisitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChannelVisitScalarFieldEnum | ChannelVisitScalarFieldEnum[]
  }

  /**
   * Channel without action
   */
  export type ChannelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageAvgAggregateOutputType = {
    durationSeconds: number | null
  }

  export type MessageSumAggregateOutputType = {
    durationSeconds: number | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    channelId: string | null
    senderId: string | null
    categoryId: string | null
    content: string | null
    durationSeconds: number | null
    expiresAt: Date | null
    isEmergency: boolean | null
    isImmediate: boolean | null
    priority: $Enums.MessagePriority | null
    approvalOverride: $Enums.ApprovalPolicy | null
    approvalOverrideSetBy: string | null
    approvalOverrideSetAt: Date | null
    deliveryMethod: $Enums.DeliveryMethod | null
    eventAt: Date | null
    publishedAt: Date | null
    state: $Enums.MessageState | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    channelId: string | null
    senderId: string | null
    categoryId: string | null
    content: string | null
    durationSeconds: number | null
    expiresAt: Date | null
    isEmergency: boolean | null
    isImmediate: boolean | null
    priority: $Enums.MessagePriority | null
    approvalOverride: $Enums.ApprovalPolicy | null
    approvalOverrideSetBy: string | null
    approvalOverrideSetAt: Date | null
    deliveryMethod: $Enums.DeliveryMethod | null
    eventAt: Date | null
    publishedAt: Date | null
    state: $Enums.MessageState | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    channelId: number
    senderId: number
    categoryId: number
    content: number
    durationSeconds: number
    expiresAt: number
    isEmergency: number
    isImmediate: number
    priority: number
    approvalOverride: number
    approvalOverrideSetBy: number
    approvalOverrideSetAt: number
    deliveryMethod: number
    eventAt: number
    publishedAt: number
    state: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MessageAvgAggregateInputType = {
    durationSeconds?: true
  }

  export type MessageSumAggregateInputType = {
    durationSeconds?: true
  }

  export type MessageMinAggregateInputType = {
    id?: true
    channelId?: true
    senderId?: true
    categoryId?: true
    content?: true
    durationSeconds?: true
    expiresAt?: true
    isEmergency?: true
    isImmediate?: true
    priority?: true
    approvalOverride?: true
    approvalOverrideSetBy?: true
    approvalOverrideSetAt?: true
    deliveryMethod?: true
    eventAt?: true
    publishedAt?: true
    state?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    channelId?: true
    senderId?: true
    categoryId?: true
    content?: true
    durationSeconds?: true
    expiresAt?: true
    isEmergency?: true
    isImmediate?: true
    priority?: true
    approvalOverride?: true
    approvalOverrideSetBy?: true
    approvalOverrideSetAt?: true
    deliveryMethod?: true
    eventAt?: true
    publishedAt?: true
    state?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    channelId?: true
    senderId?: true
    categoryId?: true
    content?: true
    durationSeconds?: true
    expiresAt?: true
    isEmergency?: true
    isImmediate?: true
    priority?: true
    approvalOverride?: true
    approvalOverrideSetBy?: true
    approvalOverrideSetAt?: true
    deliveryMethod?: true
    eventAt?: true
    publishedAt?: true
    state?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _avg?: MessageAvgAggregateInputType
    _sum?: MessageSumAggregateInputType
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    channelId: string
    senderId: string
    categoryId: string
    content: string
    durationSeconds: number
    expiresAt: Date | null
    isEmergency: boolean
    isImmediate: boolean
    priority: $Enums.MessagePriority
    approvalOverride: $Enums.ApprovalPolicy | null
    approvalOverrideSetBy: string | null
    approvalOverrideSetAt: Date | null
    deliveryMethod: $Enums.DeliveryMethod
    eventAt: Date | null
    publishedAt: Date | null
    state: $Enums.MessageState
    createdAt: Date
    updatedAt: Date
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    channelId?: boolean
    senderId?: boolean
    categoryId?: boolean
    content?: boolean
    durationSeconds?: boolean
    expiresAt?: boolean
    isEmergency?: boolean
    isImmediate?: boolean
    priority?: boolean
    approvalOverride?: boolean
    approvalOverrideSetBy?: boolean
    approvalOverrideSetAt?: boolean
    deliveryMethod?: boolean
    eventAt?: boolean
    publishedAt?: boolean
    state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    channel?: boolean | ChannelDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
    category?: boolean | MessageCategoryDefaultArgs<ExtArgs>
    overrideSetter?: boolean | Message$overrideSetterArgs<ExtArgs>
    deliveries?: boolean | Message$deliveriesArgs<ExtArgs>
    approvals?: boolean | Message$approvalsArgs<ExtArgs>
    attachments?: boolean | Message$attachmentsArgs<ExtArgs>
    revisions?: boolean | Message$revisionsArgs<ExtArgs>
    views?: boolean | Message$viewsArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>


  export type MessageSelectScalar = {
    id?: boolean
    channelId?: boolean
    senderId?: boolean
    categoryId?: boolean
    content?: boolean
    durationSeconds?: boolean
    expiresAt?: boolean
    isEmergency?: boolean
    isImmediate?: boolean
    priority?: boolean
    approvalOverride?: boolean
    approvalOverrideSetBy?: boolean
    approvalOverrideSetAt?: boolean
    deliveryMethod?: boolean
    eventAt?: boolean
    publishedAt?: boolean
    state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    channel?: boolean | ChannelDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
    category?: boolean | MessageCategoryDefaultArgs<ExtArgs>
    overrideSetter?: boolean | Message$overrideSetterArgs<ExtArgs>
    deliveries?: boolean | Message$deliveriesArgs<ExtArgs>
    approvals?: boolean | Message$approvalsArgs<ExtArgs>
    attachments?: boolean | Message$attachmentsArgs<ExtArgs>
    revisions?: boolean | Message$revisionsArgs<ExtArgs>
    views?: boolean | Message$viewsArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      channel: Prisma.$ChannelPayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs>
      category: Prisma.$MessageCategoryPayload<ExtArgs>
      overrideSetter: Prisma.$UserPayload<ExtArgs> | null
      deliveries: Prisma.$MessageDeliveryPayload<ExtArgs>[]
      approvals: Prisma.$MessageApprovalPayload<ExtArgs>[]
      attachments: Prisma.$MessageAttachmentPayload<ExtArgs>[]
      revisions: Prisma.$MessageRevisionPayload<ExtArgs>[]
      views: Prisma.$MessageViewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      channelId: string
      senderId: string
      categoryId: string
      content: string
      durationSeconds: number
      expiresAt: Date | null
      isEmergency: boolean
      isImmediate: boolean
      priority: $Enums.MessagePriority
      approvalOverride: $Enums.ApprovalPolicy | null
      approvalOverrideSetBy: string | null
      approvalOverrideSetAt: Date | null
      deliveryMethod: $Enums.DeliveryMethod
      eventAt: Date | null
      publishedAt: Date | null
      state: $Enums.MessageState
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    channel<T extends ChannelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChannelDefaultArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    category<T extends MessageCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessageCategoryDefaultArgs<ExtArgs>>): Prisma__MessageCategoryClient<$Result.GetResult<Prisma.$MessageCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    overrideSetter<T extends Message$overrideSetterArgs<ExtArgs> = {}>(args?: Subset<T, Message$overrideSetterArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    deliveries<T extends Message$deliveriesArgs<ExtArgs> = {}>(args?: Subset<T, Message$deliveriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageDeliveryPayload<ExtArgs>, T, "findMany"> | Null>
    approvals<T extends Message$approvalsArgs<ExtArgs> = {}>(args?: Subset<T, Message$approvalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageApprovalPayload<ExtArgs>, T, "findMany"> | Null>
    attachments<T extends Message$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Message$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "findMany"> | Null>
    revisions<T extends Message$revisionsArgs<ExtArgs> = {}>(args?: Subset<T, Message$revisionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageRevisionPayload<ExtArgs>, T, "findMany"> | Null>
    views<T extends Message$viewsArgs<ExtArgs> = {}>(args?: Subset<T, Message$viewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageViewPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */ 
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly channelId: FieldRef<"Message", 'String'>
    readonly senderId: FieldRef<"Message", 'String'>
    readonly categoryId: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly durationSeconds: FieldRef<"Message", 'Int'>
    readonly expiresAt: FieldRef<"Message", 'DateTime'>
    readonly isEmergency: FieldRef<"Message", 'Boolean'>
    readonly isImmediate: FieldRef<"Message", 'Boolean'>
    readonly priority: FieldRef<"Message", 'MessagePriority'>
    readonly approvalOverride: FieldRef<"Message", 'ApprovalPolicy'>
    readonly approvalOverrideSetBy: FieldRef<"Message", 'String'>
    readonly approvalOverrideSetAt: FieldRef<"Message", 'DateTime'>
    readonly deliveryMethod: FieldRef<"Message", 'DeliveryMethod'>
    readonly eventAt: FieldRef<"Message", 'DateTime'>
    readonly publishedAt: FieldRef<"Message", 'DateTime'>
    readonly state: FieldRef<"Message", 'MessageState'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly updatedAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
  }

  /**
   * Message.overrideSetter
   */
  export type Message$overrideSetterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Message.deliveries
   */
  export type Message$deliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageDelivery
     */
    select?: MessageDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageDeliveryInclude<ExtArgs> | null
    where?: MessageDeliveryWhereInput
    orderBy?: MessageDeliveryOrderByWithRelationInput | MessageDeliveryOrderByWithRelationInput[]
    cursor?: MessageDeliveryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageDeliveryScalarFieldEnum | MessageDeliveryScalarFieldEnum[]
  }

  /**
   * Message.approvals
   */
  export type Message$approvalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageApproval
     */
    select?: MessageApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageApprovalInclude<ExtArgs> | null
    where?: MessageApprovalWhereInput
    orderBy?: MessageApprovalOrderByWithRelationInput | MessageApprovalOrderByWithRelationInput[]
    cursor?: MessageApprovalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageApprovalScalarFieldEnum | MessageApprovalScalarFieldEnum[]
  }

  /**
   * Message.attachments
   */
  export type Message$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    where?: MessageAttachmentWhereInput
    orderBy?: MessageAttachmentOrderByWithRelationInput | MessageAttachmentOrderByWithRelationInput[]
    cursor?: MessageAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageAttachmentScalarFieldEnum | MessageAttachmentScalarFieldEnum[]
  }

  /**
   * Message.revisions
   */
  export type Message$revisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRevision
     */
    select?: MessageRevisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageRevisionInclude<ExtArgs> | null
    where?: MessageRevisionWhereInput
    orderBy?: MessageRevisionOrderByWithRelationInput | MessageRevisionOrderByWithRelationInput[]
    cursor?: MessageRevisionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageRevisionScalarFieldEnum | MessageRevisionScalarFieldEnum[]
  }

  /**
   * Message.views
   */
  export type Message$viewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageView
     */
    select?: MessageViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageViewInclude<ExtArgs> | null
    where?: MessageViewWhereInput
    orderBy?: MessageViewOrderByWithRelationInput | MessageViewOrderByWithRelationInput[]
    cursor?: MessageViewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageViewScalarFieldEnum | MessageViewScalarFieldEnum[]
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model ChannelSubscription
   */

  export type AggregateChannelSubscription = {
    _count: ChannelSubscriptionCountAggregateOutputType | null
    _min: ChannelSubscriptionMinAggregateOutputType | null
    _max: ChannelSubscriptionMaxAggregateOutputType | null
  }

  export type ChannelSubscriptionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    channelId: string | null
    subscribedAt: Date | null
    isActive: boolean | null
    isFavorite: boolean | null
    receiveMessages: boolean | null
  }

  export type ChannelSubscriptionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    channelId: string | null
    subscribedAt: Date | null
    isActive: boolean | null
    isFavorite: boolean | null
    receiveMessages: boolean | null
  }

  export type ChannelSubscriptionCountAggregateOutputType = {
    id: number
    userId: number
    channelId: number
    subscribedAt: number
    isActive: number
    isFavorite: number
    receiveMessages: number
    _all: number
  }


  export type ChannelSubscriptionMinAggregateInputType = {
    id?: true
    userId?: true
    channelId?: true
    subscribedAt?: true
    isActive?: true
    isFavorite?: true
    receiveMessages?: true
  }

  export type ChannelSubscriptionMaxAggregateInputType = {
    id?: true
    userId?: true
    channelId?: true
    subscribedAt?: true
    isActive?: true
    isFavorite?: true
    receiveMessages?: true
  }

  export type ChannelSubscriptionCountAggregateInputType = {
    id?: true
    userId?: true
    channelId?: true
    subscribedAt?: true
    isActive?: true
    isFavorite?: true
    receiveMessages?: true
    _all?: true
  }

  export type ChannelSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChannelSubscription to aggregate.
     */
    where?: ChannelSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelSubscriptions to fetch.
     */
    orderBy?: ChannelSubscriptionOrderByWithRelationInput | ChannelSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChannelSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChannelSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChannelSubscriptions
    **/
    _count?: true | ChannelSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChannelSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChannelSubscriptionMaxAggregateInputType
  }

  export type GetChannelSubscriptionAggregateType<T extends ChannelSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateChannelSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChannelSubscription[P]>
      : GetScalarType<T[P], AggregateChannelSubscription[P]>
  }




  export type ChannelSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelSubscriptionWhereInput
    orderBy?: ChannelSubscriptionOrderByWithAggregationInput | ChannelSubscriptionOrderByWithAggregationInput[]
    by: ChannelSubscriptionScalarFieldEnum[] | ChannelSubscriptionScalarFieldEnum
    having?: ChannelSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChannelSubscriptionCountAggregateInputType | true
    _min?: ChannelSubscriptionMinAggregateInputType
    _max?: ChannelSubscriptionMaxAggregateInputType
  }

  export type ChannelSubscriptionGroupByOutputType = {
    id: string
    userId: string
    channelId: string
    subscribedAt: Date
    isActive: boolean
    isFavorite: boolean
    receiveMessages: boolean
    _count: ChannelSubscriptionCountAggregateOutputType | null
    _min: ChannelSubscriptionMinAggregateOutputType | null
    _max: ChannelSubscriptionMaxAggregateOutputType | null
  }

  type GetChannelSubscriptionGroupByPayload<T extends ChannelSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChannelSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChannelSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChannelSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], ChannelSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type ChannelSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    channelId?: boolean
    subscribedAt?: boolean
    isActive?: boolean
    isFavorite?: boolean
    receiveMessages?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    channel?: boolean | ChannelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["channelSubscription"]>


  export type ChannelSubscriptionSelectScalar = {
    id?: boolean
    userId?: boolean
    channelId?: boolean
    subscribedAt?: boolean
    isActive?: boolean
    isFavorite?: boolean
    receiveMessages?: boolean
  }

  export type ChannelSubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    channel?: boolean | ChannelDefaultArgs<ExtArgs>
  }

  export type $ChannelSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChannelSubscription"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      channel: Prisma.$ChannelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      channelId: string
      subscribedAt: Date
      isActive: boolean
      isFavorite: boolean
      receiveMessages: boolean
    }, ExtArgs["result"]["channelSubscription"]>
    composites: {}
  }

  type ChannelSubscriptionGetPayload<S extends boolean | null | undefined | ChannelSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$ChannelSubscriptionPayload, S>

  type ChannelSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChannelSubscriptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChannelSubscriptionCountAggregateInputType | true
    }

  export interface ChannelSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChannelSubscription'], meta: { name: 'ChannelSubscription' } }
    /**
     * Find zero or one ChannelSubscription that matches the filter.
     * @param {ChannelSubscriptionFindUniqueArgs} args - Arguments to find a ChannelSubscription
     * @example
     * // Get one ChannelSubscription
     * const channelSubscription = await prisma.channelSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChannelSubscriptionFindUniqueArgs>(args: SelectSubset<T, ChannelSubscriptionFindUniqueArgs<ExtArgs>>): Prisma__ChannelSubscriptionClient<$Result.GetResult<Prisma.$ChannelSubscriptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ChannelSubscription that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChannelSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a ChannelSubscription
     * @example
     * // Get one ChannelSubscription
     * const channelSubscription = await prisma.channelSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChannelSubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, ChannelSubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChannelSubscriptionClient<$Result.GetResult<Prisma.$ChannelSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ChannelSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelSubscriptionFindFirstArgs} args - Arguments to find a ChannelSubscription
     * @example
     * // Get one ChannelSubscription
     * const channelSubscription = await prisma.channelSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChannelSubscriptionFindFirstArgs>(args?: SelectSubset<T, ChannelSubscriptionFindFirstArgs<ExtArgs>>): Prisma__ChannelSubscriptionClient<$Result.GetResult<Prisma.$ChannelSubscriptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ChannelSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelSubscriptionFindFirstOrThrowArgs} args - Arguments to find a ChannelSubscription
     * @example
     * // Get one ChannelSubscription
     * const channelSubscription = await prisma.channelSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChannelSubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, ChannelSubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChannelSubscriptionClient<$Result.GetResult<Prisma.$ChannelSubscriptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ChannelSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChannelSubscriptions
     * const channelSubscriptions = await prisma.channelSubscription.findMany()
     * 
     * // Get first 10 ChannelSubscriptions
     * const channelSubscriptions = await prisma.channelSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const channelSubscriptionWithIdOnly = await prisma.channelSubscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChannelSubscriptionFindManyArgs>(args?: SelectSubset<T, ChannelSubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelSubscriptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ChannelSubscription.
     * @param {ChannelSubscriptionCreateArgs} args - Arguments to create a ChannelSubscription.
     * @example
     * // Create one ChannelSubscription
     * const ChannelSubscription = await prisma.channelSubscription.create({
     *   data: {
     *     // ... data to create a ChannelSubscription
     *   }
     * })
     * 
     */
    create<T extends ChannelSubscriptionCreateArgs>(args: SelectSubset<T, ChannelSubscriptionCreateArgs<ExtArgs>>): Prisma__ChannelSubscriptionClient<$Result.GetResult<Prisma.$ChannelSubscriptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ChannelSubscriptions.
     * @param {ChannelSubscriptionCreateManyArgs} args - Arguments to create many ChannelSubscriptions.
     * @example
     * // Create many ChannelSubscriptions
     * const channelSubscription = await prisma.channelSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChannelSubscriptionCreateManyArgs>(args?: SelectSubset<T, ChannelSubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ChannelSubscription.
     * @param {ChannelSubscriptionDeleteArgs} args - Arguments to delete one ChannelSubscription.
     * @example
     * // Delete one ChannelSubscription
     * const ChannelSubscription = await prisma.channelSubscription.delete({
     *   where: {
     *     // ... filter to delete one ChannelSubscription
     *   }
     * })
     * 
     */
    delete<T extends ChannelSubscriptionDeleteArgs>(args: SelectSubset<T, ChannelSubscriptionDeleteArgs<ExtArgs>>): Prisma__ChannelSubscriptionClient<$Result.GetResult<Prisma.$ChannelSubscriptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ChannelSubscription.
     * @param {ChannelSubscriptionUpdateArgs} args - Arguments to update one ChannelSubscription.
     * @example
     * // Update one ChannelSubscription
     * const channelSubscription = await prisma.channelSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChannelSubscriptionUpdateArgs>(args: SelectSubset<T, ChannelSubscriptionUpdateArgs<ExtArgs>>): Prisma__ChannelSubscriptionClient<$Result.GetResult<Prisma.$ChannelSubscriptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ChannelSubscriptions.
     * @param {ChannelSubscriptionDeleteManyArgs} args - Arguments to filter ChannelSubscriptions to delete.
     * @example
     * // Delete a few ChannelSubscriptions
     * const { count } = await prisma.channelSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChannelSubscriptionDeleteManyArgs>(args?: SelectSubset<T, ChannelSubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChannelSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChannelSubscriptions
     * const channelSubscription = await prisma.channelSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChannelSubscriptionUpdateManyArgs>(args: SelectSubset<T, ChannelSubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChannelSubscription.
     * @param {ChannelSubscriptionUpsertArgs} args - Arguments to update or create a ChannelSubscription.
     * @example
     * // Update or create a ChannelSubscription
     * const channelSubscription = await prisma.channelSubscription.upsert({
     *   create: {
     *     // ... data to create a ChannelSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChannelSubscription we want to update
     *   }
     * })
     */
    upsert<T extends ChannelSubscriptionUpsertArgs>(args: SelectSubset<T, ChannelSubscriptionUpsertArgs<ExtArgs>>): Prisma__ChannelSubscriptionClient<$Result.GetResult<Prisma.$ChannelSubscriptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ChannelSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelSubscriptionCountArgs} args - Arguments to filter ChannelSubscriptions to count.
     * @example
     * // Count the number of ChannelSubscriptions
     * const count = await prisma.channelSubscription.count({
     *   where: {
     *     // ... the filter for the ChannelSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends ChannelSubscriptionCountArgs>(
      args?: Subset<T, ChannelSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChannelSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChannelSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChannelSubscriptionAggregateArgs>(args: Subset<T, ChannelSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetChannelSubscriptionAggregateType<T>>

    /**
     * Group by ChannelSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChannelSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChannelSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: ChannelSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChannelSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChannelSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChannelSubscription model
   */
  readonly fields: ChannelSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChannelSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChannelSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    channel<T extends ChannelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChannelDefaultArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChannelSubscription model
   */ 
  interface ChannelSubscriptionFieldRefs {
    readonly id: FieldRef<"ChannelSubscription", 'String'>
    readonly userId: FieldRef<"ChannelSubscription", 'String'>
    readonly channelId: FieldRef<"ChannelSubscription", 'String'>
    readonly subscribedAt: FieldRef<"ChannelSubscription", 'DateTime'>
    readonly isActive: FieldRef<"ChannelSubscription", 'Boolean'>
    readonly isFavorite: FieldRef<"ChannelSubscription", 'Boolean'>
    readonly receiveMessages: FieldRef<"ChannelSubscription", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ChannelSubscription findUnique
   */
  export type ChannelSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelSubscription
     */
    select?: ChannelSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which ChannelSubscription to fetch.
     */
    where: ChannelSubscriptionWhereUniqueInput
  }

  /**
   * ChannelSubscription findUniqueOrThrow
   */
  export type ChannelSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelSubscription
     */
    select?: ChannelSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which ChannelSubscription to fetch.
     */
    where: ChannelSubscriptionWhereUniqueInput
  }

  /**
   * ChannelSubscription findFirst
   */
  export type ChannelSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelSubscription
     */
    select?: ChannelSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which ChannelSubscription to fetch.
     */
    where?: ChannelSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelSubscriptions to fetch.
     */
    orderBy?: ChannelSubscriptionOrderByWithRelationInput | ChannelSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChannelSubscriptions.
     */
    cursor?: ChannelSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChannelSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChannelSubscriptions.
     */
    distinct?: ChannelSubscriptionScalarFieldEnum | ChannelSubscriptionScalarFieldEnum[]
  }

  /**
   * ChannelSubscription findFirstOrThrow
   */
  export type ChannelSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelSubscription
     */
    select?: ChannelSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which ChannelSubscription to fetch.
     */
    where?: ChannelSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelSubscriptions to fetch.
     */
    orderBy?: ChannelSubscriptionOrderByWithRelationInput | ChannelSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChannelSubscriptions.
     */
    cursor?: ChannelSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChannelSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChannelSubscriptions.
     */
    distinct?: ChannelSubscriptionScalarFieldEnum | ChannelSubscriptionScalarFieldEnum[]
  }

  /**
   * ChannelSubscription findMany
   */
  export type ChannelSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelSubscription
     */
    select?: ChannelSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which ChannelSubscriptions to fetch.
     */
    where?: ChannelSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelSubscriptions to fetch.
     */
    orderBy?: ChannelSubscriptionOrderByWithRelationInput | ChannelSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChannelSubscriptions.
     */
    cursor?: ChannelSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChannelSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelSubscriptions.
     */
    skip?: number
    distinct?: ChannelSubscriptionScalarFieldEnum | ChannelSubscriptionScalarFieldEnum[]
  }

  /**
   * ChannelSubscription create
   */
  export type ChannelSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelSubscription
     */
    select?: ChannelSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a ChannelSubscription.
     */
    data: XOR<ChannelSubscriptionCreateInput, ChannelSubscriptionUncheckedCreateInput>
  }

  /**
   * ChannelSubscription createMany
   */
  export type ChannelSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChannelSubscriptions.
     */
    data: ChannelSubscriptionCreateManyInput | ChannelSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChannelSubscription update
   */
  export type ChannelSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelSubscription
     */
    select?: ChannelSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a ChannelSubscription.
     */
    data: XOR<ChannelSubscriptionUpdateInput, ChannelSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which ChannelSubscription to update.
     */
    where: ChannelSubscriptionWhereUniqueInput
  }

  /**
   * ChannelSubscription updateMany
   */
  export type ChannelSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChannelSubscriptions.
     */
    data: XOR<ChannelSubscriptionUpdateManyMutationInput, ChannelSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which ChannelSubscriptions to update
     */
    where?: ChannelSubscriptionWhereInput
  }

  /**
   * ChannelSubscription upsert
   */
  export type ChannelSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelSubscription
     */
    select?: ChannelSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelSubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the ChannelSubscription to update in case it exists.
     */
    where: ChannelSubscriptionWhereUniqueInput
    /**
     * In case the ChannelSubscription found by the `where` argument doesn't exist, create a new ChannelSubscription with this data.
     */
    create: XOR<ChannelSubscriptionCreateInput, ChannelSubscriptionUncheckedCreateInput>
    /**
     * In case the ChannelSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChannelSubscriptionUpdateInput, ChannelSubscriptionUncheckedUpdateInput>
  }

  /**
   * ChannelSubscription delete
   */
  export type ChannelSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelSubscription
     */
    select?: ChannelSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelSubscriptionInclude<ExtArgs> | null
    /**
     * Filter which ChannelSubscription to delete.
     */
    where: ChannelSubscriptionWhereUniqueInput
  }

  /**
   * ChannelSubscription deleteMany
   */
  export type ChannelSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChannelSubscriptions to delete
     */
    where?: ChannelSubscriptionWhereInput
  }

  /**
   * ChannelSubscription without action
   */
  export type ChannelSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelSubscription
     */
    select?: ChannelSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelSubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    actorId: string | null
    action: string | null
    targetUserId: string | null
    targetChannelId: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    actorId: string | null
    action: string | null
    targetUserId: string | null
    targetChannelId: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    actorId: number
    action: number
    targetUserId: number
    targetChannelId: number
    details: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    actorId?: true
    action?: true
    targetUserId?: true
    targetChannelId?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    actorId?: true
    action?: true
    targetUserId?: true
    targetChannelId?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    actorId?: true
    action?: true
    targetUserId?: true
    targetChannelId?: true
    details?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    actorId: string
    action: string
    targetUserId: string | null
    targetChannelId: string | null
    details: JsonValue | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actorId?: boolean
    action?: boolean
    targetUserId?: boolean
    targetChannelId?: boolean
    details?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["auditLog"]>


  export type AuditLogSelectScalar = {
    id?: boolean
    actorId?: boolean
    action?: boolean
    targetUserId?: boolean
    targetChannelId?: boolean
    details?: boolean
    createdAt?: boolean
  }


  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      actorId: string
      action: string
      targetUserId: string | null
      targetChannelId: string | null
      details: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly actorId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly targetUserId: FieldRef<"AuditLog", 'String'>
    readonly targetChannelId: FieldRef<"AuditLog", 'String'>
    readonly details: FieldRef<"AuditLog", 'Json'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
  }


  /**
   * Model MessageDelivery
   */

  export type AggregateMessageDelivery = {
    _count: MessageDeliveryCountAggregateOutputType | null
    _min: MessageDeliveryMinAggregateOutputType | null
    _max: MessageDeliveryMaxAggregateOutputType | null
  }

  export type MessageDeliveryMinAggregateOutputType = {
    id: string | null
    messageId: string | null
    userId: string | null
    deliveryStatus: $Enums.DeliveryStatus | null
    deliveryMethod: $Enums.DeliveryMethod | null
    deliveredAt: Date | null
    readAt: Date | null
    createdAt: Date | null
  }

  export type MessageDeliveryMaxAggregateOutputType = {
    id: string | null
    messageId: string | null
    userId: string | null
    deliveryStatus: $Enums.DeliveryStatus | null
    deliveryMethod: $Enums.DeliveryMethod | null
    deliveredAt: Date | null
    readAt: Date | null
    createdAt: Date | null
  }

  export type MessageDeliveryCountAggregateOutputType = {
    id: number
    messageId: number
    userId: number
    deliveryStatus: number
    deliveryMethod: number
    deliveredAt: number
    readAt: number
    createdAt: number
    _all: number
  }


  export type MessageDeliveryMinAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    deliveryStatus?: true
    deliveryMethod?: true
    deliveredAt?: true
    readAt?: true
    createdAt?: true
  }

  export type MessageDeliveryMaxAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    deliveryStatus?: true
    deliveryMethod?: true
    deliveredAt?: true
    readAt?: true
    createdAt?: true
  }

  export type MessageDeliveryCountAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    deliveryStatus?: true
    deliveryMethod?: true
    deliveredAt?: true
    readAt?: true
    createdAt?: true
    _all?: true
  }

  export type MessageDeliveryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageDelivery to aggregate.
     */
    where?: MessageDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageDeliveries to fetch.
     */
    orderBy?: MessageDeliveryOrderByWithRelationInput | MessageDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageDeliveries
    **/
    _count?: true | MessageDeliveryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageDeliveryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageDeliveryMaxAggregateInputType
  }

  export type GetMessageDeliveryAggregateType<T extends MessageDeliveryAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageDelivery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageDelivery[P]>
      : GetScalarType<T[P], AggregateMessageDelivery[P]>
  }




  export type MessageDeliveryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageDeliveryWhereInput
    orderBy?: MessageDeliveryOrderByWithAggregationInput | MessageDeliveryOrderByWithAggregationInput[]
    by: MessageDeliveryScalarFieldEnum[] | MessageDeliveryScalarFieldEnum
    having?: MessageDeliveryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageDeliveryCountAggregateInputType | true
    _min?: MessageDeliveryMinAggregateInputType
    _max?: MessageDeliveryMaxAggregateInputType
  }

  export type MessageDeliveryGroupByOutputType = {
    id: string
    messageId: string
    userId: string
    deliveryStatus: $Enums.DeliveryStatus
    deliveryMethod: $Enums.DeliveryMethod | null
    deliveredAt: Date | null
    readAt: Date | null
    createdAt: Date
    _count: MessageDeliveryCountAggregateOutputType | null
    _min: MessageDeliveryMinAggregateOutputType | null
    _max: MessageDeliveryMaxAggregateOutputType | null
  }

  type GetMessageDeliveryGroupByPayload<T extends MessageDeliveryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageDeliveryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageDeliveryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageDeliveryGroupByOutputType[P]>
            : GetScalarType<T[P], MessageDeliveryGroupByOutputType[P]>
        }
      >
    >


  export type MessageDeliverySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    userId?: boolean
    deliveryStatus?: boolean
    deliveryMethod?: boolean
    deliveredAt?: boolean
    readAt?: boolean
    createdAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageDelivery"]>


  export type MessageDeliverySelectScalar = {
    id?: boolean
    messageId?: boolean
    userId?: boolean
    deliveryStatus?: boolean
    deliveryMethod?: boolean
    deliveredAt?: boolean
    readAt?: boolean
    createdAt?: boolean
  }

  export type MessageDeliveryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MessageDeliveryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageDelivery"
    objects: {
      message: Prisma.$MessagePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      messageId: string
      userId: string
      deliveryStatus: $Enums.DeliveryStatus
      deliveryMethod: $Enums.DeliveryMethod | null
      deliveredAt: Date | null
      readAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["messageDelivery"]>
    composites: {}
  }

  type MessageDeliveryGetPayload<S extends boolean | null | undefined | MessageDeliveryDefaultArgs> = $Result.GetResult<Prisma.$MessageDeliveryPayload, S>

  type MessageDeliveryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageDeliveryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageDeliveryCountAggregateInputType | true
    }

  export interface MessageDeliveryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageDelivery'], meta: { name: 'MessageDelivery' } }
    /**
     * Find zero or one MessageDelivery that matches the filter.
     * @param {MessageDeliveryFindUniqueArgs} args - Arguments to find a MessageDelivery
     * @example
     * // Get one MessageDelivery
     * const messageDelivery = await prisma.messageDelivery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageDeliveryFindUniqueArgs>(args: SelectSubset<T, MessageDeliveryFindUniqueArgs<ExtArgs>>): Prisma__MessageDeliveryClient<$Result.GetResult<Prisma.$MessageDeliveryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MessageDelivery that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageDeliveryFindUniqueOrThrowArgs} args - Arguments to find a MessageDelivery
     * @example
     * // Get one MessageDelivery
     * const messageDelivery = await prisma.messageDelivery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageDeliveryFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageDeliveryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageDeliveryClient<$Result.GetResult<Prisma.$MessageDeliveryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MessageDelivery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageDeliveryFindFirstArgs} args - Arguments to find a MessageDelivery
     * @example
     * // Get one MessageDelivery
     * const messageDelivery = await prisma.messageDelivery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageDeliveryFindFirstArgs>(args?: SelectSubset<T, MessageDeliveryFindFirstArgs<ExtArgs>>): Prisma__MessageDeliveryClient<$Result.GetResult<Prisma.$MessageDeliveryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MessageDelivery that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageDeliveryFindFirstOrThrowArgs} args - Arguments to find a MessageDelivery
     * @example
     * // Get one MessageDelivery
     * const messageDelivery = await prisma.messageDelivery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageDeliveryFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageDeliveryFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageDeliveryClient<$Result.GetResult<Prisma.$MessageDeliveryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MessageDeliveries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageDeliveryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageDeliveries
     * const messageDeliveries = await prisma.messageDelivery.findMany()
     * 
     * // Get first 10 MessageDeliveries
     * const messageDeliveries = await prisma.messageDelivery.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageDeliveryWithIdOnly = await prisma.messageDelivery.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageDeliveryFindManyArgs>(args?: SelectSubset<T, MessageDeliveryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageDeliveryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MessageDelivery.
     * @param {MessageDeliveryCreateArgs} args - Arguments to create a MessageDelivery.
     * @example
     * // Create one MessageDelivery
     * const MessageDelivery = await prisma.messageDelivery.create({
     *   data: {
     *     // ... data to create a MessageDelivery
     *   }
     * })
     * 
     */
    create<T extends MessageDeliveryCreateArgs>(args: SelectSubset<T, MessageDeliveryCreateArgs<ExtArgs>>): Prisma__MessageDeliveryClient<$Result.GetResult<Prisma.$MessageDeliveryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MessageDeliveries.
     * @param {MessageDeliveryCreateManyArgs} args - Arguments to create many MessageDeliveries.
     * @example
     * // Create many MessageDeliveries
     * const messageDelivery = await prisma.messageDelivery.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageDeliveryCreateManyArgs>(args?: SelectSubset<T, MessageDeliveryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MessageDelivery.
     * @param {MessageDeliveryDeleteArgs} args - Arguments to delete one MessageDelivery.
     * @example
     * // Delete one MessageDelivery
     * const MessageDelivery = await prisma.messageDelivery.delete({
     *   where: {
     *     // ... filter to delete one MessageDelivery
     *   }
     * })
     * 
     */
    delete<T extends MessageDeliveryDeleteArgs>(args: SelectSubset<T, MessageDeliveryDeleteArgs<ExtArgs>>): Prisma__MessageDeliveryClient<$Result.GetResult<Prisma.$MessageDeliveryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MessageDelivery.
     * @param {MessageDeliveryUpdateArgs} args - Arguments to update one MessageDelivery.
     * @example
     * // Update one MessageDelivery
     * const messageDelivery = await prisma.messageDelivery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageDeliveryUpdateArgs>(args: SelectSubset<T, MessageDeliveryUpdateArgs<ExtArgs>>): Prisma__MessageDeliveryClient<$Result.GetResult<Prisma.$MessageDeliveryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MessageDeliveries.
     * @param {MessageDeliveryDeleteManyArgs} args - Arguments to filter MessageDeliveries to delete.
     * @example
     * // Delete a few MessageDeliveries
     * const { count } = await prisma.messageDelivery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeliveryDeleteManyArgs>(args?: SelectSubset<T, MessageDeliveryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageDeliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageDeliveryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageDeliveries
     * const messageDelivery = await prisma.messageDelivery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageDeliveryUpdateManyArgs>(args: SelectSubset<T, MessageDeliveryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MessageDelivery.
     * @param {MessageDeliveryUpsertArgs} args - Arguments to update or create a MessageDelivery.
     * @example
     * // Update or create a MessageDelivery
     * const messageDelivery = await prisma.messageDelivery.upsert({
     *   create: {
     *     // ... data to create a MessageDelivery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageDelivery we want to update
     *   }
     * })
     */
    upsert<T extends MessageDeliveryUpsertArgs>(args: SelectSubset<T, MessageDeliveryUpsertArgs<ExtArgs>>): Prisma__MessageDeliveryClient<$Result.GetResult<Prisma.$MessageDeliveryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MessageDeliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageDeliveryCountArgs} args - Arguments to filter MessageDeliveries to count.
     * @example
     * // Count the number of MessageDeliveries
     * const count = await prisma.messageDelivery.count({
     *   where: {
     *     // ... the filter for the MessageDeliveries we want to count
     *   }
     * })
    **/
    count<T extends MessageDeliveryCountArgs>(
      args?: Subset<T, MessageDeliveryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageDeliveryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageDelivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageDeliveryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageDeliveryAggregateArgs>(args: Subset<T, MessageDeliveryAggregateArgs>): Prisma.PrismaPromise<GetMessageDeliveryAggregateType<T>>

    /**
     * Group by MessageDelivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageDeliveryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageDeliveryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageDeliveryGroupByArgs['orderBy'] }
        : { orderBy?: MessageDeliveryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageDeliveryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageDeliveryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageDelivery model
   */
  readonly fields: MessageDeliveryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageDelivery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageDeliveryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message<T extends MessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessageDefaultArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessageDelivery model
   */ 
  interface MessageDeliveryFieldRefs {
    readonly id: FieldRef<"MessageDelivery", 'String'>
    readonly messageId: FieldRef<"MessageDelivery", 'String'>
    readonly userId: FieldRef<"MessageDelivery", 'String'>
    readonly deliveryStatus: FieldRef<"MessageDelivery", 'DeliveryStatus'>
    readonly deliveryMethod: FieldRef<"MessageDelivery", 'DeliveryMethod'>
    readonly deliveredAt: FieldRef<"MessageDelivery", 'DateTime'>
    readonly readAt: FieldRef<"MessageDelivery", 'DateTime'>
    readonly createdAt: FieldRef<"MessageDelivery", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MessageDelivery findUnique
   */
  export type MessageDeliveryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageDelivery
     */
    select?: MessageDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which MessageDelivery to fetch.
     */
    where: MessageDeliveryWhereUniqueInput
  }

  /**
   * MessageDelivery findUniqueOrThrow
   */
  export type MessageDeliveryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageDelivery
     */
    select?: MessageDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which MessageDelivery to fetch.
     */
    where: MessageDeliveryWhereUniqueInput
  }

  /**
   * MessageDelivery findFirst
   */
  export type MessageDeliveryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageDelivery
     */
    select?: MessageDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which MessageDelivery to fetch.
     */
    where?: MessageDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageDeliveries to fetch.
     */
    orderBy?: MessageDeliveryOrderByWithRelationInput | MessageDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageDeliveries.
     */
    cursor?: MessageDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageDeliveries.
     */
    distinct?: MessageDeliveryScalarFieldEnum | MessageDeliveryScalarFieldEnum[]
  }

  /**
   * MessageDelivery findFirstOrThrow
   */
  export type MessageDeliveryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageDelivery
     */
    select?: MessageDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which MessageDelivery to fetch.
     */
    where?: MessageDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageDeliveries to fetch.
     */
    orderBy?: MessageDeliveryOrderByWithRelationInput | MessageDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageDeliveries.
     */
    cursor?: MessageDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageDeliveries.
     */
    distinct?: MessageDeliveryScalarFieldEnum | MessageDeliveryScalarFieldEnum[]
  }

  /**
   * MessageDelivery findMany
   */
  export type MessageDeliveryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageDelivery
     */
    select?: MessageDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which MessageDeliveries to fetch.
     */
    where?: MessageDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageDeliveries to fetch.
     */
    orderBy?: MessageDeliveryOrderByWithRelationInput | MessageDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageDeliveries.
     */
    cursor?: MessageDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageDeliveries.
     */
    skip?: number
    distinct?: MessageDeliveryScalarFieldEnum | MessageDeliveryScalarFieldEnum[]
  }

  /**
   * MessageDelivery create
   */
  export type MessageDeliveryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageDelivery
     */
    select?: MessageDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageDeliveryInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageDelivery.
     */
    data: XOR<MessageDeliveryCreateInput, MessageDeliveryUncheckedCreateInput>
  }

  /**
   * MessageDelivery createMany
   */
  export type MessageDeliveryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageDeliveries.
     */
    data: MessageDeliveryCreateManyInput | MessageDeliveryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageDelivery update
   */
  export type MessageDeliveryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageDelivery
     */
    select?: MessageDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageDeliveryInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageDelivery.
     */
    data: XOR<MessageDeliveryUpdateInput, MessageDeliveryUncheckedUpdateInput>
    /**
     * Choose, which MessageDelivery to update.
     */
    where: MessageDeliveryWhereUniqueInput
  }

  /**
   * MessageDelivery updateMany
   */
  export type MessageDeliveryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageDeliveries.
     */
    data: XOR<MessageDeliveryUpdateManyMutationInput, MessageDeliveryUncheckedUpdateManyInput>
    /**
     * Filter which MessageDeliveries to update
     */
    where?: MessageDeliveryWhereInput
  }

  /**
   * MessageDelivery upsert
   */
  export type MessageDeliveryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageDelivery
     */
    select?: MessageDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageDeliveryInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageDelivery to update in case it exists.
     */
    where: MessageDeliveryWhereUniqueInput
    /**
     * In case the MessageDelivery found by the `where` argument doesn't exist, create a new MessageDelivery with this data.
     */
    create: XOR<MessageDeliveryCreateInput, MessageDeliveryUncheckedCreateInput>
    /**
     * In case the MessageDelivery was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageDeliveryUpdateInput, MessageDeliveryUncheckedUpdateInput>
  }

  /**
   * MessageDelivery delete
   */
  export type MessageDeliveryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageDelivery
     */
    select?: MessageDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageDeliveryInclude<ExtArgs> | null
    /**
     * Filter which MessageDelivery to delete.
     */
    where: MessageDeliveryWhereUniqueInput
  }

  /**
   * MessageDelivery deleteMany
   */
  export type MessageDeliveryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageDeliveries to delete
     */
    where?: MessageDeliveryWhereInput
  }

  /**
   * MessageDelivery without action
   */
  export type MessageDeliveryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageDelivery
     */
    select?: MessageDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageDeliveryInclude<ExtArgs> | null
  }


  /**
   * Model InvitationLink
   */

  export type AggregateInvitationLink = {
    _count: InvitationLinkCountAggregateOutputType | null
    _avg: InvitationLinkAvgAggregateOutputType | null
    _sum: InvitationLinkSumAggregateOutputType | null
    _min: InvitationLinkMinAggregateOutputType | null
    _max: InvitationLinkMaxAggregateOutputType | null
  }

  export type InvitationLinkAvgAggregateOutputType = {
    maxUses: number | null
    currentUses: number | null
  }

  export type InvitationLinkSumAggregateOutputType = {
    maxUses: number | null
    currentUses: number | null
  }

  export type InvitationLinkMinAggregateOutputType = {
    id: string | null
    channelId: string | null
    createdBy: string | null
    linkCode: string | null
    expiresAt: Date | null
    maxUses: number | null
    currentUses: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type InvitationLinkMaxAggregateOutputType = {
    id: string | null
    channelId: string | null
    createdBy: string | null
    linkCode: string | null
    expiresAt: Date | null
    maxUses: number | null
    currentUses: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type InvitationLinkCountAggregateOutputType = {
    id: number
    channelId: number
    createdBy: number
    linkCode: number
    expiresAt: number
    maxUses: number
    currentUses: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type InvitationLinkAvgAggregateInputType = {
    maxUses?: true
    currentUses?: true
  }

  export type InvitationLinkSumAggregateInputType = {
    maxUses?: true
    currentUses?: true
  }

  export type InvitationLinkMinAggregateInputType = {
    id?: true
    channelId?: true
    createdBy?: true
    linkCode?: true
    expiresAt?: true
    maxUses?: true
    currentUses?: true
    isActive?: true
    createdAt?: true
  }

  export type InvitationLinkMaxAggregateInputType = {
    id?: true
    channelId?: true
    createdBy?: true
    linkCode?: true
    expiresAt?: true
    maxUses?: true
    currentUses?: true
    isActive?: true
    createdAt?: true
  }

  export type InvitationLinkCountAggregateInputType = {
    id?: true
    channelId?: true
    createdBy?: true
    linkCode?: true
    expiresAt?: true
    maxUses?: true
    currentUses?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type InvitationLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvitationLink to aggregate.
     */
    where?: InvitationLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvitationLinks to fetch.
     */
    orderBy?: InvitationLinkOrderByWithRelationInput | InvitationLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvitationLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvitationLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvitationLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvitationLinks
    **/
    _count?: true | InvitationLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvitationLinkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvitationLinkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvitationLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvitationLinkMaxAggregateInputType
  }

  export type GetInvitationLinkAggregateType<T extends InvitationLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateInvitationLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvitationLink[P]>
      : GetScalarType<T[P], AggregateInvitationLink[P]>
  }




  export type InvitationLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationLinkWhereInput
    orderBy?: InvitationLinkOrderByWithAggregationInput | InvitationLinkOrderByWithAggregationInput[]
    by: InvitationLinkScalarFieldEnum[] | InvitationLinkScalarFieldEnum
    having?: InvitationLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvitationLinkCountAggregateInputType | true
    _avg?: InvitationLinkAvgAggregateInputType
    _sum?: InvitationLinkSumAggregateInputType
    _min?: InvitationLinkMinAggregateInputType
    _max?: InvitationLinkMaxAggregateInputType
  }

  export type InvitationLinkGroupByOutputType = {
    id: string
    channelId: string
    createdBy: string
    linkCode: string
    expiresAt: Date | null
    maxUses: number | null
    currentUses: number
    isActive: boolean
    createdAt: Date
    _count: InvitationLinkCountAggregateOutputType | null
    _avg: InvitationLinkAvgAggregateOutputType | null
    _sum: InvitationLinkSumAggregateOutputType | null
    _min: InvitationLinkMinAggregateOutputType | null
    _max: InvitationLinkMaxAggregateOutputType | null
  }

  type GetInvitationLinkGroupByPayload<T extends InvitationLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvitationLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvitationLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvitationLinkGroupByOutputType[P]>
            : GetScalarType<T[P], InvitationLinkGroupByOutputType[P]>
        }
      >
    >


  export type InvitationLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    channelId?: boolean
    createdBy?: boolean
    linkCode?: boolean
    expiresAt?: boolean
    maxUses?: boolean
    currentUses?: boolean
    isActive?: boolean
    createdAt?: boolean
    channel?: boolean | ChannelDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitationLink"]>


  export type InvitationLinkSelectScalar = {
    id?: boolean
    channelId?: boolean
    createdBy?: boolean
    linkCode?: boolean
    expiresAt?: boolean
    maxUses?: boolean
    currentUses?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type InvitationLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    channel?: boolean | ChannelDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InvitationLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvitationLink"
    objects: {
      channel: Prisma.$ChannelPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      channelId: string
      createdBy: string
      linkCode: string
      expiresAt: Date | null
      maxUses: number | null
      currentUses: number
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["invitationLink"]>
    composites: {}
  }

  type InvitationLinkGetPayload<S extends boolean | null | undefined | InvitationLinkDefaultArgs> = $Result.GetResult<Prisma.$InvitationLinkPayload, S>

  type InvitationLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvitationLinkFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvitationLinkCountAggregateInputType | true
    }

  export interface InvitationLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvitationLink'], meta: { name: 'InvitationLink' } }
    /**
     * Find zero or one InvitationLink that matches the filter.
     * @param {InvitationLinkFindUniqueArgs} args - Arguments to find a InvitationLink
     * @example
     * // Get one InvitationLink
     * const invitationLink = await prisma.invitationLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvitationLinkFindUniqueArgs>(args: SelectSubset<T, InvitationLinkFindUniqueArgs<ExtArgs>>): Prisma__InvitationLinkClient<$Result.GetResult<Prisma.$InvitationLinkPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InvitationLink that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvitationLinkFindUniqueOrThrowArgs} args - Arguments to find a InvitationLink
     * @example
     * // Get one InvitationLink
     * const invitationLink = await prisma.invitationLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvitationLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, InvitationLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvitationLinkClient<$Result.GetResult<Prisma.$InvitationLinkPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InvitationLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationLinkFindFirstArgs} args - Arguments to find a InvitationLink
     * @example
     * // Get one InvitationLink
     * const invitationLink = await prisma.invitationLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvitationLinkFindFirstArgs>(args?: SelectSubset<T, InvitationLinkFindFirstArgs<ExtArgs>>): Prisma__InvitationLinkClient<$Result.GetResult<Prisma.$InvitationLinkPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InvitationLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationLinkFindFirstOrThrowArgs} args - Arguments to find a InvitationLink
     * @example
     * // Get one InvitationLink
     * const invitationLink = await prisma.invitationLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvitationLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, InvitationLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvitationLinkClient<$Result.GetResult<Prisma.$InvitationLinkPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InvitationLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvitationLinks
     * const invitationLinks = await prisma.invitationLink.findMany()
     * 
     * // Get first 10 InvitationLinks
     * const invitationLinks = await prisma.invitationLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invitationLinkWithIdOnly = await prisma.invitationLink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvitationLinkFindManyArgs>(args?: SelectSubset<T, InvitationLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationLinkPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InvitationLink.
     * @param {InvitationLinkCreateArgs} args - Arguments to create a InvitationLink.
     * @example
     * // Create one InvitationLink
     * const InvitationLink = await prisma.invitationLink.create({
     *   data: {
     *     // ... data to create a InvitationLink
     *   }
     * })
     * 
     */
    create<T extends InvitationLinkCreateArgs>(args: SelectSubset<T, InvitationLinkCreateArgs<ExtArgs>>): Prisma__InvitationLinkClient<$Result.GetResult<Prisma.$InvitationLinkPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InvitationLinks.
     * @param {InvitationLinkCreateManyArgs} args - Arguments to create many InvitationLinks.
     * @example
     * // Create many InvitationLinks
     * const invitationLink = await prisma.invitationLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvitationLinkCreateManyArgs>(args?: SelectSubset<T, InvitationLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InvitationLink.
     * @param {InvitationLinkDeleteArgs} args - Arguments to delete one InvitationLink.
     * @example
     * // Delete one InvitationLink
     * const InvitationLink = await prisma.invitationLink.delete({
     *   where: {
     *     // ... filter to delete one InvitationLink
     *   }
     * })
     * 
     */
    delete<T extends InvitationLinkDeleteArgs>(args: SelectSubset<T, InvitationLinkDeleteArgs<ExtArgs>>): Prisma__InvitationLinkClient<$Result.GetResult<Prisma.$InvitationLinkPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InvitationLink.
     * @param {InvitationLinkUpdateArgs} args - Arguments to update one InvitationLink.
     * @example
     * // Update one InvitationLink
     * const invitationLink = await prisma.invitationLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvitationLinkUpdateArgs>(args: SelectSubset<T, InvitationLinkUpdateArgs<ExtArgs>>): Prisma__InvitationLinkClient<$Result.GetResult<Prisma.$InvitationLinkPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InvitationLinks.
     * @param {InvitationLinkDeleteManyArgs} args - Arguments to filter InvitationLinks to delete.
     * @example
     * // Delete a few InvitationLinks
     * const { count } = await prisma.invitationLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvitationLinkDeleteManyArgs>(args?: SelectSubset<T, InvitationLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvitationLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvitationLinks
     * const invitationLink = await prisma.invitationLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvitationLinkUpdateManyArgs>(args: SelectSubset<T, InvitationLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InvitationLink.
     * @param {InvitationLinkUpsertArgs} args - Arguments to update or create a InvitationLink.
     * @example
     * // Update or create a InvitationLink
     * const invitationLink = await prisma.invitationLink.upsert({
     *   create: {
     *     // ... data to create a InvitationLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvitationLink we want to update
     *   }
     * })
     */
    upsert<T extends InvitationLinkUpsertArgs>(args: SelectSubset<T, InvitationLinkUpsertArgs<ExtArgs>>): Prisma__InvitationLinkClient<$Result.GetResult<Prisma.$InvitationLinkPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InvitationLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationLinkCountArgs} args - Arguments to filter InvitationLinks to count.
     * @example
     * // Count the number of InvitationLinks
     * const count = await prisma.invitationLink.count({
     *   where: {
     *     // ... the filter for the InvitationLinks we want to count
     *   }
     * })
    **/
    count<T extends InvitationLinkCountArgs>(
      args?: Subset<T, InvitationLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvitationLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvitationLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvitationLinkAggregateArgs>(args: Subset<T, InvitationLinkAggregateArgs>): Prisma.PrismaPromise<GetInvitationLinkAggregateType<T>>

    /**
     * Group by InvitationLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvitationLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvitationLinkGroupByArgs['orderBy'] }
        : { orderBy?: InvitationLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvitationLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvitationLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvitationLink model
   */
  readonly fields: InvitationLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvitationLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvitationLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    channel<T extends ChannelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChannelDefaultArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvitationLink model
   */ 
  interface InvitationLinkFieldRefs {
    readonly id: FieldRef<"InvitationLink", 'String'>
    readonly channelId: FieldRef<"InvitationLink", 'String'>
    readonly createdBy: FieldRef<"InvitationLink", 'String'>
    readonly linkCode: FieldRef<"InvitationLink", 'String'>
    readonly expiresAt: FieldRef<"InvitationLink", 'DateTime'>
    readonly maxUses: FieldRef<"InvitationLink", 'Int'>
    readonly currentUses: FieldRef<"InvitationLink", 'Int'>
    readonly isActive: FieldRef<"InvitationLink", 'Boolean'>
    readonly createdAt: FieldRef<"InvitationLink", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InvitationLink findUnique
   */
  export type InvitationLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationLink
     */
    select?: InvitationLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationLinkInclude<ExtArgs> | null
    /**
     * Filter, which InvitationLink to fetch.
     */
    where: InvitationLinkWhereUniqueInput
  }

  /**
   * InvitationLink findUniqueOrThrow
   */
  export type InvitationLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationLink
     */
    select?: InvitationLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationLinkInclude<ExtArgs> | null
    /**
     * Filter, which InvitationLink to fetch.
     */
    where: InvitationLinkWhereUniqueInput
  }

  /**
   * InvitationLink findFirst
   */
  export type InvitationLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationLink
     */
    select?: InvitationLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationLinkInclude<ExtArgs> | null
    /**
     * Filter, which InvitationLink to fetch.
     */
    where?: InvitationLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvitationLinks to fetch.
     */
    orderBy?: InvitationLinkOrderByWithRelationInput | InvitationLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvitationLinks.
     */
    cursor?: InvitationLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvitationLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvitationLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvitationLinks.
     */
    distinct?: InvitationLinkScalarFieldEnum | InvitationLinkScalarFieldEnum[]
  }

  /**
   * InvitationLink findFirstOrThrow
   */
  export type InvitationLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationLink
     */
    select?: InvitationLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationLinkInclude<ExtArgs> | null
    /**
     * Filter, which InvitationLink to fetch.
     */
    where?: InvitationLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvitationLinks to fetch.
     */
    orderBy?: InvitationLinkOrderByWithRelationInput | InvitationLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvitationLinks.
     */
    cursor?: InvitationLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvitationLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvitationLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvitationLinks.
     */
    distinct?: InvitationLinkScalarFieldEnum | InvitationLinkScalarFieldEnum[]
  }

  /**
   * InvitationLink findMany
   */
  export type InvitationLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationLink
     */
    select?: InvitationLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationLinkInclude<ExtArgs> | null
    /**
     * Filter, which InvitationLinks to fetch.
     */
    where?: InvitationLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvitationLinks to fetch.
     */
    orderBy?: InvitationLinkOrderByWithRelationInput | InvitationLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvitationLinks.
     */
    cursor?: InvitationLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvitationLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvitationLinks.
     */
    skip?: number
    distinct?: InvitationLinkScalarFieldEnum | InvitationLinkScalarFieldEnum[]
  }

  /**
   * InvitationLink create
   */
  export type InvitationLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationLink
     */
    select?: InvitationLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a InvitationLink.
     */
    data: XOR<InvitationLinkCreateInput, InvitationLinkUncheckedCreateInput>
  }

  /**
   * InvitationLink createMany
   */
  export type InvitationLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvitationLinks.
     */
    data: InvitationLinkCreateManyInput | InvitationLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvitationLink update
   */
  export type InvitationLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationLink
     */
    select?: InvitationLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a InvitationLink.
     */
    data: XOR<InvitationLinkUpdateInput, InvitationLinkUncheckedUpdateInput>
    /**
     * Choose, which InvitationLink to update.
     */
    where: InvitationLinkWhereUniqueInput
  }

  /**
   * InvitationLink updateMany
   */
  export type InvitationLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvitationLinks.
     */
    data: XOR<InvitationLinkUpdateManyMutationInput, InvitationLinkUncheckedUpdateManyInput>
    /**
     * Filter which InvitationLinks to update
     */
    where?: InvitationLinkWhereInput
  }

  /**
   * InvitationLink upsert
   */
  export type InvitationLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationLink
     */
    select?: InvitationLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the InvitationLink to update in case it exists.
     */
    where: InvitationLinkWhereUniqueInput
    /**
     * In case the InvitationLink found by the `where` argument doesn't exist, create a new InvitationLink with this data.
     */
    create: XOR<InvitationLinkCreateInput, InvitationLinkUncheckedCreateInput>
    /**
     * In case the InvitationLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvitationLinkUpdateInput, InvitationLinkUncheckedUpdateInput>
  }

  /**
   * InvitationLink delete
   */
  export type InvitationLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationLink
     */
    select?: InvitationLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationLinkInclude<ExtArgs> | null
    /**
     * Filter which InvitationLink to delete.
     */
    where: InvitationLinkWhereUniqueInput
  }

  /**
   * InvitationLink deleteMany
   */
  export type InvitationLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvitationLinks to delete
     */
    where?: InvitationLinkWhereInput
  }

  /**
   * InvitationLink without action
   */
  export type InvitationLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationLink
     */
    select?: InvitationLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationLinkInclude<ExtArgs> | null
  }


  /**
   * Model QrCode
   */

  export type AggregateQrCode = {
    _count: QrCodeCountAggregateOutputType | null
    _avg: QrCodeAvgAggregateOutputType | null
    _sum: QrCodeSumAggregateOutputType | null
    _min: QrCodeMinAggregateOutputType | null
    _max: QrCodeMaxAggregateOutputType | null
  }

  export type QrCodeAvgAggregateOutputType = {
    scanCount: number | null
  }

  export type QrCodeSumAggregateOutputType = {
    scanCount: number | null
  }

  export type QrCodeMinAggregateOutputType = {
    id: string | null
    channelId: string | null
    createdBy: string | null
    qrData: string | null
    expiresAt: Date | null
    scanCount: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type QrCodeMaxAggregateOutputType = {
    id: string | null
    channelId: string | null
    createdBy: string | null
    qrData: string | null
    expiresAt: Date | null
    scanCount: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type QrCodeCountAggregateOutputType = {
    id: number
    channelId: number
    createdBy: number
    qrData: number
    expiresAt: number
    scanCount: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type QrCodeAvgAggregateInputType = {
    scanCount?: true
  }

  export type QrCodeSumAggregateInputType = {
    scanCount?: true
  }

  export type QrCodeMinAggregateInputType = {
    id?: true
    channelId?: true
    createdBy?: true
    qrData?: true
    expiresAt?: true
    scanCount?: true
    isActive?: true
    createdAt?: true
  }

  export type QrCodeMaxAggregateInputType = {
    id?: true
    channelId?: true
    createdBy?: true
    qrData?: true
    expiresAt?: true
    scanCount?: true
    isActive?: true
    createdAt?: true
  }

  export type QrCodeCountAggregateInputType = {
    id?: true
    channelId?: true
    createdBy?: true
    qrData?: true
    expiresAt?: true
    scanCount?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type QrCodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QrCode to aggregate.
     */
    where?: QrCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QrCodes to fetch.
     */
    orderBy?: QrCodeOrderByWithRelationInput | QrCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QrCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QrCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QrCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QrCodes
    **/
    _count?: true | QrCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QrCodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QrCodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QrCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QrCodeMaxAggregateInputType
  }

  export type GetQrCodeAggregateType<T extends QrCodeAggregateArgs> = {
        [P in keyof T & keyof AggregateQrCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQrCode[P]>
      : GetScalarType<T[P], AggregateQrCode[P]>
  }




  export type QrCodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QrCodeWhereInput
    orderBy?: QrCodeOrderByWithAggregationInput | QrCodeOrderByWithAggregationInput[]
    by: QrCodeScalarFieldEnum[] | QrCodeScalarFieldEnum
    having?: QrCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QrCodeCountAggregateInputType | true
    _avg?: QrCodeAvgAggregateInputType
    _sum?: QrCodeSumAggregateInputType
    _min?: QrCodeMinAggregateInputType
    _max?: QrCodeMaxAggregateInputType
  }

  export type QrCodeGroupByOutputType = {
    id: string
    channelId: string
    createdBy: string
    qrData: string
    expiresAt: Date | null
    scanCount: number
    isActive: boolean
    createdAt: Date
    _count: QrCodeCountAggregateOutputType | null
    _avg: QrCodeAvgAggregateOutputType | null
    _sum: QrCodeSumAggregateOutputType | null
    _min: QrCodeMinAggregateOutputType | null
    _max: QrCodeMaxAggregateOutputType | null
  }

  type GetQrCodeGroupByPayload<T extends QrCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QrCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QrCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QrCodeGroupByOutputType[P]>
            : GetScalarType<T[P], QrCodeGroupByOutputType[P]>
        }
      >
    >


  export type QrCodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    channelId?: boolean
    createdBy?: boolean
    qrData?: boolean
    expiresAt?: boolean
    scanCount?: boolean
    isActive?: boolean
    createdAt?: boolean
    channel?: boolean | ChannelDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["qrCode"]>


  export type QrCodeSelectScalar = {
    id?: boolean
    channelId?: boolean
    createdBy?: boolean
    qrData?: boolean
    expiresAt?: boolean
    scanCount?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type QrCodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    channel?: boolean | ChannelDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $QrCodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QrCode"
    objects: {
      channel: Prisma.$ChannelPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      channelId: string
      createdBy: string
      qrData: string
      expiresAt: Date | null
      scanCount: number
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["qrCode"]>
    composites: {}
  }

  type QrCodeGetPayload<S extends boolean | null | undefined | QrCodeDefaultArgs> = $Result.GetResult<Prisma.$QrCodePayload, S>

  type QrCodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QrCodeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QrCodeCountAggregateInputType | true
    }

  export interface QrCodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QrCode'], meta: { name: 'QrCode' } }
    /**
     * Find zero or one QrCode that matches the filter.
     * @param {QrCodeFindUniqueArgs} args - Arguments to find a QrCode
     * @example
     * // Get one QrCode
     * const qrCode = await prisma.qrCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QrCodeFindUniqueArgs>(args: SelectSubset<T, QrCodeFindUniqueArgs<ExtArgs>>): Prisma__QrCodeClient<$Result.GetResult<Prisma.$QrCodePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one QrCode that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QrCodeFindUniqueOrThrowArgs} args - Arguments to find a QrCode
     * @example
     * // Get one QrCode
     * const qrCode = await prisma.qrCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QrCodeFindUniqueOrThrowArgs>(args: SelectSubset<T, QrCodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QrCodeClient<$Result.GetResult<Prisma.$QrCodePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first QrCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QrCodeFindFirstArgs} args - Arguments to find a QrCode
     * @example
     * // Get one QrCode
     * const qrCode = await prisma.qrCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QrCodeFindFirstArgs>(args?: SelectSubset<T, QrCodeFindFirstArgs<ExtArgs>>): Prisma__QrCodeClient<$Result.GetResult<Prisma.$QrCodePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first QrCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QrCodeFindFirstOrThrowArgs} args - Arguments to find a QrCode
     * @example
     * // Get one QrCode
     * const qrCode = await prisma.qrCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QrCodeFindFirstOrThrowArgs>(args?: SelectSubset<T, QrCodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__QrCodeClient<$Result.GetResult<Prisma.$QrCodePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more QrCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QrCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QrCodes
     * const qrCodes = await prisma.qrCode.findMany()
     * 
     * // Get first 10 QrCodes
     * const qrCodes = await prisma.qrCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const qrCodeWithIdOnly = await prisma.qrCode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QrCodeFindManyArgs>(args?: SelectSubset<T, QrCodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QrCodePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a QrCode.
     * @param {QrCodeCreateArgs} args - Arguments to create a QrCode.
     * @example
     * // Create one QrCode
     * const QrCode = await prisma.qrCode.create({
     *   data: {
     *     // ... data to create a QrCode
     *   }
     * })
     * 
     */
    create<T extends QrCodeCreateArgs>(args: SelectSubset<T, QrCodeCreateArgs<ExtArgs>>): Prisma__QrCodeClient<$Result.GetResult<Prisma.$QrCodePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many QrCodes.
     * @param {QrCodeCreateManyArgs} args - Arguments to create many QrCodes.
     * @example
     * // Create many QrCodes
     * const qrCode = await prisma.qrCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QrCodeCreateManyArgs>(args?: SelectSubset<T, QrCodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QrCode.
     * @param {QrCodeDeleteArgs} args - Arguments to delete one QrCode.
     * @example
     * // Delete one QrCode
     * const QrCode = await prisma.qrCode.delete({
     *   where: {
     *     // ... filter to delete one QrCode
     *   }
     * })
     * 
     */
    delete<T extends QrCodeDeleteArgs>(args: SelectSubset<T, QrCodeDeleteArgs<ExtArgs>>): Prisma__QrCodeClient<$Result.GetResult<Prisma.$QrCodePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one QrCode.
     * @param {QrCodeUpdateArgs} args - Arguments to update one QrCode.
     * @example
     * // Update one QrCode
     * const qrCode = await prisma.qrCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QrCodeUpdateArgs>(args: SelectSubset<T, QrCodeUpdateArgs<ExtArgs>>): Prisma__QrCodeClient<$Result.GetResult<Prisma.$QrCodePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more QrCodes.
     * @param {QrCodeDeleteManyArgs} args - Arguments to filter QrCodes to delete.
     * @example
     * // Delete a few QrCodes
     * const { count } = await prisma.qrCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QrCodeDeleteManyArgs>(args?: SelectSubset<T, QrCodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QrCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QrCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QrCodes
     * const qrCode = await prisma.qrCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QrCodeUpdateManyArgs>(args: SelectSubset<T, QrCodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QrCode.
     * @param {QrCodeUpsertArgs} args - Arguments to update or create a QrCode.
     * @example
     * // Update or create a QrCode
     * const qrCode = await prisma.qrCode.upsert({
     *   create: {
     *     // ... data to create a QrCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QrCode we want to update
     *   }
     * })
     */
    upsert<T extends QrCodeUpsertArgs>(args: SelectSubset<T, QrCodeUpsertArgs<ExtArgs>>): Prisma__QrCodeClient<$Result.GetResult<Prisma.$QrCodePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of QrCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QrCodeCountArgs} args - Arguments to filter QrCodes to count.
     * @example
     * // Count the number of QrCodes
     * const count = await prisma.qrCode.count({
     *   where: {
     *     // ... the filter for the QrCodes we want to count
     *   }
     * })
    **/
    count<T extends QrCodeCountArgs>(
      args?: Subset<T, QrCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QrCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QrCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QrCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QrCodeAggregateArgs>(args: Subset<T, QrCodeAggregateArgs>): Prisma.PrismaPromise<GetQrCodeAggregateType<T>>

    /**
     * Group by QrCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QrCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QrCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QrCodeGroupByArgs['orderBy'] }
        : { orderBy?: QrCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QrCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQrCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QrCode model
   */
  readonly fields: QrCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QrCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QrCodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    channel<T extends ChannelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChannelDefaultArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QrCode model
   */ 
  interface QrCodeFieldRefs {
    readonly id: FieldRef<"QrCode", 'String'>
    readonly channelId: FieldRef<"QrCode", 'String'>
    readonly createdBy: FieldRef<"QrCode", 'String'>
    readonly qrData: FieldRef<"QrCode", 'String'>
    readonly expiresAt: FieldRef<"QrCode", 'DateTime'>
    readonly scanCount: FieldRef<"QrCode", 'Int'>
    readonly isActive: FieldRef<"QrCode", 'Boolean'>
    readonly createdAt: FieldRef<"QrCode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QrCode findUnique
   */
  export type QrCodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QrCode
     */
    select?: QrCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QrCodeInclude<ExtArgs> | null
    /**
     * Filter, which QrCode to fetch.
     */
    where: QrCodeWhereUniqueInput
  }

  /**
   * QrCode findUniqueOrThrow
   */
  export type QrCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QrCode
     */
    select?: QrCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QrCodeInclude<ExtArgs> | null
    /**
     * Filter, which QrCode to fetch.
     */
    where: QrCodeWhereUniqueInput
  }

  /**
   * QrCode findFirst
   */
  export type QrCodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QrCode
     */
    select?: QrCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QrCodeInclude<ExtArgs> | null
    /**
     * Filter, which QrCode to fetch.
     */
    where?: QrCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QrCodes to fetch.
     */
    orderBy?: QrCodeOrderByWithRelationInput | QrCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QrCodes.
     */
    cursor?: QrCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QrCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QrCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QrCodes.
     */
    distinct?: QrCodeScalarFieldEnum | QrCodeScalarFieldEnum[]
  }

  /**
   * QrCode findFirstOrThrow
   */
  export type QrCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QrCode
     */
    select?: QrCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QrCodeInclude<ExtArgs> | null
    /**
     * Filter, which QrCode to fetch.
     */
    where?: QrCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QrCodes to fetch.
     */
    orderBy?: QrCodeOrderByWithRelationInput | QrCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QrCodes.
     */
    cursor?: QrCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QrCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QrCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QrCodes.
     */
    distinct?: QrCodeScalarFieldEnum | QrCodeScalarFieldEnum[]
  }

  /**
   * QrCode findMany
   */
  export type QrCodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QrCode
     */
    select?: QrCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QrCodeInclude<ExtArgs> | null
    /**
     * Filter, which QrCodes to fetch.
     */
    where?: QrCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QrCodes to fetch.
     */
    orderBy?: QrCodeOrderByWithRelationInput | QrCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QrCodes.
     */
    cursor?: QrCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QrCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QrCodes.
     */
    skip?: number
    distinct?: QrCodeScalarFieldEnum | QrCodeScalarFieldEnum[]
  }

  /**
   * QrCode create
   */
  export type QrCodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QrCode
     */
    select?: QrCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QrCodeInclude<ExtArgs> | null
    /**
     * The data needed to create a QrCode.
     */
    data: XOR<QrCodeCreateInput, QrCodeUncheckedCreateInput>
  }

  /**
   * QrCode createMany
   */
  export type QrCodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QrCodes.
     */
    data: QrCodeCreateManyInput | QrCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QrCode update
   */
  export type QrCodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QrCode
     */
    select?: QrCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QrCodeInclude<ExtArgs> | null
    /**
     * The data needed to update a QrCode.
     */
    data: XOR<QrCodeUpdateInput, QrCodeUncheckedUpdateInput>
    /**
     * Choose, which QrCode to update.
     */
    where: QrCodeWhereUniqueInput
  }

  /**
   * QrCode updateMany
   */
  export type QrCodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QrCodes.
     */
    data: XOR<QrCodeUpdateManyMutationInput, QrCodeUncheckedUpdateManyInput>
    /**
     * Filter which QrCodes to update
     */
    where?: QrCodeWhereInput
  }

  /**
   * QrCode upsert
   */
  export type QrCodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QrCode
     */
    select?: QrCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QrCodeInclude<ExtArgs> | null
    /**
     * The filter to search for the QrCode to update in case it exists.
     */
    where: QrCodeWhereUniqueInput
    /**
     * In case the QrCode found by the `where` argument doesn't exist, create a new QrCode with this data.
     */
    create: XOR<QrCodeCreateInput, QrCodeUncheckedCreateInput>
    /**
     * In case the QrCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QrCodeUpdateInput, QrCodeUncheckedUpdateInput>
  }

  /**
   * QrCode delete
   */
  export type QrCodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QrCode
     */
    select?: QrCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QrCodeInclude<ExtArgs> | null
    /**
     * Filter which QrCode to delete.
     */
    where: QrCodeWhereUniqueInput
  }

  /**
   * QrCode deleteMany
   */
  export type QrCodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QrCodes to delete
     */
    where?: QrCodeWhereInput
  }

  /**
   * QrCode without action
   */
  export type QrCodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QrCode
     */
    select?: QrCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QrCodeInclude<ExtArgs> | null
  }


  /**
   * Model Organization
   */

  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  export type OrganizationMinAggregateOutputType = {
    id: string | null
    name: string | null
    nit: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    nit: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationCountAggregateOutputType = {
    id: number
    name: number
    nit: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrganizationMinAggregateInputType = {
    id?: true
    name?: true
    nit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationMaxAggregateInputType = {
    id?: true
    name?: true
    nit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationCountAggregateInputType = {
    id?: true
    name?: true
    nit?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrganizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organization to aggregate.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organizations
    **/
    _count?: true | OrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMaxAggregateInputType
  }

  export type GetOrganizationAggregateType<T extends OrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>
  }




  export type OrganizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationWhereInput
    orderBy?: OrganizationOrderByWithAggregationInput | OrganizationOrderByWithAggregationInput[]
    by: OrganizationScalarFieldEnum[] | OrganizationScalarFieldEnum
    having?: OrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationCountAggregateInputType | true
    _min?: OrganizationMinAggregateInputType
    _max?: OrganizationMaxAggregateInputType
  }

  export type OrganizationGroupByOutputType = {
    id: string
    name: string
    nit: string
    createdAt: Date
    updatedAt: Date
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  type GetOrganizationGroupByPayload<T extends OrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    nit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    channels?: boolean | Organization$channelsArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organization"]>


  export type OrganizationSelectScalar = {
    id?: boolean
    name?: boolean
    nit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrganizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    channels?: boolean | Organization$channelsArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $OrganizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Organization"
    objects: {
      channels: Prisma.$ChannelPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      nit: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["organization"]>
    composites: {}
  }

  type OrganizationGetPayload<S extends boolean | null | undefined | OrganizationDefaultArgs> = $Result.GetResult<Prisma.$OrganizationPayload, S>

  type OrganizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrganizationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrganizationCountAggregateInputType | true
    }

  export interface OrganizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Organization'], meta: { name: 'Organization' } }
    /**
     * Find zero or one Organization that matches the filter.
     * @param {OrganizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationFindUniqueArgs>(args: SelectSubset<T, OrganizationFindUniqueArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Organization that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrganizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationFindFirstArgs>(args?: SelectSubset<T, OrganizationFindFirstArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Organization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationFindManyArgs>(args?: SelectSubset<T, OrganizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Organization.
     * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     * 
     */
    create<T extends OrganizationCreateArgs>(args: SelectSubset<T, OrganizationCreateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Organizations.
     * @param {OrganizationCreateManyArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationCreateManyArgs>(args?: SelectSubset<T, OrganizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Organization.
     * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     * 
     */
    delete<T extends OrganizationDeleteArgs>(args: SelectSubset<T, OrganizationDeleteArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Organization.
     * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationUpdateArgs>(args: SelectSubset<T, OrganizationUpdateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Organizations.
     * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationDeleteManyArgs>(args?: SelectSubset<T, OrganizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationUpdateManyArgs>(args: SelectSubset<T, OrganizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Organization.
     * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationUpsertArgs>(args: SelectSubset<T, OrganizationUpsertArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends OrganizationCountArgs>(
      args?: Subset<T, OrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationAggregateArgs>(args: Subset<T, OrganizationAggregateArgs>): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Organization model
   */
  readonly fields: OrganizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    channels<T extends Organization$channelsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$channelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Organization model
   */ 
  interface OrganizationFieldRefs {
    readonly id: FieldRef<"Organization", 'String'>
    readonly name: FieldRef<"Organization", 'String'>
    readonly nit: FieldRef<"Organization", 'String'>
    readonly createdAt: FieldRef<"Organization", 'DateTime'>
    readonly updatedAt: FieldRef<"Organization", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Organization findUnique
   */
  export type OrganizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findUniqueOrThrow
   */
  export type OrganizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findFirst
   */
  export type OrganizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findFirstOrThrow
   */
  export type OrganizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findMany
   */
  export type OrganizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organizations to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization create
   */
  export type OrganizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to create a Organization.
     */
    data: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
  }

  /**
   * Organization createMany
   */
  export type OrganizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization update
   */
  export type OrganizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to update a Organization.
     */
    data: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
    /**
     * Choose, which Organization to update.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization updateMany
   */
  export type OrganizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
  }

  /**
   * Organization upsert
   */
  export type OrganizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The filter to search for the Organization to update in case it exists.
     */
    where: OrganizationWhereUniqueInput
    /**
     * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
     */
    create: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
    /**
     * In case the Organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
  }

  /**
   * Organization delete
   */
  export type OrganizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter which Organization to delete.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization deleteMany
   */
  export type OrganizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organizations to delete
     */
    where?: OrganizationWhereInput
  }

  /**
   * Organization.channels
   */
  export type Organization$channelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    where?: ChannelWhereInput
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    cursor?: ChannelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * Organization without action
   */
  export type OrganizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
  }


  /**
   * Model ChannelApprover
   */

  export type AggregateChannelApprover = {
    _count: ChannelApproverCountAggregateOutputType | null
    _min: ChannelApproverMinAggregateOutputType | null
    _max: ChannelApproverMaxAggregateOutputType | null
  }

  export type ChannelApproverMinAggregateOutputType = {
    id: string | null
    channelId: string | null
    userId: string | null
    isActive: boolean | null
    removedAt: Date | null
    removedBy: string | null
    createdAt: Date | null
  }

  export type ChannelApproverMaxAggregateOutputType = {
    id: string | null
    channelId: string | null
    userId: string | null
    isActive: boolean | null
    removedAt: Date | null
    removedBy: string | null
    createdAt: Date | null
  }

  export type ChannelApproverCountAggregateOutputType = {
    id: number
    channelId: number
    userId: number
    isActive: number
    removedAt: number
    removedBy: number
    createdAt: number
    _all: number
  }


  export type ChannelApproverMinAggregateInputType = {
    id?: true
    channelId?: true
    userId?: true
    isActive?: true
    removedAt?: true
    removedBy?: true
    createdAt?: true
  }

  export type ChannelApproverMaxAggregateInputType = {
    id?: true
    channelId?: true
    userId?: true
    isActive?: true
    removedAt?: true
    removedBy?: true
    createdAt?: true
  }

  export type ChannelApproverCountAggregateInputType = {
    id?: true
    channelId?: true
    userId?: true
    isActive?: true
    removedAt?: true
    removedBy?: true
    createdAt?: true
    _all?: true
  }

  export type ChannelApproverAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChannelApprover to aggregate.
     */
    where?: ChannelApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelApprovers to fetch.
     */
    orderBy?: ChannelApproverOrderByWithRelationInput | ChannelApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChannelApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChannelApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChannelApprovers
    **/
    _count?: true | ChannelApproverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChannelApproverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChannelApproverMaxAggregateInputType
  }

  export type GetChannelApproverAggregateType<T extends ChannelApproverAggregateArgs> = {
        [P in keyof T & keyof AggregateChannelApprover]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChannelApprover[P]>
      : GetScalarType<T[P], AggregateChannelApprover[P]>
  }




  export type ChannelApproverGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelApproverWhereInput
    orderBy?: ChannelApproverOrderByWithAggregationInput | ChannelApproverOrderByWithAggregationInput[]
    by: ChannelApproverScalarFieldEnum[] | ChannelApproverScalarFieldEnum
    having?: ChannelApproverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChannelApproverCountAggregateInputType | true
    _min?: ChannelApproverMinAggregateInputType
    _max?: ChannelApproverMaxAggregateInputType
  }

  export type ChannelApproverGroupByOutputType = {
    id: string
    channelId: string
    userId: string
    isActive: boolean
    removedAt: Date | null
    removedBy: string | null
    createdAt: Date
    _count: ChannelApproverCountAggregateOutputType | null
    _min: ChannelApproverMinAggregateOutputType | null
    _max: ChannelApproverMaxAggregateOutputType | null
  }

  type GetChannelApproverGroupByPayload<T extends ChannelApproverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChannelApproverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChannelApproverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChannelApproverGroupByOutputType[P]>
            : GetScalarType<T[P], ChannelApproverGroupByOutputType[P]>
        }
      >
    >


  export type ChannelApproverSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    channelId?: boolean
    userId?: boolean
    isActive?: boolean
    removedAt?: boolean
    removedBy?: boolean
    createdAt?: boolean
    channel?: boolean | ChannelDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["channelApprover"]>


  export type ChannelApproverSelectScalar = {
    id?: boolean
    channelId?: boolean
    userId?: boolean
    isActive?: boolean
    removedAt?: boolean
    removedBy?: boolean
    createdAt?: boolean
  }

  export type ChannelApproverInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    channel?: boolean | ChannelDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ChannelApproverPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChannelApprover"
    objects: {
      channel: Prisma.$ChannelPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      channelId: string
      userId: string
      isActive: boolean
      removedAt: Date | null
      removedBy: string | null
      createdAt: Date
    }, ExtArgs["result"]["channelApprover"]>
    composites: {}
  }

  type ChannelApproverGetPayload<S extends boolean | null | undefined | ChannelApproverDefaultArgs> = $Result.GetResult<Prisma.$ChannelApproverPayload, S>

  type ChannelApproverCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChannelApproverFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChannelApproverCountAggregateInputType | true
    }

  export interface ChannelApproverDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChannelApprover'], meta: { name: 'ChannelApprover' } }
    /**
     * Find zero or one ChannelApprover that matches the filter.
     * @param {ChannelApproverFindUniqueArgs} args - Arguments to find a ChannelApprover
     * @example
     * // Get one ChannelApprover
     * const channelApprover = await prisma.channelApprover.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChannelApproverFindUniqueArgs>(args: SelectSubset<T, ChannelApproverFindUniqueArgs<ExtArgs>>): Prisma__ChannelApproverClient<$Result.GetResult<Prisma.$ChannelApproverPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ChannelApprover that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChannelApproverFindUniqueOrThrowArgs} args - Arguments to find a ChannelApprover
     * @example
     * // Get one ChannelApprover
     * const channelApprover = await prisma.channelApprover.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChannelApproverFindUniqueOrThrowArgs>(args: SelectSubset<T, ChannelApproverFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChannelApproverClient<$Result.GetResult<Prisma.$ChannelApproverPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ChannelApprover that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelApproverFindFirstArgs} args - Arguments to find a ChannelApprover
     * @example
     * // Get one ChannelApprover
     * const channelApprover = await prisma.channelApprover.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChannelApproverFindFirstArgs>(args?: SelectSubset<T, ChannelApproverFindFirstArgs<ExtArgs>>): Prisma__ChannelApproverClient<$Result.GetResult<Prisma.$ChannelApproverPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ChannelApprover that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelApproverFindFirstOrThrowArgs} args - Arguments to find a ChannelApprover
     * @example
     * // Get one ChannelApprover
     * const channelApprover = await prisma.channelApprover.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChannelApproverFindFirstOrThrowArgs>(args?: SelectSubset<T, ChannelApproverFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChannelApproverClient<$Result.GetResult<Prisma.$ChannelApproverPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ChannelApprovers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelApproverFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChannelApprovers
     * const channelApprovers = await prisma.channelApprover.findMany()
     * 
     * // Get first 10 ChannelApprovers
     * const channelApprovers = await prisma.channelApprover.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const channelApproverWithIdOnly = await prisma.channelApprover.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChannelApproverFindManyArgs>(args?: SelectSubset<T, ChannelApproverFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelApproverPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ChannelApprover.
     * @param {ChannelApproverCreateArgs} args - Arguments to create a ChannelApprover.
     * @example
     * // Create one ChannelApprover
     * const ChannelApprover = await prisma.channelApprover.create({
     *   data: {
     *     // ... data to create a ChannelApprover
     *   }
     * })
     * 
     */
    create<T extends ChannelApproverCreateArgs>(args: SelectSubset<T, ChannelApproverCreateArgs<ExtArgs>>): Prisma__ChannelApproverClient<$Result.GetResult<Prisma.$ChannelApproverPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ChannelApprovers.
     * @param {ChannelApproverCreateManyArgs} args - Arguments to create many ChannelApprovers.
     * @example
     * // Create many ChannelApprovers
     * const channelApprover = await prisma.channelApprover.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChannelApproverCreateManyArgs>(args?: SelectSubset<T, ChannelApproverCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ChannelApprover.
     * @param {ChannelApproverDeleteArgs} args - Arguments to delete one ChannelApprover.
     * @example
     * // Delete one ChannelApprover
     * const ChannelApprover = await prisma.channelApprover.delete({
     *   where: {
     *     // ... filter to delete one ChannelApprover
     *   }
     * })
     * 
     */
    delete<T extends ChannelApproverDeleteArgs>(args: SelectSubset<T, ChannelApproverDeleteArgs<ExtArgs>>): Prisma__ChannelApproverClient<$Result.GetResult<Prisma.$ChannelApproverPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ChannelApprover.
     * @param {ChannelApproverUpdateArgs} args - Arguments to update one ChannelApprover.
     * @example
     * // Update one ChannelApprover
     * const channelApprover = await prisma.channelApprover.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChannelApproverUpdateArgs>(args: SelectSubset<T, ChannelApproverUpdateArgs<ExtArgs>>): Prisma__ChannelApproverClient<$Result.GetResult<Prisma.$ChannelApproverPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ChannelApprovers.
     * @param {ChannelApproverDeleteManyArgs} args - Arguments to filter ChannelApprovers to delete.
     * @example
     * // Delete a few ChannelApprovers
     * const { count } = await prisma.channelApprover.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChannelApproverDeleteManyArgs>(args?: SelectSubset<T, ChannelApproverDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChannelApprovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelApproverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChannelApprovers
     * const channelApprover = await prisma.channelApprover.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChannelApproverUpdateManyArgs>(args: SelectSubset<T, ChannelApproverUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChannelApprover.
     * @param {ChannelApproverUpsertArgs} args - Arguments to update or create a ChannelApprover.
     * @example
     * // Update or create a ChannelApprover
     * const channelApprover = await prisma.channelApprover.upsert({
     *   create: {
     *     // ... data to create a ChannelApprover
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChannelApprover we want to update
     *   }
     * })
     */
    upsert<T extends ChannelApproverUpsertArgs>(args: SelectSubset<T, ChannelApproverUpsertArgs<ExtArgs>>): Prisma__ChannelApproverClient<$Result.GetResult<Prisma.$ChannelApproverPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ChannelApprovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelApproverCountArgs} args - Arguments to filter ChannelApprovers to count.
     * @example
     * // Count the number of ChannelApprovers
     * const count = await prisma.channelApprover.count({
     *   where: {
     *     // ... the filter for the ChannelApprovers we want to count
     *   }
     * })
    **/
    count<T extends ChannelApproverCountArgs>(
      args?: Subset<T, ChannelApproverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChannelApproverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChannelApprover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelApproverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChannelApproverAggregateArgs>(args: Subset<T, ChannelApproverAggregateArgs>): Prisma.PrismaPromise<GetChannelApproverAggregateType<T>>

    /**
     * Group by ChannelApprover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelApproverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChannelApproverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChannelApproverGroupByArgs['orderBy'] }
        : { orderBy?: ChannelApproverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChannelApproverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChannelApproverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChannelApprover model
   */
  readonly fields: ChannelApproverFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChannelApprover.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChannelApproverClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    channel<T extends ChannelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChannelDefaultArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChannelApprover model
   */ 
  interface ChannelApproverFieldRefs {
    readonly id: FieldRef<"ChannelApprover", 'String'>
    readonly channelId: FieldRef<"ChannelApprover", 'String'>
    readonly userId: FieldRef<"ChannelApprover", 'String'>
    readonly isActive: FieldRef<"ChannelApprover", 'Boolean'>
    readonly removedAt: FieldRef<"ChannelApprover", 'DateTime'>
    readonly removedBy: FieldRef<"ChannelApprover", 'String'>
    readonly createdAt: FieldRef<"ChannelApprover", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChannelApprover findUnique
   */
  export type ChannelApproverFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelApprover
     */
    select?: ChannelApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelApproverInclude<ExtArgs> | null
    /**
     * Filter, which ChannelApprover to fetch.
     */
    where: ChannelApproverWhereUniqueInput
  }

  /**
   * ChannelApprover findUniqueOrThrow
   */
  export type ChannelApproverFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelApprover
     */
    select?: ChannelApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelApproverInclude<ExtArgs> | null
    /**
     * Filter, which ChannelApprover to fetch.
     */
    where: ChannelApproverWhereUniqueInput
  }

  /**
   * ChannelApprover findFirst
   */
  export type ChannelApproverFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelApprover
     */
    select?: ChannelApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelApproverInclude<ExtArgs> | null
    /**
     * Filter, which ChannelApprover to fetch.
     */
    where?: ChannelApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelApprovers to fetch.
     */
    orderBy?: ChannelApproverOrderByWithRelationInput | ChannelApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChannelApprovers.
     */
    cursor?: ChannelApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChannelApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChannelApprovers.
     */
    distinct?: ChannelApproverScalarFieldEnum | ChannelApproverScalarFieldEnum[]
  }

  /**
   * ChannelApprover findFirstOrThrow
   */
  export type ChannelApproverFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelApprover
     */
    select?: ChannelApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelApproverInclude<ExtArgs> | null
    /**
     * Filter, which ChannelApprover to fetch.
     */
    where?: ChannelApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelApprovers to fetch.
     */
    orderBy?: ChannelApproverOrderByWithRelationInput | ChannelApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChannelApprovers.
     */
    cursor?: ChannelApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChannelApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChannelApprovers.
     */
    distinct?: ChannelApproverScalarFieldEnum | ChannelApproverScalarFieldEnum[]
  }

  /**
   * ChannelApprover findMany
   */
  export type ChannelApproverFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelApprover
     */
    select?: ChannelApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelApproverInclude<ExtArgs> | null
    /**
     * Filter, which ChannelApprovers to fetch.
     */
    where?: ChannelApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelApprovers to fetch.
     */
    orderBy?: ChannelApproverOrderByWithRelationInput | ChannelApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChannelApprovers.
     */
    cursor?: ChannelApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChannelApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelApprovers.
     */
    skip?: number
    distinct?: ChannelApproverScalarFieldEnum | ChannelApproverScalarFieldEnum[]
  }

  /**
   * ChannelApprover create
   */
  export type ChannelApproverCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelApprover
     */
    select?: ChannelApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelApproverInclude<ExtArgs> | null
    /**
     * The data needed to create a ChannelApprover.
     */
    data: XOR<ChannelApproverCreateInput, ChannelApproverUncheckedCreateInput>
  }

  /**
   * ChannelApprover createMany
   */
  export type ChannelApproverCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChannelApprovers.
     */
    data: ChannelApproverCreateManyInput | ChannelApproverCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChannelApprover update
   */
  export type ChannelApproverUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelApprover
     */
    select?: ChannelApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelApproverInclude<ExtArgs> | null
    /**
     * The data needed to update a ChannelApprover.
     */
    data: XOR<ChannelApproverUpdateInput, ChannelApproverUncheckedUpdateInput>
    /**
     * Choose, which ChannelApprover to update.
     */
    where: ChannelApproverWhereUniqueInput
  }

  /**
   * ChannelApprover updateMany
   */
  export type ChannelApproverUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChannelApprovers.
     */
    data: XOR<ChannelApproverUpdateManyMutationInput, ChannelApproverUncheckedUpdateManyInput>
    /**
     * Filter which ChannelApprovers to update
     */
    where?: ChannelApproverWhereInput
  }

  /**
   * ChannelApprover upsert
   */
  export type ChannelApproverUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelApprover
     */
    select?: ChannelApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelApproverInclude<ExtArgs> | null
    /**
     * The filter to search for the ChannelApprover to update in case it exists.
     */
    where: ChannelApproverWhereUniqueInput
    /**
     * In case the ChannelApprover found by the `where` argument doesn't exist, create a new ChannelApprover with this data.
     */
    create: XOR<ChannelApproverCreateInput, ChannelApproverUncheckedCreateInput>
    /**
     * In case the ChannelApprover was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChannelApproverUpdateInput, ChannelApproverUncheckedUpdateInput>
  }

  /**
   * ChannelApprover delete
   */
  export type ChannelApproverDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelApprover
     */
    select?: ChannelApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelApproverInclude<ExtArgs> | null
    /**
     * Filter which ChannelApprover to delete.
     */
    where: ChannelApproverWhereUniqueInput
  }

  /**
   * ChannelApprover deleteMany
   */
  export type ChannelApproverDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChannelApprovers to delete
     */
    where?: ChannelApproverWhereInput
  }

  /**
   * ChannelApprover without action
   */
  export type ChannelApproverDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelApprover
     */
    select?: ChannelApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelApproverInclude<ExtArgs> | null
  }


  /**
   * Model MessageApproval
   */

  export type AggregateMessageApproval = {
    _count: MessageApprovalCountAggregateOutputType | null
    _min: MessageApprovalMinAggregateOutputType | null
    _max: MessageApprovalMaxAggregateOutputType | null
  }

  export type MessageApprovalMinAggregateOutputType = {
    id: string | null
    messageId: string | null
    approverId: string | null
    status: $Enums.ApprovalStatus | null
    decidedAt: Date | null
  }

  export type MessageApprovalMaxAggregateOutputType = {
    id: string | null
    messageId: string | null
    approverId: string | null
    status: $Enums.ApprovalStatus | null
    decidedAt: Date | null
  }

  export type MessageApprovalCountAggregateOutputType = {
    id: number
    messageId: number
    approverId: number
    status: number
    decidedAt: number
    _all: number
  }


  export type MessageApprovalMinAggregateInputType = {
    id?: true
    messageId?: true
    approverId?: true
    status?: true
    decidedAt?: true
  }

  export type MessageApprovalMaxAggregateInputType = {
    id?: true
    messageId?: true
    approverId?: true
    status?: true
    decidedAt?: true
  }

  export type MessageApprovalCountAggregateInputType = {
    id?: true
    messageId?: true
    approverId?: true
    status?: true
    decidedAt?: true
    _all?: true
  }

  export type MessageApprovalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageApproval to aggregate.
     */
    where?: MessageApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageApprovals to fetch.
     */
    orderBy?: MessageApprovalOrderByWithRelationInput | MessageApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageApprovals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageApprovals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageApprovals
    **/
    _count?: true | MessageApprovalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageApprovalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageApprovalMaxAggregateInputType
  }

  export type GetMessageApprovalAggregateType<T extends MessageApprovalAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageApproval]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageApproval[P]>
      : GetScalarType<T[P], AggregateMessageApproval[P]>
  }




  export type MessageApprovalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageApprovalWhereInput
    orderBy?: MessageApprovalOrderByWithAggregationInput | MessageApprovalOrderByWithAggregationInput[]
    by: MessageApprovalScalarFieldEnum[] | MessageApprovalScalarFieldEnum
    having?: MessageApprovalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageApprovalCountAggregateInputType | true
    _min?: MessageApprovalMinAggregateInputType
    _max?: MessageApprovalMaxAggregateInputType
  }

  export type MessageApprovalGroupByOutputType = {
    id: string
    messageId: string
    approverId: string
    status: $Enums.ApprovalStatus
    decidedAt: Date | null
    _count: MessageApprovalCountAggregateOutputType | null
    _min: MessageApprovalMinAggregateOutputType | null
    _max: MessageApprovalMaxAggregateOutputType | null
  }

  type GetMessageApprovalGroupByPayload<T extends MessageApprovalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageApprovalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageApprovalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageApprovalGroupByOutputType[P]>
            : GetScalarType<T[P], MessageApprovalGroupByOutputType[P]>
        }
      >
    >


  export type MessageApprovalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    approverId?: boolean
    status?: boolean
    decidedAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
    approver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageApproval"]>


  export type MessageApprovalSelectScalar = {
    id?: boolean
    messageId?: boolean
    approverId?: boolean
    status?: boolean
    decidedAt?: boolean
  }

  export type MessageApprovalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
    approver?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MessageApprovalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageApproval"
    objects: {
      message: Prisma.$MessagePayload<ExtArgs>
      approver: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      messageId: string
      approverId: string
      status: $Enums.ApprovalStatus
      decidedAt: Date | null
    }, ExtArgs["result"]["messageApproval"]>
    composites: {}
  }

  type MessageApprovalGetPayload<S extends boolean | null | undefined | MessageApprovalDefaultArgs> = $Result.GetResult<Prisma.$MessageApprovalPayload, S>

  type MessageApprovalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageApprovalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageApprovalCountAggregateInputType | true
    }

  export interface MessageApprovalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageApproval'], meta: { name: 'MessageApproval' } }
    /**
     * Find zero or one MessageApproval that matches the filter.
     * @param {MessageApprovalFindUniqueArgs} args - Arguments to find a MessageApproval
     * @example
     * // Get one MessageApproval
     * const messageApproval = await prisma.messageApproval.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageApprovalFindUniqueArgs>(args: SelectSubset<T, MessageApprovalFindUniqueArgs<ExtArgs>>): Prisma__MessageApprovalClient<$Result.GetResult<Prisma.$MessageApprovalPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MessageApproval that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageApprovalFindUniqueOrThrowArgs} args - Arguments to find a MessageApproval
     * @example
     * // Get one MessageApproval
     * const messageApproval = await prisma.messageApproval.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageApprovalFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageApprovalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageApprovalClient<$Result.GetResult<Prisma.$MessageApprovalPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MessageApproval that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageApprovalFindFirstArgs} args - Arguments to find a MessageApproval
     * @example
     * // Get one MessageApproval
     * const messageApproval = await prisma.messageApproval.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageApprovalFindFirstArgs>(args?: SelectSubset<T, MessageApprovalFindFirstArgs<ExtArgs>>): Prisma__MessageApprovalClient<$Result.GetResult<Prisma.$MessageApprovalPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MessageApproval that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageApprovalFindFirstOrThrowArgs} args - Arguments to find a MessageApproval
     * @example
     * // Get one MessageApproval
     * const messageApproval = await prisma.messageApproval.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageApprovalFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageApprovalFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageApprovalClient<$Result.GetResult<Prisma.$MessageApprovalPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MessageApprovals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageApprovalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageApprovals
     * const messageApprovals = await prisma.messageApproval.findMany()
     * 
     * // Get first 10 MessageApprovals
     * const messageApprovals = await prisma.messageApproval.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageApprovalWithIdOnly = await prisma.messageApproval.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageApprovalFindManyArgs>(args?: SelectSubset<T, MessageApprovalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageApprovalPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MessageApproval.
     * @param {MessageApprovalCreateArgs} args - Arguments to create a MessageApproval.
     * @example
     * // Create one MessageApproval
     * const MessageApproval = await prisma.messageApproval.create({
     *   data: {
     *     // ... data to create a MessageApproval
     *   }
     * })
     * 
     */
    create<T extends MessageApprovalCreateArgs>(args: SelectSubset<T, MessageApprovalCreateArgs<ExtArgs>>): Prisma__MessageApprovalClient<$Result.GetResult<Prisma.$MessageApprovalPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MessageApprovals.
     * @param {MessageApprovalCreateManyArgs} args - Arguments to create many MessageApprovals.
     * @example
     * // Create many MessageApprovals
     * const messageApproval = await prisma.messageApproval.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageApprovalCreateManyArgs>(args?: SelectSubset<T, MessageApprovalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MessageApproval.
     * @param {MessageApprovalDeleteArgs} args - Arguments to delete one MessageApproval.
     * @example
     * // Delete one MessageApproval
     * const MessageApproval = await prisma.messageApproval.delete({
     *   where: {
     *     // ... filter to delete one MessageApproval
     *   }
     * })
     * 
     */
    delete<T extends MessageApprovalDeleteArgs>(args: SelectSubset<T, MessageApprovalDeleteArgs<ExtArgs>>): Prisma__MessageApprovalClient<$Result.GetResult<Prisma.$MessageApprovalPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MessageApproval.
     * @param {MessageApprovalUpdateArgs} args - Arguments to update one MessageApproval.
     * @example
     * // Update one MessageApproval
     * const messageApproval = await prisma.messageApproval.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageApprovalUpdateArgs>(args: SelectSubset<T, MessageApprovalUpdateArgs<ExtArgs>>): Prisma__MessageApprovalClient<$Result.GetResult<Prisma.$MessageApprovalPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MessageApprovals.
     * @param {MessageApprovalDeleteManyArgs} args - Arguments to filter MessageApprovals to delete.
     * @example
     * // Delete a few MessageApprovals
     * const { count } = await prisma.messageApproval.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageApprovalDeleteManyArgs>(args?: SelectSubset<T, MessageApprovalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageApprovals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageApprovalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageApprovals
     * const messageApproval = await prisma.messageApproval.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageApprovalUpdateManyArgs>(args: SelectSubset<T, MessageApprovalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MessageApproval.
     * @param {MessageApprovalUpsertArgs} args - Arguments to update or create a MessageApproval.
     * @example
     * // Update or create a MessageApproval
     * const messageApproval = await prisma.messageApproval.upsert({
     *   create: {
     *     // ... data to create a MessageApproval
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageApproval we want to update
     *   }
     * })
     */
    upsert<T extends MessageApprovalUpsertArgs>(args: SelectSubset<T, MessageApprovalUpsertArgs<ExtArgs>>): Prisma__MessageApprovalClient<$Result.GetResult<Prisma.$MessageApprovalPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MessageApprovals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageApprovalCountArgs} args - Arguments to filter MessageApprovals to count.
     * @example
     * // Count the number of MessageApprovals
     * const count = await prisma.messageApproval.count({
     *   where: {
     *     // ... the filter for the MessageApprovals we want to count
     *   }
     * })
    **/
    count<T extends MessageApprovalCountArgs>(
      args?: Subset<T, MessageApprovalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageApprovalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageApproval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageApprovalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageApprovalAggregateArgs>(args: Subset<T, MessageApprovalAggregateArgs>): Prisma.PrismaPromise<GetMessageApprovalAggregateType<T>>

    /**
     * Group by MessageApproval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageApprovalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageApprovalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageApprovalGroupByArgs['orderBy'] }
        : { orderBy?: MessageApprovalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageApprovalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageApprovalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageApproval model
   */
  readonly fields: MessageApprovalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageApproval.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageApprovalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message<T extends MessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessageDefaultArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    approver<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessageApproval model
   */ 
  interface MessageApprovalFieldRefs {
    readonly id: FieldRef<"MessageApproval", 'String'>
    readonly messageId: FieldRef<"MessageApproval", 'String'>
    readonly approverId: FieldRef<"MessageApproval", 'String'>
    readonly status: FieldRef<"MessageApproval", 'ApprovalStatus'>
    readonly decidedAt: FieldRef<"MessageApproval", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MessageApproval findUnique
   */
  export type MessageApprovalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageApproval
     */
    select?: MessageApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageApprovalInclude<ExtArgs> | null
    /**
     * Filter, which MessageApproval to fetch.
     */
    where: MessageApprovalWhereUniqueInput
  }

  /**
   * MessageApproval findUniqueOrThrow
   */
  export type MessageApprovalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageApproval
     */
    select?: MessageApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageApprovalInclude<ExtArgs> | null
    /**
     * Filter, which MessageApproval to fetch.
     */
    where: MessageApprovalWhereUniqueInput
  }

  /**
   * MessageApproval findFirst
   */
  export type MessageApprovalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageApproval
     */
    select?: MessageApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageApprovalInclude<ExtArgs> | null
    /**
     * Filter, which MessageApproval to fetch.
     */
    where?: MessageApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageApprovals to fetch.
     */
    orderBy?: MessageApprovalOrderByWithRelationInput | MessageApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageApprovals.
     */
    cursor?: MessageApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageApprovals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageApprovals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageApprovals.
     */
    distinct?: MessageApprovalScalarFieldEnum | MessageApprovalScalarFieldEnum[]
  }

  /**
   * MessageApproval findFirstOrThrow
   */
  export type MessageApprovalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageApproval
     */
    select?: MessageApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageApprovalInclude<ExtArgs> | null
    /**
     * Filter, which MessageApproval to fetch.
     */
    where?: MessageApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageApprovals to fetch.
     */
    orderBy?: MessageApprovalOrderByWithRelationInput | MessageApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageApprovals.
     */
    cursor?: MessageApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageApprovals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageApprovals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageApprovals.
     */
    distinct?: MessageApprovalScalarFieldEnum | MessageApprovalScalarFieldEnum[]
  }

  /**
   * MessageApproval findMany
   */
  export type MessageApprovalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageApproval
     */
    select?: MessageApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageApprovalInclude<ExtArgs> | null
    /**
     * Filter, which MessageApprovals to fetch.
     */
    where?: MessageApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageApprovals to fetch.
     */
    orderBy?: MessageApprovalOrderByWithRelationInput | MessageApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageApprovals.
     */
    cursor?: MessageApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageApprovals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageApprovals.
     */
    skip?: number
    distinct?: MessageApprovalScalarFieldEnum | MessageApprovalScalarFieldEnum[]
  }

  /**
   * MessageApproval create
   */
  export type MessageApprovalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageApproval
     */
    select?: MessageApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageApprovalInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageApproval.
     */
    data: XOR<MessageApprovalCreateInput, MessageApprovalUncheckedCreateInput>
  }

  /**
   * MessageApproval createMany
   */
  export type MessageApprovalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageApprovals.
     */
    data: MessageApprovalCreateManyInput | MessageApprovalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageApproval update
   */
  export type MessageApprovalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageApproval
     */
    select?: MessageApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageApprovalInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageApproval.
     */
    data: XOR<MessageApprovalUpdateInput, MessageApprovalUncheckedUpdateInput>
    /**
     * Choose, which MessageApproval to update.
     */
    where: MessageApprovalWhereUniqueInput
  }

  /**
   * MessageApproval updateMany
   */
  export type MessageApprovalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageApprovals.
     */
    data: XOR<MessageApprovalUpdateManyMutationInput, MessageApprovalUncheckedUpdateManyInput>
    /**
     * Filter which MessageApprovals to update
     */
    where?: MessageApprovalWhereInput
  }

  /**
   * MessageApproval upsert
   */
  export type MessageApprovalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageApproval
     */
    select?: MessageApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageApprovalInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageApproval to update in case it exists.
     */
    where: MessageApprovalWhereUniqueInput
    /**
     * In case the MessageApproval found by the `where` argument doesn't exist, create a new MessageApproval with this data.
     */
    create: XOR<MessageApprovalCreateInput, MessageApprovalUncheckedCreateInput>
    /**
     * In case the MessageApproval was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageApprovalUpdateInput, MessageApprovalUncheckedUpdateInput>
  }

  /**
   * MessageApproval delete
   */
  export type MessageApprovalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageApproval
     */
    select?: MessageApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageApprovalInclude<ExtArgs> | null
    /**
     * Filter which MessageApproval to delete.
     */
    where: MessageApprovalWhereUniqueInput
  }

  /**
   * MessageApproval deleteMany
   */
  export type MessageApprovalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageApprovals to delete
     */
    where?: MessageApprovalWhereInput
  }

  /**
   * MessageApproval without action
   */
  export type MessageApprovalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageApproval
     */
    select?: MessageApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageApprovalInclude<ExtArgs> | null
  }


  /**
   * Model MessageCategory
   */

  export type AggregateMessageCategory = {
    _count: MessageCategoryCountAggregateOutputType | null
    _min: MessageCategoryMinAggregateOutputType | null
    _max: MessageCategoryMaxAggregateOutputType | null
  }

  export type MessageCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    scope: $Enums.CategoryScope | null
    channelId: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type MessageCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    scope: $Enums.CategoryScope | null
    channelId: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type MessageCategoryCountAggregateOutputType = {
    id: number
    name: number
    scope: number
    channelId: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type MessageCategoryMinAggregateInputType = {
    id?: true
    name?: true
    scope?: true
    channelId?: true
    createdBy?: true
    createdAt?: true
  }

  export type MessageCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    scope?: true
    channelId?: true
    createdBy?: true
    createdAt?: true
  }

  export type MessageCategoryCountAggregateInputType = {
    id?: true
    name?: true
    scope?: true
    channelId?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type MessageCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageCategory to aggregate.
     */
    where?: MessageCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageCategories to fetch.
     */
    orderBy?: MessageCategoryOrderByWithRelationInput | MessageCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageCategories
    **/
    _count?: true | MessageCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageCategoryMaxAggregateInputType
  }

  export type GetMessageCategoryAggregateType<T extends MessageCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageCategory[P]>
      : GetScalarType<T[P], AggregateMessageCategory[P]>
  }




  export type MessageCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageCategoryWhereInput
    orderBy?: MessageCategoryOrderByWithAggregationInput | MessageCategoryOrderByWithAggregationInput[]
    by: MessageCategoryScalarFieldEnum[] | MessageCategoryScalarFieldEnum
    having?: MessageCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCategoryCountAggregateInputType | true
    _min?: MessageCategoryMinAggregateInputType
    _max?: MessageCategoryMaxAggregateInputType
  }

  export type MessageCategoryGroupByOutputType = {
    id: string
    name: string
    scope: $Enums.CategoryScope
    channelId: string | null
    createdBy: string | null
    createdAt: Date
    _count: MessageCategoryCountAggregateOutputType | null
    _min: MessageCategoryMinAggregateOutputType | null
    _max: MessageCategoryMaxAggregateOutputType | null
  }

  type GetMessageCategoryGroupByPayload<T extends MessageCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], MessageCategoryGroupByOutputType[P]>
        }
      >
    >


  export type MessageCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    scope?: boolean
    channelId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    channel?: boolean | MessageCategory$channelArgs<ExtArgs>
    creator?: boolean | MessageCategory$creatorArgs<ExtArgs>
    messages?: boolean | MessageCategory$messagesArgs<ExtArgs>
    _count?: boolean | MessageCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageCategory"]>


  export type MessageCategorySelectScalar = {
    id?: boolean
    name?: boolean
    scope?: boolean
    channelId?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }

  export type MessageCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    channel?: boolean | MessageCategory$channelArgs<ExtArgs>
    creator?: boolean | MessageCategory$creatorArgs<ExtArgs>
    messages?: boolean | MessageCategory$messagesArgs<ExtArgs>
    _count?: boolean | MessageCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MessageCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageCategory"
    objects: {
      channel: Prisma.$ChannelPayload<ExtArgs> | null
      creator: Prisma.$UserPayload<ExtArgs> | null
      messages: Prisma.$MessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      scope: $Enums.CategoryScope
      channelId: string | null
      createdBy: string | null
      createdAt: Date
    }, ExtArgs["result"]["messageCategory"]>
    composites: {}
  }

  type MessageCategoryGetPayload<S extends boolean | null | undefined | MessageCategoryDefaultArgs> = $Result.GetResult<Prisma.$MessageCategoryPayload, S>

  type MessageCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageCategoryCountAggregateInputType | true
    }

  export interface MessageCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageCategory'], meta: { name: 'MessageCategory' } }
    /**
     * Find zero or one MessageCategory that matches the filter.
     * @param {MessageCategoryFindUniqueArgs} args - Arguments to find a MessageCategory
     * @example
     * // Get one MessageCategory
     * const messageCategory = await prisma.messageCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageCategoryFindUniqueArgs>(args: SelectSubset<T, MessageCategoryFindUniqueArgs<ExtArgs>>): Prisma__MessageCategoryClient<$Result.GetResult<Prisma.$MessageCategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MessageCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageCategoryFindUniqueOrThrowArgs} args - Arguments to find a MessageCategory
     * @example
     * // Get one MessageCategory
     * const messageCategory = await prisma.messageCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageCategoryClient<$Result.GetResult<Prisma.$MessageCategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MessageCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCategoryFindFirstArgs} args - Arguments to find a MessageCategory
     * @example
     * // Get one MessageCategory
     * const messageCategory = await prisma.messageCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageCategoryFindFirstArgs>(args?: SelectSubset<T, MessageCategoryFindFirstArgs<ExtArgs>>): Prisma__MessageCategoryClient<$Result.GetResult<Prisma.$MessageCategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MessageCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCategoryFindFirstOrThrowArgs} args - Arguments to find a MessageCategory
     * @example
     * // Get one MessageCategory
     * const messageCategory = await prisma.messageCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageCategoryClient<$Result.GetResult<Prisma.$MessageCategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MessageCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageCategories
     * const messageCategories = await prisma.messageCategory.findMany()
     * 
     * // Get first 10 MessageCategories
     * const messageCategories = await prisma.messageCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageCategoryWithIdOnly = await prisma.messageCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageCategoryFindManyArgs>(args?: SelectSubset<T, MessageCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageCategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MessageCategory.
     * @param {MessageCategoryCreateArgs} args - Arguments to create a MessageCategory.
     * @example
     * // Create one MessageCategory
     * const MessageCategory = await prisma.messageCategory.create({
     *   data: {
     *     // ... data to create a MessageCategory
     *   }
     * })
     * 
     */
    create<T extends MessageCategoryCreateArgs>(args: SelectSubset<T, MessageCategoryCreateArgs<ExtArgs>>): Prisma__MessageCategoryClient<$Result.GetResult<Prisma.$MessageCategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MessageCategories.
     * @param {MessageCategoryCreateManyArgs} args - Arguments to create many MessageCategories.
     * @example
     * // Create many MessageCategories
     * const messageCategory = await prisma.messageCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCategoryCreateManyArgs>(args?: SelectSubset<T, MessageCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MessageCategory.
     * @param {MessageCategoryDeleteArgs} args - Arguments to delete one MessageCategory.
     * @example
     * // Delete one MessageCategory
     * const MessageCategory = await prisma.messageCategory.delete({
     *   where: {
     *     // ... filter to delete one MessageCategory
     *   }
     * })
     * 
     */
    delete<T extends MessageCategoryDeleteArgs>(args: SelectSubset<T, MessageCategoryDeleteArgs<ExtArgs>>): Prisma__MessageCategoryClient<$Result.GetResult<Prisma.$MessageCategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MessageCategory.
     * @param {MessageCategoryUpdateArgs} args - Arguments to update one MessageCategory.
     * @example
     * // Update one MessageCategory
     * const messageCategory = await prisma.messageCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageCategoryUpdateArgs>(args: SelectSubset<T, MessageCategoryUpdateArgs<ExtArgs>>): Prisma__MessageCategoryClient<$Result.GetResult<Prisma.$MessageCategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MessageCategories.
     * @param {MessageCategoryDeleteManyArgs} args - Arguments to filter MessageCategories to delete.
     * @example
     * // Delete a few MessageCategories
     * const { count } = await prisma.messageCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageCategoryDeleteManyArgs>(args?: SelectSubset<T, MessageCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageCategories
     * const messageCategory = await prisma.messageCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageCategoryUpdateManyArgs>(args: SelectSubset<T, MessageCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MessageCategory.
     * @param {MessageCategoryUpsertArgs} args - Arguments to update or create a MessageCategory.
     * @example
     * // Update or create a MessageCategory
     * const messageCategory = await prisma.messageCategory.upsert({
     *   create: {
     *     // ... data to create a MessageCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageCategory we want to update
     *   }
     * })
     */
    upsert<T extends MessageCategoryUpsertArgs>(args: SelectSubset<T, MessageCategoryUpsertArgs<ExtArgs>>): Prisma__MessageCategoryClient<$Result.GetResult<Prisma.$MessageCategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MessageCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCategoryCountArgs} args - Arguments to filter MessageCategories to count.
     * @example
     * // Count the number of MessageCategories
     * const count = await prisma.messageCategory.count({
     *   where: {
     *     // ... the filter for the MessageCategories we want to count
     *   }
     * })
    **/
    count<T extends MessageCategoryCountArgs>(
      args?: Subset<T, MessageCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageCategoryAggregateArgs>(args: Subset<T, MessageCategoryAggregateArgs>): Prisma.PrismaPromise<GetMessageCategoryAggregateType<T>>

    /**
     * Group by MessageCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageCategoryGroupByArgs['orderBy'] }
        : { orderBy?: MessageCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageCategory model
   */
  readonly fields: MessageCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    channel<T extends MessageCategory$channelArgs<ExtArgs> = {}>(args?: Subset<T, MessageCategory$channelArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    creator<T extends MessageCategory$creatorArgs<ExtArgs> = {}>(args?: Subset<T, MessageCategory$creatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    messages<T extends MessageCategory$messagesArgs<ExtArgs> = {}>(args?: Subset<T, MessageCategory$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessageCategory model
   */ 
  interface MessageCategoryFieldRefs {
    readonly id: FieldRef<"MessageCategory", 'String'>
    readonly name: FieldRef<"MessageCategory", 'String'>
    readonly scope: FieldRef<"MessageCategory", 'CategoryScope'>
    readonly channelId: FieldRef<"MessageCategory", 'String'>
    readonly createdBy: FieldRef<"MessageCategory", 'String'>
    readonly createdAt: FieldRef<"MessageCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MessageCategory findUnique
   */
  export type MessageCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCategory
     */
    select?: MessageCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageCategoryInclude<ExtArgs> | null
    /**
     * Filter, which MessageCategory to fetch.
     */
    where: MessageCategoryWhereUniqueInput
  }

  /**
   * MessageCategory findUniqueOrThrow
   */
  export type MessageCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCategory
     */
    select?: MessageCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageCategoryInclude<ExtArgs> | null
    /**
     * Filter, which MessageCategory to fetch.
     */
    where: MessageCategoryWhereUniqueInput
  }

  /**
   * MessageCategory findFirst
   */
  export type MessageCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCategory
     */
    select?: MessageCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageCategoryInclude<ExtArgs> | null
    /**
     * Filter, which MessageCategory to fetch.
     */
    where?: MessageCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageCategories to fetch.
     */
    orderBy?: MessageCategoryOrderByWithRelationInput | MessageCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageCategories.
     */
    cursor?: MessageCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageCategories.
     */
    distinct?: MessageCategoryScalarFieldEnum | MessageCategoryScalarFieldEnum[]
  }

  /**
   * MessageCategory findFirstOrThrow
   */
  export type MessageCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCategory
     */
    select?: MessageCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageCategoryInclude<ExtArgs> | null
    /**
     * Filter, which MessageCategory to fetch.
     */
    where?: MessageCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageCategories to fetch.
     */
    orderBy?: MessageCategoryOrderByWithRelationInput | MessageCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageCategories.
     */
    cursor?: MessageCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageCategories.
     */
    distinct?: MessageCategoryScalarFieldEnum | MessageCategoryScalarFieldEnum[]
  }

  /**
   * MessageCategory findMany
   */
  export type MessageCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCategory
     */
    select?: MessageCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageCategoryInclude<ExtArgs> | null
    /**
     * Filter, which MessageCategories to fetch.
     */
    where?: MessageCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageCategories to fetch.
     */
    orderBy?: MessageCategoryOrderByWithRelationInput | MessageCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageCategories.
     */
    cursor?: MessageCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageCategories.
     */
    skip?: number
    distinct?: MessageCategoryScalarFieldEnum | MessageCategoryScalarFieldEnum[]
  }

  /**
   * MessageCategory create
   */
  export type MessageCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCategory
     */
    select?: MessageCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageCategory.
     */
    data: XOR<MessageCategoryCreateInput, MessageCategoryUncheckedCreateInput>
  }

  /**
   * MessageCategory createMany
   */
  export type MessageCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageCategories.
     */
    data: MessageCategoryCreateManyInput | MessageCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageCategory update
   */
  export type MessageCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCategory
     */
    select?: MessageCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageCategory.
     */
    data: XOR<MessageCategoryUpdateInput, MessageCategoryUncheckedUpdateInput>
    /**
     * Choose, which MessageCategory to update.
     */
    where: MessageCategoryWhereUniqueInput
  }

  /**
   * MessageCategory updateMany
   */
  export type MessageCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageCategories.
     */
    data: XOR<MessageCategoryUpdateManyMutationInput, MessageCategoryUncheckedUpdateManyInput>
    /**
     * Filter which MessageCategories to update
     */
    where?: MessageCategoryWhereInput
  }

  /**
   * MessageCategory upsert
   */
  export type MessageCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCategory
     */
    select?: MessageCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageCategory to update in case it exists.
     */
    where: MessageCategoryWhereUniqueInput
    /**
     * In case the MessageCategory found by the `where` argument doesn't exist, create a new MessageCategory with this data.
     */
    create: XOR<MessageCategoryCreateInput, MessageCategoryUncheckedCreateInput>
    /**
     * In case the MessageCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageCategoryUpdateInput, MessageCategoryUncheckedUpdateInput>
  }

  /**
   * MessageCategory delete
   */
  export type MessageCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCategory
     */
    select?: MessageCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageCategoryInclude<ExtArgs> | null
    /**
     * Filter which MessageCategory to delete.
     */
    where: MessageCategoryWhereUniqueInput
  }

  /**
   * MessageCategory deleteMany
   */
  export type MessageCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageCategories to delete
     */
    where?: MessageCategoryWhereInput
  }

  /**
   * MessageCategory.channel
   */
  export type MessageCategory$channelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    where?: ChannelWhereInput
  }

  /**
   * MessageCategory.creator
   */
  export type MessageCategory$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * MessageCategory.messages
   */
  export type MessageCategory$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * MessageCategory without action
   */
  export type MessageCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCategory
     */
    select?: MessageCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageCategoryInclude<ExtArgs> | null
  }


  /**
   * Model MessageAttachment
   */

  export type AggregateMessageAttachment = {
    _count: MessageAttachmentCountAggregateOutputType | null
    _min: MessageAttachmentMinAggregateOutputType | null
    _max: MessageAttachmentMaxAggregateOutputType | null
  }

  export type MessageAttachmentMinAggregateOutputType = {
    id: string | null
    messageId: string | null
    type: $Enums.AttachmentType | null
    url: string | null
    createdAt: Date | null
  }

  export type MessageAttachmentMaxAggregateOutputType = {
    id: string | null
    messageId: string | null
    type: $Enums.AttachmentType | null
    url: string | null
    createdAt: Date | null
  }

  export type MessageAttachmentCountAggregateOutputType = {
    id: number
    messageId: number
    type: number
    url: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type MessageAttachmentMinAggregateInputType = {
    id?: true
    messageId?: true
    type?: true
    url?: true
    createdAt?: true
  }

  export type MessageAttachmentMaxAggregateInputType = {
    id?: true
    messageId?: true
    type?: true
    url?: true
    createdAt?: true
  }

  export type MessageAttachmentCountAggregateInputType = {
    id?: true
    messageId?: true
    type?: true
    url?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type MessageAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageAttachment to aggregate.
     */
    where?: MessageAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageAttachments to fetch.
     */
    orderBy?: MessageAttachmentOrderByWithRelationInput | MessageAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageAttachments
    **/
    _count?: true | MessageAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageAttachmentMaxAggregateInputType
  }

  export type GetMessageAttachmentAggregateType<T extends MessageAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageAttachment[P]>
      : GetScalarType<T[P], AggregateMessageAttachment[P]>
  }




  export type MessageAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageAttachmentWhereInput
    orderBy?: MessageAttachmentOrderByWithAggregationInput | MessageAttachmentOrderByWithAggregationInput[]
    by: MessageAttachmentScalarFieldEnum[] | MessageAttachmentScalarFieldEnum
    having?: MessageAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageAttachmentCountAggregateInputType | true
    _min?: MessageAttachmentMinAggregateInputType
    _max?: MessageAttachmentMaxAggregateInputType
  }

  export type MessageAttachmentGroupByOutputType = {
    id: string
    messageId: string
    type: $Enums.AttachmentType
    url: string
    metadata: JsonValue | null
    createdAt: Date
    _count: MessageAttachmentCountAggregateOutputType | null
    _min: MessageAttachmentMinAggregateOutputType | null
    _max: MessageAttachmentMaxAggregateOutputType | null
  }

  type GetMessageAttachmentGroupByPayload<T extends MessageAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], MessageAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type MessageAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    type?: boolean
    url?: boolean
    metadata?: boolean
    createdAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageAttachment"]>


  export type MessageAttachmentSelectScalar = {
    id?: boolean
    messageId?: boolean
    type?: boolean
    url?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type MessageAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }

  export type $MessageAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageAttachment"
    objects: {
      message: Prisma.$MessagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      messageId: string
      type: $Enums.AttachmentType
      url: string
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["messageAttachment"]>
    composites: {}
  }

  type MessageAttachmentGetPayload<S extends boolean | null | undefined | MessageAttachmentDefaultArgs> = $Result.GetResult<Prisma.$MessageAttachmentPayload, S>

  type MessageAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageAttachmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageAttachmentCountAggregateInputType | true
    }

  export interface MessageAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageAttachment'], meta: { name: 'MessageAttachment' } }
    /**
     * Find zero or one MessageAttachment that matches the filter.
     * @param {MessageAttachmentFindUniqueArgs} args - Arguments to find a MessageAttachment
     * @example
     * // Get one MessageAttachment
     * const messageAttachment = await prisma.messageAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageAttachmentFindUniqueArgs>(args: SelectSubset<T, MessageAttachmentFindUniqueArgs<ExtArgs>>): Prisma__MessageAttachmentClient<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MessageAttachment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageAttachmentFindUniqueOrThrowArgs} args - Arguments to find a MessageAttachment
     * @example
     * // Get one MessageAttachment
     * const messageAttachment = await prisma.messageAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageAttachmentClient<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MessageAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentFindFirstArgs} args - Arguments to find a MessageAttachment
     * @example
     * // Get one MessageAttachment
     * const messageAttachment = await prisma.messageAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageAttachmentFindFirstArgs>(args?: SelectSubset<T, MessageAttachmentFindFirstArgs<ExtArgs>>): Prisma__MessageAttachmentClient<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MessageAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentFindFirstOrThrowArgs} args - Arguments to find a MessageAttachment
     * @example
     * // Get one MessageAttachment
     * const messageAttachment = await prisma.messageAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageAttachmentClient<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MessageAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageAttachments
     * const messageAttachments = await prisma.messageAttachment.findMany()
     * 
     * // Get first 10 MessageAttachments
     * const messageAttachments = await prisma.messageAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageAttachmentWithIdOnly = await prisma.messageAttachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageAttachmentFindManyArgs>(args?: SelectSubset<T, MessageAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MessageAttachment.
     * @param {MessageAttachmentCreateArgs} args - Arguments to create a MessageAttachment.
     * @example
     * // Create one MessageAttachment
     * const MessageAttachment = await prisma.messageAttachment.create({
     *   data: {
     *     // ... data to create a MessageAttachment
     *   }
     * })
     * 
     */
    create<T extends MessageAttachmentCreateArgs>(args: SelectSubset<T, MessageAttachmentCreateArgs<ExtArgs>>): Prisma__MessageAttachmentClient<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MessageAttachments.
     * @param {MessageAttachmentCreateManyArgs} args - Arguments to create many MessageAttachments.
     * @example
     * // Create many MessageAttachments
     * const messageAttachment = await prisma.messageAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageAttachmentCreateManyArgs>(args?: SelectSubset<T, MessageAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MessageAttachment.
     * @param {MessageAttachmentDeleteArgs} args - Arguments to delete one MessageAttachment.
     * @example
     * // Delete one MessageAttachment
     * const MessageAttachment = await prisma.messageAttachment.delete({
     *   where: {
     *     // ... filter to delete one MessageAttachment
     *   }
     * })
     * 
     */
    delete<T extends MessageAttachmentDeleteArgs>(args: SelectSubset<T, MessageAttachmentDeleteArgs<ExtArgs>>): Prisma__MessageAttachmentClient<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MessageAttachment.
     * @param {MessageAttachmentUpdateArgs} args - Arguments to update one MessageAttachment.
     * @example
     * // Update one MessageAttachment
     * const messageAttachment = await prisma.messageAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageAttachmentUpdateArgs>(args: SelectSubset<T, MessageAttachmentUpdateArgs<ExtArgs>>): Prisma__MessageAttachmentClient<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MessageAttachments.
     * @param {MessageAttachmentDeleteManyArgs} args - Arguments to filter MessageAttachments to delete.
     * @example
     * // Delete a few MessageAttachments
     * const { count } = await prisma.messageAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageAttachmentDeleteManyArgs>(args?: SelectSubset<T, MessageAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageAttachments
     * const messageAttachment = await prisma.messageAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageAttachmentUpdateManyArgs>(args: SelectSubset<T, MessageAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MessageAttachment.
     * @param {MessageAttachmentUpsertArgs} args - Arguments to update or create a MessageAttachment.
     * @example
     * // Update or create a MessageAttachment
     * const messageAttachment = await prisma.messageAttachment.upsert({
     *   create: {
     *     // ... data to create a MessageAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageAttachment we want to update
     *   }
     * })
     */
    upsert<T extends MessageAttachmentUpsertArgs>(args: SelectSubset<T, MessageAttachmentUpsertArgs<ExtArgs>>): Prisma__MessageAttachmentClient<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MessageAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentCountArgs} args - Arguments to filter MessageAttachments to count.
     * @example
     * // Count the number of MessageAttachments
     * const count = await prisma.messageAttachment.count({
     *   where: {
     *     // ... the filter for the MessageAttachments we want to count
     *   }
     * })
    **/
    count<T extends MessageAttachmentCountArgs>(
      args?: Subset<T, MessageAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAttachmentAggregateArgs>(args: Subset<T, MessageAttachmentAggregateArgs>): Prisma.PrismaPromise<GetMessageAttachmentAggregateType<T>>

    /**
     * Group by MessageAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: MessageAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageAttachment model
   */
  readonly fields: MessageAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message<T extends MessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessageDefaultArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessageAttachment model
   */ 
  interface MessageAttachmentFieldRefs {
    readonly id: FieldRef<"MessageAttachment", 'String'>
    readonly messageId: FieldRef<"MessageAttachment", 'String'>
    readonly type: FieldRef<"MessageAttachment", 'AttachmentType'>
    readonly url: FieldRef<"MessageAttachment", 'String'>
    readonly metadata: FieldRef<"MessageAttachment", 'Json'>
    readonly createdAt: FieldRef<"MessageAttachment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MessageAttachment findUnique
   */
  export type MessageAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MessageAttachment to fetch.
     */
    where: MessageAttachmentWhereUniqueInput
  }

  /**
   * MessageAttachment findUniqueOrThrow
   */
  export type MessageAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MessageAttachment to fetch.
     */
    where: MessageAttachmentWhereUniqueInput
  }

  /**
   * MessageAttachment findFirst
   */
  export type MessageAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MessageAttachment to fetch.
     */
    where?: MessageAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageAttachments to fetch.
     */
    orderBy?: MessageAttachmentOrderByWithRelationInput | MessageAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageAttachments.
     */
    cursor?: MessageAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageAttachments.
     */
    distinct?: MessageAttachmentScalarFieldEnum | MessageAttachmentScalarFieldEnum[]
  }

  /**
   * MessageAttachment findFirstOrThrow
   */
  export type MessageAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MessageAttachment to fetch.
     */
    where?: MessageAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageAttachments to fetch.
     */
    orderBy?: MessageAttachmentOrderByWithRelationInput | MessageAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageAttachments.
     */
    cursor?: MessageAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageAttachments.
     */
    distinct?: MessageAttachmentScalarFieldEnum | MessageAttachmentScalarFieldEnum[]
  }

  /**
   * MessageAttachment findMany
   */
  export type MessageAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MessageAttachments to fetch.
     */
    where?: MessageAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageAttachments to fetch.
     */
    orderBy?: MessageAttachmentOrderByWithRelationInput | MessageAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageAttachments.
     */
    cursor?: MessageAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageAttachments.
     */
    skip?: number
    distinct?: MessageAttachmentScalarFieldEnum | MessageAttachmentScalarFieldEnum[]
  }

  /**
   * MessageAttachment create
   */
  export type MessageAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageAttachment.
     */
    data: XOR<MessageAttachmentCreateInput, MessageAttachmentUncheckedCreateInput>
  }

  /**
   * MessageAttachment createMany
   */
  export type MessageAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageAttachments.
     */
    data: MessageAttachmentCreateManyInput | MessageAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageAttachment update
   */
  export type MessageAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageAttachment.
     */
    data: XOR<MessageAttachmentUpdateInput, MessageAttachmentUncheckedUpdateInput>
    /**
     * Choose, which MessageAttachment to update.
     */
    where: MessageAttachmentWhereUniqueInput
  }

  /**
   * MessageAttachment updateMany
   */
  export type MessageAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageAttachments.
     */
    data: XOR<MessageAttachmentUpdateManyMutationInput, MessageAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which MessageAttachments to update
     */
    where?: MessageAttachmentWhereInput
  }

  /**
   * MessageAttachment upsert
   */
  export type MessageAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageAttachment to update in case it exists.
     */
    where: MessageAttachmentWhereUniqueInput
    /**
     * In case the MessageAttachment found by the `where` argument doesn't exist, create a new MessageAttachment with this data.
     */
    create: XOR<MessageAttachmentCreateInput, MessageAttachmentUncheckedCreateInput>
    /**
     * In case the MessageAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageAttachmentUpdateInput, MessageAttachmentUncheckedUpdateInput>
  }

  /**
   * MessageAttachment delete
   */
  export type MessageAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * Filter which MessageAttachment to delete.
     */
    where: MessageAttachmentWhereUniqueInput
  }

  /**
   * MessageAttachment deleteMany
   */
  export type MessageAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageAttachments to delete
     */
    where?: MessageAttachmentWhereInput
  }

  /**
   * MessageAttachment without action
   */
  export type MessageAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
  }


  /**
   * Model MessageRevision
   */

  export type AggregateMessageRevision = {
    _count: MessageRevisionCountAggregateOutputType | null
    _min: MessageRevisionMinAggregateOutputType | null
    _max: MessageRevisionMaxAggregateOutputType | null
  }

  export type MessageRevisionMinAggregateOutputType = {
    id: string | null
    messageId: string | null
    editorId: string | null
    previousContent: string | null
    previousCategoryId: string | null
    previousPriority: $Enums.MessagePriority | null
    previousIsImmediate: boolean | null
    previousDeliveryMethod: $Enums.DeliveryMethod | null
    changedAt: Date | null
  }

  export type MessageRevisionMaxAggregateOutputType = {
    id: string | null
    messageId: string | null
    editorId: string | null
    previousContent: string | null
    previousCategoryId: string | null
    previousPriority: $Enums.MessagePriority | null
    previousIsImmediate: boolean | null
    previousDeliveryMethod: $Enums.DeliveryMethod | null
    changedAt: Date | null
  }

  export type MessageRevisionCountAggregateOutputType = {
    id: number
    messageId: number
    editorId: number
    previousContent: number
    previousCategoryId: number
    previousPriority: number
    previousIsImmediate: number
    previousDeliveryMethod: number
    changedAt: number
    _all: number
  }


  export type MessageRevisionMinAggregateInputType = {
    id?: true
    messageId?: true
    editorId?: true
    previousContent?: true
    previousCategoryId?: true
    previousPriority?: true
    previousIsImmediate?: true
    previousDeliveryMethod?: true
    changedAt?: true
  }

  export type MessageRevisionMaxAggregateInputType = {
    id?: true
    messageId?: true
    editorId?: true
    previousContent?: true
    previousCategoryId?: true
    previousPriority?: true
    previousIsImmediate?: true
    previousDeliveryMethod?: true
    changedAt?: true
  }

  export type MessageRevisionCountAggregateInputType = {
    id?: true
    messageId?: true
    editorId?: true
    previousContent?: true
    previousCategoryId?: true
    previousPriority?: true
    previousIsImmediate?: true
    previousDeliveryMethod?: true
    changedAt?: true
    _all?: true
  }

  export type MessageRevisionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageRevision to aggregate.
     */
    where?: MessageRevisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageRevisions to fetch.
     */
    orderBy?: MessageRevisionOrderByWithRelationInput | MessageRevisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageRevisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageRevisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageRevisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageRevisions
    **/
    _count?: true | MessageRevisionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageRevisionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageRevisionMaxAggregateInputType
  }

  export type GetMessageRevisionAggregateType<T extends MessageRevisionAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageRevision]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageRevision[P]>
      : GetScalarType<T[P], AggregateMessageRevision[P]>
  }




  export type MessageRevisionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageRevisionWhereInput
    orderBy?: MessageRevisionOrderByWithAggregationInput | MessageRevisionOrderByWithAggregationInput[]
    by: MessageRevisionScalarFieldEnum[] | MessageRevisionScalarFieldEnum
    having?: MessageRevisionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageRevisionCountAggregateInputType | true
    _min?: MessageRevisionMinAggregateInputType
    _max?: MessageRevisionMaxAggregateInputType
  }

  export type MessageRevisionGroupByOutputType = {
    id: string
    messageId: string
    editorId: string
    previousContent: string
    previousCategoryId: string | null
    previousPriority: $Enums.MessagePriority
    previousIsImmediate: boolean
    previousDeliveryMethod: $Enums.DeliveryMethod
    changedAt: Date
    _count: MessageRevisionCountAggregateOutputType | null
    _min: MessageRevisionMinAggregateOutputType | null
    _max: MessageRevisionMaxAggregateOutputType | null
  }

  type GetMessageRevisionGroupByPayload<T extends MessageRevisionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageRevisionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageRevisionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageRevisionGroupByOutputType[P]>
            : GetScalarType<T[P], MessageRevisionGroupByOutputType[P]>
        }
      >
    >


  export type MessageRevisionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    editorId?: boolean
    previousContent?: boolean
    previousCategoryId?: boolean
    previousPriority?: boolean
    previousIsImmediate?: boolean
    previousDeliveryMethod?: boolean
    changedAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
    editor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageRevision"]>


  export type MessageRevisionSelectScalar = {
    id?: boolean
    messageId?: boolean
    editorId?: boolean
    previousContent?: boolean
    previousCategoryId?: boolean
    previousPriority?: boolean
    previousIsImmediate?: boolean
    previousDeliveryMethod?: boolean
    changedAt?: boolean
  }

  export type MessageRevisionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
    editor?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MessageRevisionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageRevision"
    objects: {
      message: Prisma.$MessagePayload<ExtArgs>
      editor: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      messageId: string
      editorId: string
      previousContent: string
      previousCategoryId: string | null
      previousPriority: $Enums.MessagePriority
      previousIsImmediate: boolean
      previousDeliveryMethod: $Enums.DeliveryMethod
      changedAt: Date
    }, ExtArgs["result"]["messageRevision"]>
    composites: {}
  }

  type MessageRevisionGetPayload<S extends boolean | null | undefined | MessageRevisionDefaultArgs> = $Result.GetResult<Prisma.$MessageRevisionPayload, S>

  type MessageRevisionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageRevisionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageRevisionCountAggregateInputType | true
    }

  export interface MessageRevisionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageRevision'], meta: { name: 'MessageRevision' } }
    /**
     * Find zero or one MessageRevision that matches the filter.
     * @param {MessageRevisionFindUniqueArgs} args - Arguments to find a MessageRevision
     * @example
     * // Get one MessageRevision
     * const messageRevision = await prisma.messageRevision.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageRevisionFindUniqueArgs>(args: SelectSubset<T, MessageRevisionFindUniqueArgs<ExtArgs>>): Prisma__MessageRevisionClient<$Result.GetResult<Prisma.$MessageRevisionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MessageRevision that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageRevisionFindUniqueOrThrowArgs} args - Arguments to find a MessageRevision
     * @example
     * // Get one MessageRevision
     * const messageRevision = await prisma.messageRevision.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageRevisionFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageRevisionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageRevisionClient<$Result.GetResult<Prisma.$MessageRevisionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MessageRevision that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageRevisionFindFirstArgs} args - Arguments to find a MessageRevision
     * @example
     * // Get one MessageRevision
     * const messageRevision = await prisma.messageRevision.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageRevisionFindFirstArgs>(args?: SelectSubset<T, MessageRevisionFindFirstArgs<ExtArgs>>): Prisma__MessageRevisionClient<$Result.GetResult<Prisma.$MessageRevisionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MessageRevision that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageRevisionFindFirstOrThrowArgs} args - Arguments to find a MessageRevision
     * @example
     * // Get one MessageRevision
     * const messageRevision = await prisma.messageRevision.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageRevisionFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageRevisionFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageRevisionClient<$Result.GetResult<Prisma.$MessageRevisionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MessageRevisions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageRevisionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageRevisions
     * const messageRevisions = await prisma.messageRevision.findMany()
     * 
     * // Get first 10 MessageRevisions
     * const messageRevisions = await prisma.messageRevision.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageRevisionWithIdOnly = await prisma.messageRevision.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageRevisionFindManyArgs>(args?: SelectSubset<T, MessageRevisionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageRevisionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MessageRevision.
     * @param {MessageRevisionCreateArgs} args - Arguments to create a MessageRevision.
     * @example
     * // Create one MessageRevision
     * const MessageRevision = await prisma.messageRevision.create({
     *   data: {
     *     // ... data to create a MessageRevision
     *   }
     * })
     * 
     */
    create<T extends MessageRevisionCreateArgs>(args: SelectSubset<T, MessageRevisionCreateArgs<ExtArgs>>): Prisma__MessageRevisionClient<$Result.GetResult<Prisma.$MessageRevisionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MessageRevisions.
     * @param {MessageRevisionCreateManyArgs} args - Arguments to create many MessageRevisions.
     * @example
     * // Create many MessageRevisions
     * const messageRevision = await prisma.messageRevision.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageRevisionCreateManyArgs>(args?: SelectSubset<T, MessageRevisionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MessageRevision.
     * @param {MessageRevisionDeleteArgs} args - Arguments to delete one MessageRevision.
     * @example
     * // Delete one MessageRevision
     * const MessageRevision = await prisma.messageRevision.delete({
     *   where: {
     *     // ... filter to delete one MessageRevision
     *   }
     * })
     * 
     */
    delete<T extends MessageRevisionDeleteArgs>(args: SelectSubset<T, MessageRevisionDeleteArgs<ExtArgs>>): Prisma__MessageRevisionClient<$Result.GetResult<Prisma.$MessageRevisionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MessageRevision.
     * @param {MessageRevisionUpdateArgs} args - Arguments to update one MessageRevision.
     * @example
     * // Update one MessageRevision
     * const messageRevision = await prisma.messageRevision.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageRevisionUpdateArgs>(args: SelectSubset<T, MessageRevisionUpdateArgs<ExtArgs>>): Prisma__MessageRevisionClient<$Result.GetResult<Prisma.$MessageRevisionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MessageRevisions.
     * @param {MessageRevisionDeleteManyArgs} args - Arguments to filter MessageRevisions to delete.
     * @example
     * // Delete a few MessageRevisions
     * const { count } = await prisma.messageRevision.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageRevisionDeleteManyArgs>(args?: SelectSubset<T, MessageRevisionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageRevisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageRevisionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageRevisions
     * const messageRevision = await prisma.messageRevision.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageRevisionUpdateManyArgs>(args: SelectSubset<T, MessageRevisionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MessageRevision.
     * @param {MessageRevisionUpsertArgs} args - Arguments to update or create a MessageRevision.
     * @example
     * // Update or create a MessageRevision
     * const messageRevision = await prisma.messageRevision.upsert({
     *   create: {
     *     // ... data to create a MessageRevision
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageRevision we want to update
     *   }
     * })
     */
    upsert<T extends MessageRevisionUpsertArgs>(args: SelectSubset<T, MessageRevisionUpsertArgs<ExtArgs>>): Prisma__MessageRevisionClient<$Result.GetResult<Prisma.$MessageRevisionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MessageRevisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageRevisionCountArgs} args - Arguments to filter MessageRevisions to count.
     * @example
     * // Count the number of MessageRevisions
     * const count = await prisma.messageRevision.count({
     *   where: {
     *     // ... the filter for the MessageRevisions we want to count
     *   }
     * })
    **/
    count<T extends MessageRevisionCountArgs>(
      args?: Subset<T, MessageRevisionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageRevisionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageRevision.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageRevisionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageRevisionAggregateArgs>(args: Subset<T, MessageRevisionAggregateArgs>): Prisma.PrismaPromise<GetMessageRevisionAggregateType<T>>

    /**
     * Group by MessageRevision.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageRevisionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageRevisionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageRevisionGroupByArgs['orderBy'] }
        : { orderBy?: MessageRevisionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageRevisionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageRevisionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageRevision model
   */
  readonly fields: MessageRevisionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageRevision.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageRevisionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message<T extends MessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessageDefaultArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    editor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessageRevision model
   */ 
  interface MessageRevisionFieldRefs {
    readonly id: FieldRef<"MessageRevision", 'String'>
    readonly messageId: FieldRef<"MessageRevision", 'String'>
    readonly editorId: FieldRef<"MessageRevision", 'String'>
    readonly previousContent: FieldRef<"MessageRevision", 'String'>
    readonly previousCategoryId: FieldRef<"MessageRevision", 'String'>
    readonly previousPriority: FieldRef<"MessageRevision", 'MessagePriority'>
    readonly previousIsImmediate: FieldRef<"MessageRevision", 'Boolean'>
    readonly previousDeliveryMethod: FieldRef<"MessageRevision", 'DeliveryMethod'>
    readonly changedAt: FieldRef<"MessageRevision", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MessageRevision findUnique
   */
  export type MessageRevisionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRevision
     */
    select?: MessageRevisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageRevisionInclude<ExtArgs> | null
    /**
     * Filter, which MessageRevision to fetch.
     */
    where: MessageRevisionWhereUniqueInput
  }

  /**
   * MessageRevision findUniqueOrThrow
   */
  export type MessageRevisionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRevision
     */
    select?: MessageRevisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageRevisionInclude<ExtArgs> | null
    /**
     * Filter, which MessageRevision to fetch.
     */
    where: MessageRevisionWhereUniqueInput
  }

  /**
   * MessageRevision findFirst
   */
  export type MessageRevisionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRevision
     */
    select?: MessageRevisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageRevisionInclude<ExtArgs> | null
    /**
     * Filter, which MessageRevision to fetch.
     */
    where?: MessageRevisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageRevisions to fetch.
     */
    orderBy?: MessageRevisionOrderByWithRelationInput | MessageRevisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageRevisions.
     */
    cursor?: MessageRevisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageRevisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageRevisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageRevisions.
     */
    distinct?: MessageRevisionScalarFieldEnum | MessageRevisionScalarFieldEnum[]
  }

  /**
   * MessageRevision findFirstOrThrow
   */
  export type MessageRevisionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRevision
     */
    select?: MessageRevisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageRevisionInclude<ExtArgs> | null
    /**
     * Filter, which MessageRevision to fetch.
     */
    where?: MessageRevisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageRevisions to fetch.
     */
    orderBy?: MessageRevisionOrderByWithRelationInput | MessageRevisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageRevisions.
     */
    cursor?: MessageRevisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageRevisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageRevisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageRevisions.
     */
    distinct?: MessageRevisionScalarFieldEnum | MessageRevisionScalarFieldEnum[]
  }

  /**
   * MessageRevision findMany
   */
  export type MessageRevisionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRevision
     */
    select?: MessageRevisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageRevisionInclude<ExtArgs> | null
    /**
     * Filter, which MessageRevisions to fetch.
     */
    where?: MessageRevisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageRevisions to fetch.
     */
    orderBy?: MessageRevisionOrderByWithRelationInput | MessageRevisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageRevisions.
     */
    cursor?: MessageRevisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageRevisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageRevisions.
     */
    skip?: number
    distinct?: MessageRevisionScalarFieldEnum | MessageRevisionScalarFieldEnum[]
  }

  /**
   * MessageRevision create
   */
  export type MessageRevisionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRevision
     */
    select?: MessageRevisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageRevisionInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageRevision.
     */
    data: XOR<MessageRevisionCreateInput, MessageRevisionUncheckedCreateInput>
  }

  /**
   * MessageRevision createMany
   */
  export type MessageRevisionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageRevisions.
     */
    data: MessageRevisionCreateManyInput | MessageRevisionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageRevision update
   */
  export type MessageRevisionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRevision
     */
    select?: MessageRevisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageRevisionInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageRevision.
     */
    data: XOR<MessageRevisionUpdateInput, MessageRevisionUncheckedUpdateInput>
    /**
     * Choose, which MessageRevision to update.
     */
    where: MessageRevisionWhereUniqueInput
  }

  /**
   * MessageRevision updateMany
   */
  export type MessageRevisionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageRevisions.
     */
    data: XOR<MessageRevisionUpdateManyMutationInput, MessageRevisionUncheckedUpdateManyInput>
    /**
     * Filter which MessageRevisions to update
     */
    where?: MessageRevisionWhereInput
  }

  /**
   * MessageRevision upsert
   */
  export type MessageRevisionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRevision
     */
    select?: MessageRevisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageRevisionInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageRevision to update in case it exists.
     */
    where: MessageRevisionWhereUniqueInput
    /**
     * In case the MessageRevision found by the `where` argument doesn't exist, create a new MessageRevision with this data.
     */
    create: XOR<MessageRevisionCreateInput, MessageRevisionUncheckedCreateInput>
    /**
     * In case the MessageRevision was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageRevisionUpdateInput, MessageRevisionUncheckedUpdateInput>
  }

  /**
   * MessageRevision delete
   */
  export type MessageRevisionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRevision
     */
    select?: MessageRevisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageRevisionInclude<ExtArgs> | null
    /**
     * Filter which MessageRevision to delete.
     */
    where: MessageRevisionWhereUniqueInput
  }

  /**
   * MessageRevision deleteMany
   */
  export type MessageRevisionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageRevisions to delete
     */
    where?: MessageRevisionWhereInput
  }

  /**
   * MessageRevision without action
   */
  export type MessageRevisionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRevision
     */
    select?: MessageRevisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageRevisionInclude<ExtArgs> | null
  }


  /**
   * Model ChannelVerificationDocument
   */

  export type AggregateChannelVerificationDocument = {
    _count: ChannelVerificationDocumentCountAggregateOutputType | null
    _min: ChannelVerificationDocumentMinAggregateOutputType | null
    _max: ChannelVerificationDocumentMaxAggregateOutputType | null
  }

  export type ChannelVerificationDocumentMinAggregateOutputType = {
    id: string | null
    channelId: string | null
    title: string | null
    docUrl: string | null
    issuer: string | null
    issuedAt: Date | null
    createdAt: Date | null
  }

  export type ChannelVerificationDocumentMaxAggregateOutputType = {
    id: string | null
    channelId: string | null
    title: string | null
    docUrl: string | null
    issuer: string | null
    issuedAt: Date | null
    createdAt: Date | null
  }

  export type ChannelVerificationDocumentCountAggregateOutputType = {
    id: number
    channelId: number
    title: number
    docUrl: number
    issuer: number
    issuedAt: number
    createdAt: number
    _all: number
  }


  export type ChannelVerificationDocumentMinAggregateInputType = {
    id?: true
    channelId?: true
    title?: true
    docUrl?: true
    issuer?: true
    issuedAt?: true
    createdAt?: true
  }

  export type ChannelVerificationDocumentMaxAggregateInputType = {
    id?: true
    channelId?: true
    title?: true
    docUrl?: true
    issuer?: true
    issuedAt?: true
    createdAt?: true
  }

  export type ChannelVerificationDocumentCountAggregateInputType = {
    id?: true
    channelId?: true
    title?: true
    docUrl?: true
    issuer?: true
    issuedAt?: true
    createdAt?: true
    _all?: true
  }

  export type ChannelVerificationDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChannelVerificationDocument to aggregate.
     */
    where?: ChannelVerificationDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelVerificationDocuments to fetch.
     */
    orderBy?: ChannelVerificationDocumentOrderByWithRelationInput | ChannelVerificationDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChannelVerificationDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChannelVerificationDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelVerificationDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChannelVerificationDocuments
    **/
    _count?: true | ChannelVerificationDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChannelVerificationDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChannelVerificationDocumentMaxAggregateInputType
  }

  export type GetChannelVerificationDocumentAggregateType<T extends ChannelVerificationDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateChannelVerificationDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChannelVerificationDocument[P]>
      : GetScalarType<T[P], AggregateChannelVerificationDocument[P]>
  }




  export type ChannelVerificationDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelVerificationDocumentWhereInput
    orderBy?: ChannelVerificationDocumentOrderByWithAggregationInput | ChannelVerificationDocumentOrderByWithAggregationInput[]
    by: ChannelVerificationDocumentScalarFieldEnum[] | ChannelVerificationDocumentScalarFieldEnum
    having?: ChannelVerificationDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChannelVerificationDocumentCountAggregateInputType | true
    _min?: ChannelVerificationDocumentMinAggregateInputType
    _max?: ChannelVerificationDocumentMaxAggregateInputType
  }

  export type ChannelVerificationDocumentGroupByOutputType = {
    id: string
    channelId: string
    title: string
    docUrl: string
    issuer: string | null
    issuedAt: Date | null
    createdAt: Date
    _count: ChannelVerificationDocumentCountAggregateOutputType | null
    _min: ChannelVerificationDocumentMinAggregateOutputType | null
    _max: ChannelVerificationDocumentMaxAggregateOutputType | null
  }

  type GetChannelVerificationDocumentGroupByPayload<T extends ChannelVerificationDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChannelVerificationDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChannelVerificationDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChannelVerificationDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], ChannelVerificationDocumentGroupByOutputType[P]>
        }
      >
    >


  export type ChannelVerificationDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    channelId?: boolean
    title?: boolean
    docUrl?: boolean
    issuer?: boolean
    issuedAt?: boolean
    createdAt?: boolean
    channel?: boolean | ChannelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["channelVerificationDocument"]>


  export type ChannelVerificationDocumentSelectScalar = {
    id?: boolean
    channelId?: boolean
    title?: boolean
    docUrl?: boolean
    issuer?: boolean
    issuedAt?: boolean
    createdAt?: boolean
  }

  export type ChannelVerificationDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    channel?: boolean | ChannelDefaultArgs<ExtArgs>
  }

  export type $ChannelVerificationDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChannelVerificationDocument"
    objects: {
      channel: Prisma.$ChannelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      channelId: string
      title: string
      docUrl: string
      issuer: string | null
      issuedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["channelVerificationDocument"]>
    composites: {}
  }

  type ChannelVerificationDocumentGetPayload<S extends boolean | null | undefined | ChannelVerificationDocumentDefaultArgs> = $Result.GetResult<Prisma.$ChannelVerificationDocumentPayload, S>

  type ChannelVerificationDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChannelVerificationDocumentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChannelVerificationDocumentCountAggregateInputType | true
    }

  export interface ChannelVerificationDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChannelVerificationDocument'], meta: { name: 'ChannelVerificationDocument' } }
    /**
     * Find zero or one ChannelVerificationDocument that matches the filter.
     * @param {ChannelVerificationDocumentFindUniqueArgs} args - Arguments to find a ChannelVerificationDocument
     * @example
     * // Get one ChannelVerificationDocument
     * const channelVerificationDocument = await prisma.channelVerificationDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChannelVerificationDocumentFindUniqueArgs>(args: SelectSubset<T, ChannelVerificationDocumentFindUniqueArgs<ExtArgs>>): Prisma__ChannelVerificationDocumentClient<$Result.GetResult<Prisma.$ChannelVerificationDocumentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ChannelVerificationDocument that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChannelVerificationDocumentFindUniqueOrThrowArgs} args - Arguments to find a ChannelVerificationDocument
     * @example
     * // Get one ChannelVerificationDocument
     * const channelVerificationDocument = await prisma.channelVerificationDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChannelVerificationDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, ChannelVerificationDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChannelVerificationDocumentClient<$Result.GetResult<Prisma.$ChannelVerificationDocumentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ChannelVerificationDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelVerificationDocumentFindFirstArgs} args - Arguments to find a ChannelVerificationDocument
     * @example
     * // Get one ChannelVerificationDocument
     * const channelVerificationDocument = await prisma.channelVerificationDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChannelVerificationDocumentFindFirstArgs>(args?: SelectSubset<T, ChannelVerificationDocumentFindFirstArgs<ExtArgs>>): Prisma__ChannelVerificationDocumentClient<$Result.GetResult<Prisma.$ChannelVerificationDocumentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ChannelVerificationDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelVerificationDocumentFindFirstOrThrowArgs} args - Arguments to find a ChannelVerificationDocument
     * @example
     * // Get one ChannelVerificationDocument
     * const channelVerificationDocument = await prisma.channelVerificationDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChannelVerificationDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, ChannelVerificationDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChannelVerificationDocumentClient<$Result.GetResult<Prisma.$ChannelVerificationDocumentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ChannelVerificationDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelVerificationDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChannelVerificationDocuments
     * const channelVerificationDocuments = await prisma.channelVerificationDocument.findMany()
     * 
     * // Get first 10 ChannelVerificationDocuments
     * const channelVerificationDocuments = await prisma.channelVerificationDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const channelVerificationDocumentWithIdOnly = await prisma.channelVerificationDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChannelVerificationDocumentFindManyArgs>(args?: SelectSubset<T, ChannelVerificationDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelVerificationDocumentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ChannelVerificationDocument.
     * @param {ChannelVerificationDocumentCreateArgs} args - Arguments to create a ChannelVerificationDocument.
     * @example
     * // Create one ChannelVerificationDocument
     * const ChannelVerificationDocument = await prisma.channelVerificationDocument.create({
     *   data: {
     *     // ... data to create a ChannelVerificationDocument
     *   }
     * })
     * 
     */
    create<T extends ChannelVerificationDocumentCreateArgs>(args: SelectSubset<T, ChannelVerificationDocumentCreateArgs<ExtArgs>>): Prisma__ChannelVerificationDocumentClient<$Result.GetResult<Prisma.$ChannelVerificationDocumentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ChannelVerificationDocuments.
     * @param {ChannelVerificationDocumentCreateManyArgs} args - Arguments to create many ChannelVerificationDocuments.
     * @example
     * // Create many ChannelVerificationDocuments
     * const channelVerificationDocument = await prisma.channelVerificationDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChannelVerificationDocumentCreateManyArgs>(args?: SelectSubset<T, ChannelVerificationDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ChannelVerificationDocument.
     * @param {ChannelVerificationDocumentDeleteArgs} args - Arguments to delete one ChannelVerificationDocument.
     * @example
     * // Delete one ChannelVerificationDocument
     * const ChannelVerificationDocument = await prisma.channelVerificationDocument.delete({
     *   where: {
     *     // ... filter to delete one ChannelVerificationDocument
     *   }
     * })
     * 
     */
    delete<T extends ChannelVerificationDocumentDeleteArgs>(args: SelectSubset<T, ChannelVerificationDocumentDeleteArgs<ExtArgs>>): Prisma__ChannelVerificationDocumentClient<$Result.GetResult<Prisma.$ChannelVerificationDocumentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ChannelVerificationDocument.
     * @param {ChannelVerificationDocumentUpdateArgs} args - Arguments to update one ChannelVerificationDocument.
     * @example
     * // Update one ChannelVerificationDocument
     * const channelVerificationDocument = await prisma.channelVerificationDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChannelVerificationDocumentUpdateArgs>(args: SelectSubset<T, ChannelVerificationDocumentUpdateArgs<ExtArgs>>): Prisma__ChannelVerificationDocumentClient<$Result.GetResult<Prisma.$ChannelVerificationDocumentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ChannelVerificationDocuments.
     * @param {ChannelVerificationDocumentDeleteManyArgs} args - Arguments to filter ChannelVerificationDocuments to delete.
     * @example
     * // Delete a few ChannelVerificationDocuments
     * const { count } = await prisma.channelVerificationDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChannelVerificationDocumentDeleteManyArgs>(args?: SelectSubset<T, ChannelVerificationDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChannelVerificationDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelVerificationDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChannelVerificationDocuments
     * const channelVerificationDocument = await prisma.channelVerificationDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChannelVerificationDocumentUpdateManyArgs>(args: SelectSubset<T, ChannelVerificationDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChannelVerificationDocument.
     * @param {ChannelVerificationDocumentUpsertArgs} args - Arguments to update or create a ChannelVerificationDocument.
     * @example
     * // Update or create a ChannelVerificationDocument
     * const channelVerificationDocument = await prisma.channelVerificationDocument.upsert({
     *   create: {
     *     // ... data to create a ChannelVerificationDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChannelVerificationDocument we want to update
     *   }
     * })
     */
    upsert<T extends ChannelVerificationDocumentUpsertArgs>(args: SelectSubset<T, ChannelVerificationDocumentUpsertArgs<ExtArgs>>): Prisma__ChannelVerificationDocumentClient<$Result.GetResult<Prisma.$ChannelVerificationDocumentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ChannelVerificationDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelVerificationDocumentCountArgs} args - Arguments to filter ChannelVerificationDocuments to count.
     * @example
     * // Count the number of ChannelVerificationDocuments
     * const count = await prisma.channelVerificationDocument.count({
     *   where: {
     *     // ... the filter for the ChannelVerificationDocuments we want to count
     *   }
     * })
    **/
    count<T extends ChannelVerificationDocumentCountArgs>(
      args?: Subset<T, ChannelVerificationDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChannelVerificationDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChannelVerificationDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelVerificationDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChannelVerificationDocumentAggregateArgs>(args: Subset<T, ChannelVerificationDocumentAggregateArgs>): Prisma.PrismaPromise<GetChannelVerificationDocumentAggregateType<T>>

    /**
     * Group by ChannelVerificationDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelVerificationDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChannelVerificationDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChannelVerificationDocumentGroupByArgs['orderBy'] }
        : { orderBy?: ChannelVerificationDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChannelVerificationDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChannelVerificationDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChannelVerificationDocument model
   */
  readonly fields: ChannelVerificationDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChannelVerificationDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChannelVerificationDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    channel<T extends ChannelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChannelDefaultArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChannelVerificationDocument model
   */ 
  interface ChannelVerificationDocumentFieldRefs {
    readonly id: FieldRef<"ChannelVerificationDocument", 'String'>
    readonly channelId: FieldRef<"ChannelVerificationDocument", 'String'>
    readonly title: FieldRef<"ChannelVerificationDocument", 'String'>
    readonly docUrl: FieldRef<"ChannelVerificationDocument", 'String'>
    readonly issuer: FieldRef<"ChannelVerificationDocument", 'String'>
    readonly issuedAt: FieldRef<"ChannelVerificationDocument", 'DateTime'>
    readonly createdAt: FieldRef<"ChannelVerificationDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChannelVerificationDocument findUnique
   */
  export type ChannelVerificationDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelVerificationDocument
     */
    select?: ChannelVerificationDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelVerificationDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ChannelVerificationDocument to fetch.
     */
    where: ChannelVerificationDocumentWhereUniqueInput
  }

  /**
   * ChannelVerificationDocument findUniqueOrThrow
   */
  export type ChannelVerificationDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelVerificationDocument
     */
    select?: ChannelVerificationDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelVerificationDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ChannelVerificationDocument to fetch.
     */
    where: ChannelVerificationDocumentWhereUniqueInput
  }

  /**
   * ChannelVerificationDocument findFirst
   */
  export type ChannelVerificationDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelVerificationDocument
     */
    select?: ChannelVerificationDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelVerificationDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ChannelVerificationDocument to fetch.
     */
    where?: ChannelVerificationDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelVerificationDocuments to fetch.
     */
    orderBy?: ChannelVerificationDocumentOrderByWithRelationInput | ChannelVerificationDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChannelVerificationDocuments.
     */
    cursor?: ChannelVerificationDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChannelVerificationDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelVerificationDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChannelVerificationDocuments.
     */
    distinct?: ChannelVerificationDocumentScalarFieldEnum | ChannelVerificationDocumentScalarFieldEnum[]
  }

  /**
   * ChannelVerificationDocument findFirstOrThrow
   */
  export type ChannelVerificationDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelVerificationDocument
     */
    select?: ChannelVerificationDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelVerificationDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ChannelVerificationDocument to fetch.
     */
    where?: ChannelVerificationDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelVerificationDocuments to fetch.
     */
    orderBy?: ChannelVerificationDocumentOrderByWithRelationInput | ChannelVerificationDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChannelVerificationDocuments.
     */
    cursor?: ChannelVerificationDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChannelVerificationDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelVerificationDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChannelVerificationDocuments.
     */
    distinct?: ChannelVerificationDocumentScalarFieldEnum | ChannelVerificationDocumentScalarFieldEnum[]
  }

  /**
   * ChannelVerificationDocument findMany
   */
  export type ChannelVerificationDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelVerificationDocument
     */
    select?: ChannelVerificationDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelVerificationDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ChannelVerificationDocuments to fetch.
     */
    where?: ChannelVerificationDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelVerificationDocuments to fetch.
     */
    orderBy?: ChannelVerificationDocumentOrderByWithRelationInput | ChannelVerificationDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChannelVerificationDocuments.
     */
    cursor?: ChannelVerificationDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChannelVerificationDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelVerificationDocuments.
     */
    skip?: number
    distinct?: ChannelVerificationDocumentScalarFieldEnum | ChannelVerificationDocumentScalarFieldEnum[]
  }

  /**
   * ChannelVerificationDocument create
   */
  export type ChannelVerificationDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelVerificationDocument
     */
    select?: ChannelVerificationDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelVerificationDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a ChannelVerificationDocument.
     */
    data: XOR<ChannelVerificationDocumentCreateInput, ChannelVerificationDocumentUncheckedCreateInput>
  }

  /**
   * ChannelVerificationDocument createMany
   */
  export type ChannelVerificationDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChannelVerificationDocuments.
     */
    data: ChannelVerificationDocumentCreateManyInput | ChannelVerificationDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChannelVerificationDocument update
   */
  export type ChannelVerificationDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelVerificationDocument
     */
    select?: ChannelVerificationDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelVerificationDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a ChannelVerificationDocument.
     */
    data: XOR<ChannelVerificationDocumentUpdateInput, ChannelVerificationDocumentUncheckedUpdateInput>
    /**
     * Choose, which ChannelVerificationDocument to update.
     */
    where: ChannelVerificationDocumentWhereUniqueInput
  }

  /**
   * ChannelVerificationDocument updateMany
   */
  export type ChannelVerificationDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChannelVerificationDocuments.
     */
    data: XOR<ChannelVerificationDocumentUpdateManyMutationInput, ChannelVerificationDocumentUncheckedUpdateManyInput>
    /**
     * Filter which ChannelVerificationDocuments to update
     */
    where?: ChannelVerificationDocumentWhereInput
  }

  /**
   * ChannelVerificationDocument upsert
   */
  export type ChannelVerificationDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelVerificationDocument
     */
    select?: ChannelVerificationDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelVerificationDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the ChannelVerificationDocument to update in case it exists.
     */
    where: ChannelVerificationDocumentWhereUniqueInput
    /**
     * In case the ChannelVerificationDocument found by the `where` argument doesn't exist, create a new ChannelVerificationDocument with this data.
     */
    create: XOR<ChannelVerificationDocumentCreateInput, ChannelVerificationDocumentUncheckedCreateInput>
    /**
     * In case the ChannelVerificationDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChannelVerificationDocumentUpdateInput, ChannelVerificationDocumentUncheckedUpdateInput>
  }

  /**
   * ChannelVerificationDocument delete
   */
  export type ChannelVerificationDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelVerificationDocument
     */
    select?: ChannelVerificationDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelVerificationDocumentInclude<ExtArgs> | null
    /**
     * Filter which ChannelVerificationDocument to delete.
     */
    where: ChannelVerificationDocumentWhereUniqueInput
  }

  /**
   * ChannelVerificationDocument deleteMany
   */
  export type ChannelVerificationDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChannelVerificationDocuments to delete
     */
    where?: ChannelVerificationDocumentWhereInput
  }

  /**
   * ChannelVerificationDocument without action
   */
  export type ChannelVerificationDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelVerificationDocument
     */
    select?: ChannelVerificationDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelVerificationDocumentInclude<ExtArgs> | null
  }


  /**
   * Model UserProfile
   */

  export type AggregateUserProfile = {
    _count: UserProfileCountAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  export type UserProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    country: string | null
    department: string | null
    city: string | null
  }

  export type UserProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    country: string | null
    department: string | null
    city: string | null
  }

  export type UserProfileCountAggregateOutputType = {
    id: number
    userId: number
    country: number
    department: number
    city: number
    extra: number
    _all: number
  }


  export type UserProfileMinAggregateInputType = {
    id?: true
    userId?: true
    country?: true
    department?: true
    city?: true
  }

  export type UserProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    country?: true
    department?: true
    city?: true
  }

  export type UserProfileCountAggregateInputType = {
    id?: true
    userId?: true
    country?: true
    department?: true
    city?: true
    extra?: true
    _all?: true
  }

  export type UserProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProfile to aggregate.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserProfiles
    **/
    _count?: true | UserProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserProfileMaxAggregateInputType
  }

  export type GetUserProfileAggregateType<T extends UserProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateUserProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserProfile[P]>
      : GetScalarType<T[P], AggregateUserProfile[P]>
  }




  export type UserProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProfileWhereInput
    orderBy?: UserProfileOrderByWithAggregationInput | UserProfileOrderByWithAggregationInput[]
    by: UserProfileScalarFieldEnum[] | UserProfileScalarFieldEnum
    having?: UserProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserProfileCountAggregateInputType | true
    _min?: UserProfileMinAggregateInputType
    _max?: UserProfileMaxAggregateInputType
  }

  export type UserProfileGroupByOutputType = {
    id: string
    userId: string
    country: string | null
    department: string | null
    city: string | null
    extra: JsonValue | null
    _count: UserProfileCountAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  type GetUserProfileGroupByPayload<T extends UserProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
            : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
        }
      >
    >


  export type UserProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    country?: boolean
    department?: boolean
    city?: boolean
    extra?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProfile"]>


  export type UserProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    country?: boolean
    department?: boolean
    city?: boolean
    extra?: boolean
  }

  export type UserProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      country: string | null
      department: string | null
      city: string | null
      extra: Prisma.JsonValue | null
    }, ExtArgs["result"]["userProfile"]>
    composites: {}
  }

  type UserProfileGetPayload<S extends boolean | null | undefined | UserProfileDefaultArgs> = $Result.GetResult<Prisma.$UserProfilePayload, S>

  type UserProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserProfileCountAggregateInputType | true
    }

  export interface UserProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserProfile'], meta: { name: 'UserProfile' } }
    /**
     * Find zero or one UserProfile that matches the filter.
     * @param {UserProfileFindUniqueArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserProfileFindUniqueArgs>(args: SelectSubset<T, UserProfileFindUniqueArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserProfile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserProfileFindUniqueOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, UserProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserProfileFindFirstArgs>(args?: SelectSubset<T, UserProfileFindFirstArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, UserProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserProfiles
     * const userProfiles = await prisma.userProfile.findMany()
     * 
     * // Get first 10 UserProfiles
     * const userProfiles = await prisma.userProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserProfileFindManyArgs>(args?: SelectSubset<T, UserProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserProfile.
     * @param {UserProfileCreateArgs} args - Arguments to create a UserProfile.
     * @example
     * // Create one UserProfile
     * const UserProfile = await prisma.userProfile.create({
     *   data: {
     *     // ... data to create a UserProfile
     *   }
     * })
     * 
     */
    create<T extends UserProfileCreateArgs>(args: SelectSubset<T, UserProfileCreateArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserProfiles.
     * @param {UserProfileCreateManyArgs} args - Arguments to create many UserProfiles.
     * @example
     * // Create many UserProfiles
     * const userProfile = await prisma.userProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserProfileCreateManyArgs>(args?: SelectSubset<T, UserProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserProfile.
     * @param {UserProfileDeleteArgs} args - Arguments to delete one UserProfile.
     * @example
     * // Delete one UserProfile
     * const UserProfile = await prisma.userProfile.delete({
     *   where: {
     *     // ... filter to delete one UserProfile
     *   }
     * })
     * 
     */
    delete<T extends UserProfileDeleteArgs>(args: SelectSubset<T, UserProfileDeleteArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserProfile.
     * @param {UserProfileUpdateArgs} args - Arguments to update one UserProfile.
     * @example
     * // Update one UserProfile
     * const userProfile = await prisma.userProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserProfileUpdateArgs>(args: SelectSubset<T, UserProfileUpdateArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserProfiles.
     * @param {UserProfileDeleteManyArgs} args - Arguments to filter UserProfiles to delete.
     * @example
     * // Delete a few UserProfiles
     * const { count } = await prisma.userProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserProfileDeleteManyArgs>(args?: SelectSubset<T, UserProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserProfiles
     * const userProfile = await prisma.userProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserProfileUpdateManyArgs>(args: SelectSubset<T, UserProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserProfile.
     * @param {UserProfileUpsertArgs} args - Arguments to update or create a UserProfile.
     * @example
     * // Update or create a UserProfile
     * const userProfile = await prisma.userProfile.upsert({
     *   create: {
     *     // ... data to create a UserProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserProfile we want to update
     *   }
     * })
     */
    upsert<T extends UserProfileUpsertArgs>(args: SelectSubset<T, UserProfileUpsertArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileCountArgs} args - Arguments to filter UserProfiles to count.
     * @example
     * // Count the number of UserProfiles
     * const count = await prisma.userProfile.count({
     *   where: {
     *     // ... the filter for the UserProfiles we want to count
     *   }
     * })
    **/
    count<T extends UserProfileCountArgs>(
      args?: Subset<T, UserProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserProfileAggregateArgs>(args: Subset<T, UserProfileAggregateArgs>): Prisma.PrismaPromise<GetUserProfileAggregateType<T>>

    /**
     * Group by UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserProfileGroupByArgs['orderBy'] }
        : { orderBy?: UserProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserProfile model
   */
  readonly fields: UserProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserProfile model
   */ 
  interface UserProfileFieldRefs {
    readonly id: FieldRef<"UserProfile", 'String'>
    readonly userId: FieldRef<"UserProfile", 'String'>
    readonly country: FieldRef<"UserProfile", 'String'>
    readonly department: FieldRef<"UserProfile", 'String'>
    readonly city: FieldRef<"UserProfile", 'String'>
    readonly extra: FieldRef<"UserProfile", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * UserProfile findUnique
   */
  export type UserProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile findUniqueOrThrow
   */
  export type UserProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile findFirst
   */
  export type UserProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile findFirstOrThrow
   */
  export type UserProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile findMany
   */
  export type UserProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfiles to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile create
   */
  export type UserProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a UserProfile.
     */
    data: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
  }

  /**
   * UserProfile createMany
   */
  export type UserProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserProfiles.
     */
    data: UserProfileCreateManyInput | UserProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserProfile update
   */
  export type UserProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a UserProfile.
     */
    data: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
    /**
     * Choose, which UserProfile to update.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile updateMany
   */
  export type UserProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserProfiles.
     */
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyInput>
    /**
     * Filter which UserProfiles to update
     */
    where?: UserProfileWhereInput
  }

  /**
   * UserProfile upsert
   */
  export type UserProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the UserProfile to update in case it exists.
     */
    where: UserProfileWhereUniqueInput
    /**
     * In case the UserProfile found by the `where` argument doesn't exist, create a new UserProfile with this data.
     */
    create: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
    /**
     * In case the UserProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
  }

  /**
   * UserProfile delete
   */
  export type UserProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter which UserProfile to delete.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile deleteMany
   */
  export type UserProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProfiles to delete
     */
    where?: UserProfileWhereInput
  }

  /**
   * UserProfile without action
   */
  export type UserProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
  }


  /**
   * Model UserMessagingSetting
   */

  export type AggregateUserMessagingSetting = {
    _count: UserMessagingSettingCountAggregateOutputType | null
    _min: UserMessagingSettingMinAggregateOutputType | null
    _max: UserMessagingSettingMaxAggregateOutputType | null
  }

  export type UserMessagingSettingMinAggregateOutputType = {
    id: string | null
    userId: string | null
    platform: $Enums.MessagingPlatform | null
    handle: string | null
    isEnabled: boolean | null
    verified: boolean | null
    createdAt: Date | null
  }

  export type UserMessagingSettingMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    platform: $Enums.MessagingPlatform | null
    handle: string | null
    isEnabled: boolean | null
    verified: boolean | null
    createdAt: Date | null
  }

  export type UserMessagingSettingCountAggregateOutputType = {
    id: number
    userId: number
    platform: number
    handle: number
    isEnabled: number
    verified: number
    createdAt: number
    _all: number
  }


  export type UserMessagingSettingMinAggregateInputType = {
    id?: true
    userId?: true
    platform?: true
    handle?: true
    isEnabled?: true
    verified?: true
    createdAt?: true
  }

  export type UserMessagingSettingMaxAggregateInputType = {
    id?: true
    userId?: true
    platform?: true
    handle?: true
    isEnabled?: true
    verified?: true
    createdAt?: true
  }

  export type UserMessagingSettingCountAggregateInputType = {
    id?: true
    userId?: true
    platform?: true
    handle?: true
    isEnabled?: true
    verified?: true
    createdAt?: true
    _all?: true
  }

  export type UserMessagingSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserMessagingSetting to aggregate.
     */
    where?: UserMessagingSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserMessagingSettings to fetch.
     */
    orderBy?: UserMessagingSettingOrderByWithRelationInput | UserMessagingSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserMessagingSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserMessagingSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserMessagingSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserMessagingSettings
    **/
    _count?: true | UserMessagingSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMessagingSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMessagingSettingMaxAggregateInputType
  }

  export type GetUserMessagingSettingAggregateType<T extends UserMessagingSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateUserMessagingSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserMessagingSetting[P]>
      : GetScalarType<T[P], AggregateUserMessagingSetting[P]>
  }




  export type UserMessagingSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserMessagingSettingWhereInput
    orderBy?: UserMessagingSettingOrderByWithAggregationInput | UserMessagingSettingOrderByWithAggregationInput[]
    by: UserMessagingSettingScalarFieldEnum[] | UserMessagingSettingScalarFieldEnum
    having?: UserMessagingSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserMessagingSettingCountAggregateInputType | true
    _min?: UserMessagingSettingMinAggregateInputType
    _max?: UserMessagingSettingMaxAggregateInputType
  }

  export type UserMessagingSettingGroupByOutputType = {
    id: string
    userId: string
    platform: $Enums.MessagingPlatform
    handle: string | null
    isEnabled: boolean
    verified: boolean
    createdAt: Date
    _count: UserMessagingSettingCountAggregateOutputType | null
    _min: UserMessagingSettingMinAggregateOutputType | null
    _max: UserMessagingSettingMaxAggregateOutputType | null
  }

  type GetUserMessagingSettingGroupByPayload<T extends UserMessagingSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserMessagingSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserMessagingSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserMessagingSettingGroupByOutputType[P]>
            : GetScalarType<T[P], UserMessagingSettingGroupByOutputType[P]>
        }
      >
    >


  export type UserMessagingSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    platform?: boolean
    handle?: boolean
    isEnabled?: boolean
    verified?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userMessagingSetting"]>


  export type UserMessagingSettingSelectScalar = {
    id?: boolean
    userId?: boolean
    platform?: boolean
    handle?: boolean
    isEnabled?: boolean
    verified?: boolean
    createdAt?: boolean
  }

  export type UserMessagingSettingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserMessagingSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserMessagingSetting"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      platform: $Enums.MessagingPlatform
      handle: string | null
      isEnabled: boolean
      verified: boolean
      createdAt: Date
    }, ExtArgs["result"]["userMessagingSetting"]>
    composites: {}
  }

  type UserMessagingSettingGetPayload<S extends boolean | null | undefined | UserMessagingSettingDefaultArgs> = $Result.GetResult<Prisma.$UserMessagingSettingPayload, S>

  type UserMessagingSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserMessagingSettingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserMessagingSettingCountAggregateInputType | true
    }

  export interface UserMessagingSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserMessagingSetting'], meta: { name: 'UserMessagingSetting' } }
    /**
     * Find zero or one UserMessagingSetting that matches the filter.
     * @param {UserMessagingSettingFindUniqueArgs} args - Arguments to find a UserMessagingSetting
     * @example
     * // Get one UserMessagingSetting
     * const userMessagingSetting = await prisma.userMessagingSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserMessagingSettingFindUniqueArgs>(args: SelectSubset<T, UserMessagingSettingFindUniqueArgs<ExtArgs>>): Prisma__UserMessagingSettingClient<$Result.GetResult<Prisma.$UserMessagingSettingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserMessagingSetting that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserMessagingSettingFindUniqueOrThrowArgs} args - Arguments to find a UserMessagingSetting
     * @example
     * // Get one UserMessagingSetting
     * const userMessagingSetting = await prisma.userMessagingSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserMessagingSettingFindUniqueOrThrowArgs>(args: SelectSubset<T, UserMessagingSettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserMessagingSettingClient<$Result.GetResult<Prisma.$UserMessagingSettingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserMessagingSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMessagingSettingFindFirstArgs} args - Arguments to find a UserMessagingSetting
     * @example
     * // Get one UserMessagingSetting
     * const userMessagingSetting = await prisma.userMessagingSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserMessagingSettingFindFirstArgs>(args?: SelectSubset<T, UserMessagingSettingFindFirstArgs<ExtArgs>>): Prisma__UserMessagingSettingClient<$Result.GetResult<Prisma.$UserMessagingSettingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserMessagingSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMessagingSettingFindFirstOrThrowArgs} args - Arguments to find a UserMessagingSetting
     * @example
     * // Get one UserMessagingSetting
     * const userMessagingSetting = await prisma.userMessagingSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserMessagingSettingFindFirstOrThrowArgs>(args?: SelectSubset<T, UserMessagingSettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserMessagingSettingClient<$Result.GetResult<Prisma.$UserMessagingSettingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserMessagingSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMessagingSettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserMessagingSettings
     * const userMessagingSettings = await prisma.userMessagingSetting.findMany()
     * 
     * // Get first 10 UserMessagingSettings
     * const userMessagingSettings = await prisma.userMessagingSetting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userMessagingSettingWithIdOnly = await prisma.userMessagingSetting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserMessagingSettingFindManyArgs>(args?: SelectSubset<T, UserMessagingSettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserMessagingSettingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserMessagingSetting.
     * @param {UserMessagingSettingCreateArgs} args - Arguments to create a UserMessagingSetting.
     * @example
     * // Create one UserMessagingSetting
     * const UserMessagingSetting = await prisma.userMessagingSetting.create({
     *   data: {
     *     // ... data to create a UserMessagingSetting
     *   }
     * })
     * 
     */
    create<T extends UserMessagingSettingCreateArgs>(args: SelectSubset<T, UserMessagingSettingCreateArgs<ExtArgs>>): Prisma__UserMessagingSettingClient<$Result.GetResult<Prisma.$UserMessagingSettingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserMessagingSettings.
     * @param {UserMessagingSettingCreateManyArgs} args - Arguments to create many UserMessagingSettings.
     * @example
     * // Create many UserMessagingSettings
     * const userMessagingSetting = await prisma.userMessagingSetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserMessagingSettingCreateManyArgs>(args?: SelectSubset<T, UserMessagingSettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserMessagingSetting.
     * @param {UserMessagingSettingDeleteArgs} args - Arguments to delete one UserMessagingSetting.
     * @example
     * // Delete one UserMessagingSetting
     * const UserMessagingSetting = await prisma.userMessagingSetting.delete({
     *   where: {
     *     // ... filter to delete one UserMessagingSetting
     *   }
     * })
     * 
     */
    delete<T extends UserMessagingSettingDeleteArgs>(args: SelectSubset<T, UserMessagingSettingDeleteArgs<ExtArgs>>): Prisma__UserMessagingSettingClient<$Result.GetResult<Prisma.$UserMessagingSettingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserMessagingSetting.
     * @param {UserMessagingSettingUpdateArgs} args - Arguments to update one UserMessagingSetting.
     * @example
     * // Update one UserMessagingSetting
     * const userMessagingSetting = await prisma.userMessagingSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserMessagingSettingUpdateArgs>(args: SelectSubset<T, UserMessagingSettingUpdateArgs<ExtArgs>>): Prisma__UserMessagingSettingClient<$Result.GetResult<Prisma.$UserMessagingSettingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserMessagingSettings.
     * @param {UserMessagingSettingDeleteManyArgs} args - Arguments to filter UserMessagingSettings to delete.
     * @example
     * // Delete a few UserMessagingSettings
     * const { count } = await prisma.userMessagingSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserMessagingSettingDeleteManyArgs>(args?: SelectSubset<T, UserMessagingSettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserMessagingSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMessagingSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserMessagingSettings
     * const userMessagingSetting = await prisma.userMessagingSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserMessagingSettingUpdateManyArgs>(args: SelectSubset<T, UserMessagingSettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserMessagingSetting.
     * @param {UserMessagingSettingUpsertArgs} args - Arguments to update or create a UserMessagingSetting.
     * @example
     * // Update or create a UserMessagingSetting
     * const userMessagingSetting = await prisma.userMessagingSetting.upsert({
     *   create: {
     *     // ... data to create a UserMessagingSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserMessagingSetting we want to update
     *   }
     * })
     */
    upsert<T extends UserMessagingSettingUpsertArgs>(args: SelectSubset<T, UserMessagingSettingUpsertArgs<ExtArgs>>): Prisma__UserMessagingSettingClient<$Result.GetResult<Prisma.$UserMessagingSettingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserMessagingSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMessagingSettingCountArgs} args - Arguments to filter UserMessagingSettings to count.
     * @example
     * // Count the number of UserMessagingSettings
     * const count = await prisma.userMessagingSetting.count({
     *   where: {
     *     // ... the filter for the UserMessagingSettings we want to count
     *   }
     * })
    **/
    count<T extends UserMessagingSettingCountArgs>(
      args?: Subset<T, UserMessagingSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserMessagingSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserMessagingSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMessagingSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserMessagingSettingAggregateArgs>(args: Subset<T, UserMessagingSettingAggregateArgs>): Prisma.PrismaPromise<GetUserMessagingSettingAggregateType<T>>

    /**
     * Group by UserMessagingSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMessagingSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserMessagingSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserMessagingSettingGroupByArgs['orderBy'] }
        : { orderBy?: UserMessagingSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserMessagingSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserMessagingSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserMessagingSetting model
   */
  readonly fields: UserMessagingSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserMessagingSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserMessagingSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserMessagingSetting model
   */ 
  interface UserMessagingSettingFieldRefs {
    readonly id: FieldRef<"UserMessagingSetting", 'String'>
    readonly userId: FieldRef<"UserMessagingSetting", 'String'>
    readonly platform: FieldRef<"UserMessagingSetting", 'MessagingPlatform'>
    readonly handle: FieldRef<"UserMessagingSetting", 'String'>
    readonly isEnabled: FieldRef<"UserMessagingSetting", 'Boolean'>
    readonly verified: FieldRef<"UserMessagingSetting", 'Boolean'>
    readonly createdAt: FieldRef<"UserMessagingSetting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserMessagingSetting findUnique
   */
  export type UserMessagingSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMessagingSetting
     */
    select?: UserMessagingSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMessagingSettingInclude<ExtArgs> | null
    /**
     * Filter, which UserMessagingSetting to fetch.
     */
    where: UserMessagingSettingWhereUniqueInput
  }

  /**
   * UserMessagingSetting findUniqueOrThrow
   */
  export type UserMessagingSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMessagingSetting
     */
    select?: UserMessagingSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMessagingSettingInclude<ExtArgs> | null
    /**
     * Filter, which UserMessagingSetting to fetch.
     */
    where: UserMessagingSettingWhereUniqueInput
  }

  /**
   * UserMessagingSetting findFirst
   */
  export type UserMessagingSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMessagingSetting
     */
    select?: UserMessagingSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMessagingSettingInclude<ExtArgs> | null
    /**
     * Filter, which UserMessagingSetting to fetch.
     */
    where?: UserMessagingSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserMessagingSettings to fetch.
     */
    orderBy?: UserMessagingSettingOrderByWithRelationInput | UserMessagingSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserMessagingSettings.
     */
    cursor?: UserMessagingSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserMessagingSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserMessagingSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserMessagingSettings.
     */
    distinct?: UserMessagingSettingScalarFieldEnum | UserMessagingSettingScalarFieldEnum[]
  }

  /**
   * UserMessagingSetting findFirstOrThrow
   */
  export type UserMessagingSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMessagingSetting
     */
    select?: UserMessagingSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMessagingSettingInclude<ExtArgs> | null
    /**
     * Filter, which UserMessagingSetting to fetch.
     */
    where?: UserMessagingSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserMessagingSettings to fetch.
     */
    orderBy?: UserMessagingSettingOrderByWithRelationInput | UserMessagingSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserMessagingSettings.
     */
    cursor?: UserMessagingSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserMessagingSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserMessagingSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserMessagingSettings.
     */
    distinct?: UserMessagingSettingScalarFieldEnum | UserMessagingSettingScalarFieldEnum[]
  }

  /**
   * UserMessagingSetting findMany
   */
  export type UserMessagingSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMessagingSetting
     */
    select?: UserMessagingSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMessagingSettingInclude<ExtArgs> | null
    /**
     * Filter, which UserMessagingSettings to fetch.
     */
    where?: UserMessagingSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserMessagingSettings to fetch.
     */
    orderBy?: UserMessagingSettingOrderByWithRelationInput | UserMessagingSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserMessagingSettings.
     */
    cursor?: UserMessagingSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserMessagingSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserMessagingSettings.
     */
    skip?: number
    distinct?: UserMessagingSettingScalarFieldEnum | UserMessagingSettingScalarFieldEnum[]
  }

  /**
   * UserMessagingSetting create
   */
  export type UserMessagingSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMessagingSetting
     */
    select?: UserMessagingSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMessagingSettingInclude<ExtArgs> | null
    /**
     * The data needed to create a UserMessagingSetting.
     */
    data: XOR<UserMessagingSettingCreateInput, UserMessagingSettingUncheckedCreateInput>
  }

  /**
   * UserMessagingSetting createMany
   */
  export type UserMessagingSettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserMessagingSettings.
     */
    data: UserMessagingSettingCreateManyInput | UserMessagingSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserMessagingSetting update
   */
  export type UserMessagingSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMessagingSetting
     */
    select?: UserMessagingSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMessagingSettingInclude<ExtArgs> | null
    /**
     * The data needed to update a UserMessagingSetting.
     */
    data: XOR<UserMessagingSettingUpdateInput, UserMessagingSettingUncheckedUpdateInput>
    /**
     * Choose, which UserMessagingSetting to update.
     */
    where: UserMessagingSettingWhereUniqueInput
  }

  /**
   * UserMessagingSetting updateMany
   */
  export type UserMessagingSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserMessagingSettings.
     */
    data: XOR<UserMessagingSettingUpdateManyMutationInput, UserMessagingSettingUncheckedUpdateManyInput>
    /**
     * Filter which UserMessagingSettings to update
     */
    where?: UserMessagingSettingWhereInput
  }

  /**
   * UserMessagingSetting upsert
   */
  export type UserMessagingSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMessagingSetting
     */
    select?: UserMessagingSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMessagingSettingInclude<ExtArgs> | null
    /**
     * The filter to search for the UserMessagingSetting to update in case it exists.
     */
    where: UserMessagingSettingWhereUniqueInput
    /**
     * In case the UserMessagingSetting found by the `where` argument doesn't exist, create a new UserMessagingSetting with this data.
     */
    create: XOR<UserMessagingSettingCreateInput, UserMessagingSettingUncheckedCreateInput>
    /**
     * In case the UserMessagingSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserMessagingSettingUpdateInput, UserMessagingSettingUncheckedUpdateInput>
  }

  /**
   * UserMessagingSetting delete
   */
  export type UserMessagingSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMessagingSetting
     */
    select?: UserMessagingSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMessagingSettingInclude<ExtArgs> | null
    /**
     * Filter which UserMessagingSetting to delete.
     */
    where: UserMessagingSettingWhereUniqueInput
  }

  /**
   * UserMessagingSetting deleteMany
   */
  export type UserMessagingSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserMessagingSettings to delete
     */
    where?: UserMessagingSettingWhereInput
  }

  /**
   * UserMessagingSetting without action
   */
  export type UserMessagingSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMessagingSetting
     */
    select?: UserMessagingSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMessagingSettingInclude<ExtArgs> | null
  }


  /**
   * Model ChannelCategory
   */

  export type AggregateChannelCategory = {
    _count: ChannelCategoryCountAggregateOutputType | null
    _min: ChannelCategoryMinAggregateOutputType | null
    _max: ChannelCategoryMaxAggregateOutputType | null
  }

  export type ChannelCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
  }

  export type ChannelCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
  }

  export type ChannelCategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    _all: number
  }


  export type ChannelCategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
  }

  export type ChannelCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
  }

  export type ChannelCategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type ChannelCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChannelCategory to aggregate.
     */
    where?: ChannelCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelCategories to fetch.
     */
    orderBy?: ChannelCategoryOrderByWithRelationInput | ChannelCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChannelCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChannelCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChannelCategories
    **/
    _count?: true | ChannelCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChannelCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChannelCategoryMaxAggregateInputType
  }

  export type GetChannelCategoryAggregateType<T extends ChannelCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateChannelCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChannelCategory[P]>
      : GetScalarType<T[P], AggregateChannelCategory[P]>
  }




  export type ChannelCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelCategoryWhereInput
    orderBy?: ChannelCategoryOrderByWithAggregationInput | ChannelCategoryOrderByWithAggregationInput[]
    by: ChannelCategoryScalarFieldEnum[] | ChannelCategoryScalarFieldEnum
    having?: ChannelCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChannelCategoryCountAggregateInputType | true
    _min?: ChannelCategoryMinAggregateInputType
    _max?: ChannelCategoryMaxAggregateInputType
  }

  export type ChannelCategoryGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    _count: ChannelCategoryCountAggregateOutputType | null
    _min: ChannelCategoryMinAggregateOutputType | null
    _max: ChannelCategoryMaxAggregateOutputType | null
  }

  type GetChannelCategoryGroupByPayload<T extends ChannelCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChannelCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChannelCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChannelCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ChannelCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ChannelCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    assignments?: boolean | ChannelCategory$assignmentsArgs<ExtArgs>
    _count?: boolean | ChannelCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["channelCategory"]>


  export type ChannelCategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
  }

  export type ChannelCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignments?: boolean | ChannelCategory$assignmentsArgs<ExtArgs>
    _count?: boolean | ChannelCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ChannelCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChannelCategory"
    objects: {
      assignments: Prisma.$ChannelCategoryAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
    }, ExtArgs["result"]["channelCategory"]>
    composites: {}
  }

  type ChannelCategoryGetPayload<S extends boolean | null | undefined | ChannelCategoryDefaultArgs> = $Result.GetResult<Prisma.$ChannelCategoryPayload, S>

  type ChannelCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChannelCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChannelCategoryCountAggregateInputType | true
    }

  export interface ChannelCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChannelCategory'], meta: { name: 'ChannelCategory' } }
    /**
     * Find zero or one ChannelCategory that matches the filter.
     * @param {ChannelCategoryFindUniqueArgs} args - Arguments to find a ChannelCategory
     * @example
     * // Get one ChannelCategory
     * const channelCategory = await prisma.channelCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChannelCategoryFindUniqueArgs>(args: SelectSubset<T, ChannelCategoryFindUniqueArgs<ExtArgs>>): Prisma__ChannelCategoryClient<$Result.GetResult<Prisma.$ChannelCategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ChannelCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChannelCategoryFindUniqueOrThrowArgs} args - Arguments to find a ChannelCategory
     * @example
     * // Get one ChannelCategory
     * const channelCategory = await prisma.channelCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChannelCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ChannelCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChannelCategoryClient<$Result.GetResult<Prisma.$ChannelCategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ChannelCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelCategoryFindFirstArgs} args - Arguments to find a ChannelCategory
     * @example
     * // Get one ChannelCategory
     * const channelCategory = await prisma.channelCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChannelCategoryFindFirstArgs>(args?: SelectSubset<T, ChannelCategoryFindFirstArgs<ExtArgs>>): Prisma__ChannelCategoryClient<$Result.GetResult<Prisma.$ChannelCategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ChannelCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelCategoryFindFirstOrThrowArgs} args - Arguments to find a ChannelCategory
     * @example
     * // Get one ChannelCategory
     * const channelCategory = await prisma.channelCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChannelCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ChannelCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChannelCategoryClient<$Result.GetResult<Prisma.$ChannelCategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ChannelCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChannelCategories
     * const channelCategories = await prisma.channelCategory.findMany()
     * 
     * // Get first 10 ChannelCategories
     * const channelCategories = await prisma.channelCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const channelCategoryWithIdOnly = await prisma.channelCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChannelCategoryFindManyArgs>(args?: SelectSubset<T, ChannelCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelCategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ChannelCategory.
     * @param {ChannelCategoryCreateArgs} args - Arguments to create a ChannelCategory.
     * @example
     * // Create one ChannelCategory
     * const ChannelCategory = await prisma.channelCategory.create({
     *   data: {
     *     // ... data to create a ChannelCategory
     *   }
     * })
     * 
     */
    create<T extends ChannelCategoryCreateArgs>(args: SelectSubset<T, ChannelCategoryCreateArgs<ExtArgs>>): Prisma__ChannelCategoryClient<$Result.GetResult<Prisma.$ChannelCategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ChannelCategories.
     * @param {ChannelCategoryCreateManyArgs} args - Arguments to create many ChannelCategories.
     * @example
     * // Create many ChannelCategories
     * const channelCategory = await prisma.channelCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChannelCategoryCreateManyArgs>(args?: SelectSubset<T, ChannelCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ChannelCategory.
     * @param {ChannelCategoryDeleteArgs} args - Arguments to delete one ChannelCategory.
     * @example
     * // Delete one ChannelCategory
     * const ChannelCategory = await prisma.channelCategory.delete({
     *   where: {
     *     // ... filter to delete one ChannelCategory
     *   }
     * })
     * 
     */
    delete<T extends ChannelCategoryDeleteArgs>(args: SelectSubset<T, ChannelCategoryDeleteArgs<ExtArgs>>): Prisma__ChannelCategoryClient<$Result.GetResult<Prisma.$ChannelCategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ChannelCategory.
     * @param {ChannelCategoryUpdateArgs} args - Arguments to update one ChannelCategory.
     * @example
     * // Update one ChannelCategory
     * const channelCategory = await prisma.channelCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChannelCategoryUpdateArgs>(args: SelectSubset<T, ChannelCategoryUpdateArgs<ExtArgs>>): Prisma__ChannelCategoryClient<$Result.GetResult<Prisma.$ChannelCategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ChannelCategories.
     * @param {ChannelCategoryDeleteManyArgs} args - Arguments to filter ChannelCategories to delete.
     * @example
     * // Delete a few ChannelCategories
     * const { count } = await prisma.channelCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChannelCategoryDeleteManyArgs>(args?: SelectSubset<T, ChannelCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChannelCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChannelCategories
     * const channelCategory = await prisma.channelCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChannelCategoryUpdateManyArgs>(args: SelectSubset<T, ChannelCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChannelCategory.
     * @param {ChannelCategoryUpsertArgs} args - Arguments to update or create a ChannelCategory.
     * @example
     * // Update or create a ChannelCategory
     * const channelCategory = await prisma.channelCategory.upsert({
     *   create: {
     *     // ... data to create a ChannelCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChannelCategory we want to update
     *   }
     * })
     */
    upsert<T extends ChannelCategoryUpsertArgs>(args: SelectSubset<T, ChannelCategoryUpsertArgs<ExtArgs>>): Prisma__ChannelCategoryClient<$Result.GetResult<Prisma.$ChannelCategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ChannelCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelCategoryCountArgs} args - Arguments to filter ChannelCategories to count.
     * @example
     * // Count the number of ChannelCategories
     * const count = await prisma.channelCategory.count({
     *   where: {
     *     // ... the filter for the ChannelCategories we want to count
     *   }
     * })
    **/
    count<T extends ChannelCategoryCountArgs>(
      args?: Subset<T, ChannelCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChannelCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChannelCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChannelCategoryAggregateArgs>(args: Subset<T, ChannelCategoryAggregateArgs>): Prisma.PrismaPromise<GetChannelCategoryAggregateType<T>>

    /**
     * Group by ChannelCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChannelCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChannelCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ChannelCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChannelCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChannelCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChannelCategory model
   */
  readonly fields: ChannelCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChannelCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChannelCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignments<T extends ChannelCategory$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, ChannelCategory$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelCategoryAssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChannelCategory model
   */ 
  interface ChannelCategoryFieldRefs {
    readonly id: FieldRef<"ChannelCategory", 'String'>
    readonly name: FieldRef<"ChannelCategory", 'String'>
    readonly description: FieldRef<"ChannelCategory", 'String'>
    readonly createdAt: FieldRef<"ChannelCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChannelCategory findUnique
   */
  export type ChannelCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCategory
     */
    select?: ChannelCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ChannelCategory to fetch.
     */
    where: ChannelCategoryWhereUniqueInput
  }

  /**
   * ChannelCategory findUniqueOrThrow
   */
  export type ChannelCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCategory
     */
    select?: ChannelCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ChannelCategory to fetch.
     */
    where: ChannelCategoryWhereUniqueInput
  }

  /**
   * ChannelCategory findFirst
   */
  export type ChannelCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCategory
     */
    select?: ChannelCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ChannelCategory to fetch.
     */
    where?: ChannelCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelCategories to fetch.
     */
    orderBy?: ChannelCategoryOrderByWithRelationInput | ChannelCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChannelCategories.
     */
    cursor?: ChannelCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChannelCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChannelCategories.
     */
    distinct?: ChannelCategoryScalarFieldEnum | ChannelCategoryScalarFieldEnum[]
  }

  /**
   * ChannelCategory findFirstOrThrow
   */
  export type ChannelCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCategory
     */
    select?: ChannelCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ChannelCategory to fetch.
     */
    where?: ChannelCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelCategories to fetch.
     */
    orderBy?: ChannelCategoryOrderByWithRelationInput | ChannelCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChannelCategories.
     */
    cursor?: ChannelCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChannelCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChannelCategories.
     */
    distinct?: ChannelCategoryScalarFieldEnum | ChannelCategoryScalarFieldEnum[]
  }

  /**
   * ChannelCategory findMany
   */
  export type ChannelCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCategory
     */
    select?: ChannelCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ChannelCategories to fetch.
     */
    where?: ChannelCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelCategories to fetch.
     */
    orderBy?: ChannelCategoryOrderByWithRelationInput | ChannelCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChannelCategories.
     */
    cursor?: ChannelCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChannelCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelCategories.
     */
    skip?: number
    distinct?: ChannelCategoryScalarFieldEnum | ChannelCategoryScalarFieldEnum[]
  }

  /**
   * ChannelCategory create
   */
  export type ChannelCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCategory
     */
    select?: ChannelCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ChannelCategory.
     */
    data: XOR<ChannelCategoryCreateInput, ChannelCategoryUncheckedCreateInput>
  }

  /**
   * ChannelCategory createMany
   */
  export type ChannelCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChannelCategories.
     */
    data: ChannelCategoryCreateManyInput | ChannelCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChannelCategory update
   */
  export type ChannelCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCategory
     */
    select?: ChannelCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ChannelCategory.
     */
    data: XOR<ChannelCategoryUpdateInput, ChannelCategoryUncheckedUpdateInput>
    /**
     * Choose, which ChannelCategory to update.
     */
    where: ChannelCategoryWhereUniqueInput
  }

  /**
   * ChannelCategory updateMany
   */
  export type ChannelCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChannelCategories.
     */
    data: XOR<ChannelCategoryUpdateManyMutationInput, ChannelCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ChannelCategories to update
     */
    where?: ChannelCategoryWhereInput
  }

  /**
   * ChannelCategory upsert
   */
  export type ChannelCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCategory
     */
    select?: ChannelCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ChannelCategory to update in case it exists.
     */
    where: ChannelCategoryWhereUniqueInput
    /**
     * In case the ChannelCategory found by the `where` argument doesn't exist, create a new ChannelCategory with this data.
     */
    create: XOR<ChannelCategoryCreateInput, ChannelCategoryUncheckedCreateInput>
    /**
     * In case the ChannelCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChannelCategoryUpdateInput, ChannelCategoryUncheckedUpdateInput>
  }

  /**
   * ChannelCategory delete
   */
  export type ChannelCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCategory
     */
    select?: ChannelCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelCategoryInclude<ExtArgs> | null
    /**
     * Filter which ChannelCategory to delete.
     */
    where: ChannelCategoryWhereUniqueInput
  }

  /**
   * ChannelCategory deleteMany
   */
  export type ChannelCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChannelCategories to delete
     */
    where?: ChannelCategoryWhereInput
  }

  /**
   * ChannelCategory.assignments
   */
  export type ChannelCategory$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCategoryAssignment
     */
    select?: ChannelCategoryAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelCategoryAssignmentInclude<ExtArgs> | null
    where?: ChannelCategoryAssignmentWhereInput
    orderBy?: ChannelCategoryAssignmentOrderByWithRelationInput | ChannelCategoryAssignmentOrderByWithRelationInput[]
    cursor?: ChannelCategoryAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChannelCategoryAssignmentScalarFieldEnum | ChannelCategoryAssignmentScalarFieldEnum[]
  }

  /**
   * ChannelCategory without action
   */
  export type ChannelCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCategory
     */
    select?: ChannelCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelCategoryInclude<ExtArgs> | null
  }


  /**
   * Model ChannelCategoryAssignment
   */

  export type AggregateChannelCategoryAssignment = {
    _count: ChannelCategoryAssignmentCountAggregateOutputType | null
    _min: ChannelCategoryAssignmentMinAggregateOutputType | null
    _max: ChannelCategoryAssignmentMaxAggregateOutputType | null
  }

  export type ChannelCategoryAssignmentMinAggregateOutputType = {
    id: string | null
    channelId: string | null
    categoryId: string | null
  }

  export type ChannelCategoryAssignmentMaxAggregateOutputType = {
    id: string | null
    channelId: string | null
    categoryId: string | null
  }

  export type ChannelCategoryAssignmentCountAggregateOutputType = {
    id: number
    channelId: number
    categoryId: number
    _all: number
  }


  export type ChannelCategoryAssignmentMinAggregateInputType = {
    id?: true
    channelId?: true
    categoryId?: true
  }

  export type ChannelCategoryAssignmentMaxAggregateInputType = {
    id?: true
    channelId?: true
    categoryId?: true
  }

  export type ChannelCategoryAssignmentCountAggregateInputType = {
    id?: true
    channelId?: true
    categoryId?: true
    _all?: true
  }

  export type ChannelCategoryAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChannelCategoryAssignment to aggregate.
     */
    where?: ChannelCategoryAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelCategoryAssignments to fetch.
     */
    orderBy?: ChannelCategoryAssignmentOrderByWithRelationInput | ChannelCategoryAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChannelCategoryAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChannelCategoryAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelCategoryAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChannelCategoryAssignments
    **/
    _count?: true | ChannelCategoryAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChannelCategoryAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChannelCategoryAssignmentMaxAggregateInputType
  }

  export type GetChannelCategoryAssignmentAggregateType<T extends ChannelCategoryAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateChannelCategoryAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChannelCategoryAssignment[P]>
      : GetScalarType<T[P], AggregateChannelCategoryAssignment[P]>
  }




  export type ChannelCategoryAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelCategoryAssignmentWhereInput
    orderBy?: ChannelCategoryAssignmentOrderByWithAggregationInput | ChannelCategoryAssignmentOrderByWithAggregationInput[]
    by: ChannelCategoryAssignmentScalarFieldEnum[] | ChannelCategoryAssignmentScalarFieldEnum
    having?: ChannelCategoryAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChannelCategoryAssignmentCountAggregateInputType | true
    _min?: ChannelCategoryAssignmentMinAggregateInputType
    _max?: ChannelCategoryAssignmentMaxAggregateInputType
  }

  export type ChannelCategoryAssignmentGroupByOutputType = {
    id: string
    channelId: string
    categoryId: string
    _count: ChannelCategoryAssignmentCountAggregateOutputType | null
    _min: ChannelCategoryAssignmentMinAggregateOutputType | null
    _max: ChannelCategoryAssignmentMaxAggregateOutputType | null
  }

  type GetChannelCategoryAssignmentGroupByPayload<T extends ChannelCategoryAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChannelCategoryAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChannelCategoryAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChannelCategoryAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], ChannelCategoryAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type ChannelCategoryAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    channelId?: boolean
    categoryId?: boolean
    channel?: boolean | ChannelDefaultArgs<ExtArgs>
    category?: boolean | ChannelCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["channelCategoryAssignment"]>


  export type ChannelCategoryAssignmentSelectScalar = {
    id?: boolean
    channelId?: boolean
    categoryId?: boolean
  }

  export type ChannelCategoryAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    channel?: boolean | ChannelDefaultArgs<ExtArgs>
    category?: boolean | ChannelCategoryDefaultArgs<ExtArgs>
  }

  export type $ChannelCategoryAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChannelCategoryAssignment"
    objects: {
      channel: Prisma.$ChannelPayload<ExtArgs>
      category: Prisma.$ChannelCategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      channelId: string
      categoryId: string
    }, ExtArgs["result"]["channelCategoryAssignment"]>
    composites: {}
  }

  type ChannelCategoryAssignmentGetPayload<S extends boolean | null | undefined | ChannelCategoryAssignmentDefaultArgs> = $Result.GetResult<Prisma.$ChannelCategoryAssignmentPayload, S>

  type ChannelCategoryAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChannelCategoryAssignmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChannelCategoryAssignmentCountAggregateInputType | true
    }

  export interface ChannelCategoryAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChannelCategoryAssignment'], meta: { name: 'ChannelCategoryAssignment' } }
    /**
     * Find zero or one ChannelCategoryAssignment that matches the filter.
     * @param {ChannelCategoryAssignmentFindUniqueArgs} args - Arguments to find a ChannelCategoryAssignment
     * @example
     * // Get one ChannelCategoryAssignment
     * const channelCategoryAssignment = await prisma.channelCategoryAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChannelCategoryAssignmentFindUniqueArgs>(args: SelectSubset<T, ChannelCategoryAssignmentFindUniqueArgs<ExtArgs>>): Prisma__ChannelCategoryAssignmentClient<$Result.GetResult<Prisma.$ChannelCategoryAssignmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ChannelCategoryAssignment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChannelCategoryAssignmentFindUniqueOrThrowArgs} args - Arguments to find a ChannelCategoryAssignment
     * @example
     * // Get one ChannelCategoryAssignment
     * const channelCategoryAssignment = await prisma.channelCategoryAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChannelCategoryAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, ChannelCategoryAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChannelCategoryAssignmentClient<$Result.GetResult<Prisma.$ChannelCategoryAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ChannelCategoryAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelCategoryAssignmentFindFirstArgs} args - Arguments to find a ChannelCategoryAssignment
     * @example
     * // Get one ChannelCategoryAssignment
     * const channelCategoryAssignment = await prisma.channelCategoryAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChannelCategoryAssignmentFindFirstArgs>(args?: SelectSubset<T, ChannelCategoryAssignmentFindFirstArgs<ExtArgs>>): Prisma__ChannelCategoryAssignmentClient<$Result.GetResult<Prisma.$ChannelCategoryAssignmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ChannelCategoryAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelCategoryAssignmentFindFirstOrThrowArgs} args - Arguments to find a ChannelCategoryAssignment
     * @example
     * // Get one ChannelCategoryAssignment
     * const channelCategoryAssignment = await prisma.channelCategoryAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChannelCategoryAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, ChannelCategoryAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChannelCategoryAssignmentClient<$Result.GetResult<Prisma.$ChannelCategoryAssignmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ChannelCategoryAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelCategoryAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChannelCategoryAssignments
     * const channelCategoryAssignments = await prisma.channelCategoryAssignment.findMany()
     * 
     * // Get first 10 ChannelCategoryAssignments
     * const channelCategoryAssignments = await prisma.channelCategoryAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const channelCategoryAssignmentWithIdOnly = await prisma.channelCategoryAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChannelCategoryAssignmentFindManyArgs>(args?: SelectSubset<T, ChannelCategoryAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelCategoryAssignmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ChannelCategoryAssignment.
     * @param {ChannelCategoryAssignmentCreateArgs} args - Arguments to create a ChannelCategoryAssignment.
     * @example
     * // Create one ChannelCategoryAssignment
     * const ChannelCategoryAssignment = await prisma.channelCategoryAssignment.create({
     *   data: {
     *     // ... data to create a ChannelCategoryAssignment
     *   }
     * })
     * 
     */
    create<T extends ChannelCategoryAssignmentCreateArgs>(args: SelectSubset<T, ChannelCategoryAssignmentCreateArgs<ExtArgs>>): Prisma__ChannelCategoryAssignmentClient<$Result.GetResult<Prisma.$ChannelCategoryAssignmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ChannelCategoryAssignments.
     * @param {ChannelCategoryAssignmentCreateManyArgs} args - Arguments to create many ChannelCategoryAssignments.
     * @example
     * // Create many ChannelCategoryAssignments
     * const channelCategoryAssignment = await prisma.channelCategoryAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChannelCategoryAssignmentCreateManyArgs>(args?: SelectSubset<T, ChannelCategoryAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ChannelCategoryAssignment.
     * @param {ChannelCategoryAssignmentDeleteArgs} args - Arguments to delete one ChannelCategoryAssignment.
     * @example
     * // Delete one ChannelCategoryAssignment
     * const ChannelCategoryAssignment = await prisma.channelCategoryAssignment.delete({
     *   where: {
     *     // ... filter to delete one ChannelCategoryAssignment
     *   }
     * })
     * 
     */
    delete<T extends ChannelCategoryAssignmentDeleteArgs>(args: SelectSubset<T, ChannelCategoryAssignmentDeleteArgs<ExtArgs>>): Prisma__ChannelCategoryAssignmentClient<$Result.GetResult<Prisma.$ChannelCategoryAssignmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ChannelCategoryAssignment.
     * @param {ChannelCategoryAssignmentUpdateArgs} args - Arguments to update one ChannelCategoryAssignment.
     * @example
     * // Update one ChannelCategoryAssignment
     * const channelCategoryAssignment = await prisma.channelCategoryAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChannelCategoryAssignmentUpdateArgs>(args: SelectSubset<T, ChannelCategoryAssignmentUpdateArgs<ExtArgs>>): Prisma__ChannelCategoryAssignmentClient<$Result.GetResult<Prisma.$ChannelCategoryAssignmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ChannelCategoryAssignments.
     * @param {ChannelCategoryAssignmentDeleteManyArgs} args - Arguments to filter ChannelCategoryAssignments to delete.
     * @example
     * // Delete a few ChannelCategoryAssignments
     * const { count } = await prisma.channelCategoryAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChannelCategoryAssignmentDeleteManyArgs>(args?: SelectSubset<T, ChannelCategoryAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChannelCategoryAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelCategoryAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChannelCategoryAssignments
     * const channelCategoryAssignment = await prisma.channelCategoryAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChannelCategoryAssignmentUpdateManyArgs>(args: SelectSubset<T, ChannelCategoryAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChannelCategoryAssignment.
     * @param {ChannelCategoryAssignmentUpsertArgs} args - Arguments to update or create a ChannelCategoryAssignment.
     * @example
     * // Update or create a ChannelCategoryAssignment
     * const channelCategoryAssignment = await prisma.channelCategoryAssignment.upsert({
     *   create: {
     *     // ... data to create a ChannelCategoryAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChannelCategoryAssignment we want to update
     *   }
     * })
     */
    upsert<T extends ChannelCategoryAssignmentUpsertArgs>(args: SelectSubset<T, ChannelCategoryAssignmentUpsertArgs<ExtArgs>>): Prisma__ChannelCategoryAssignmentClient<$Result.GetResult<Prisma.$ChannelCategoryAssignmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ChannelCategoryAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelCategoryAssignmentCountArgs} args - Arguments to filter ChannelCategoryAssignments to count.
     * @example
     * // Count the number of ChannelCategoryAssignments
     * const count = await prisma.channelCategoryAssignment.count({
     *   where: {
     *     // ... the filter for the ChannelCategoryAssignments we want to count
     *   }
     * })
    **/
    count<T extends ChannelCategoryAssignmentCountArgs>(
      args?: Subset<T, ChannelCategoryAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChannelCategoryAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChannelCategoryAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelCategoryAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChannelCategoryAssignmentAggregateArgs>(args: Subset<T, ChannelCategoryAssignmentAggregateArgs>): Prisma.PrismaPromise<GetChannelCategoryAssignmentAggregateType<T>>

    /**
     * Group by ChannelCategoryAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelCategoryAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChannelCategoryAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChannelCategoryAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: ChannelCategoryAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChannelCategoryAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChannelCategoryAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChannelCategoryAssignment model
   */
  readonly fields: ChannelCategoryAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChannelCategoryAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChannelCategoryAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    channel<T extends ChannelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChannelDefaultArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    category<T extends ChannelCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChannelCategoryDefaultArgs<ExtArgs>>): Prisma__ChannelCategoryClient<$Result.GetResult<Prisma.$ChannelCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChannelCategoryAssignment model
   */ 
  interface ChannelCategoryAssignmentFieldRefs {
    readonly id: FieldRef<"ChannelCategoryAssignment", 'String'>
    readonly channelId: FieldRef<"ChannelCategoryAssignment", 'String'>
    readonly categoryId: FieldRef<"ChannelCategoryAssignment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ChannelCategoryAssignment findUnique
   */
  export type ChannelCategoryAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCategoryAssignment
     */
    select?: ChannelCategoryAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelCategoryAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ChannelCategoryAssignment to fetch.
     */
    where: ChannelCategoryAssignmentWhereUniqueInput
  }

  /**
   * ChannelCategoryAssignment findUniqueOrThrow
   */
  export type ChannelCategoryAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCategoryAssignment
     */
    select?: ChannelCategoryAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelCategoryAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ChannelCategoryAssignment to fetch.
     */
    where: ChannelCategoryAssignmentWhereUniqueInput
  }

  /**
   * ChannelCategoryAssignment findFirst
   */
  export type ChannelCategoryAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCategoryAssignment
     */
    select?: ChannelCategoryAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelCategoryAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ChannelCategoryAssignment to fetch.
     */
    where?: ChannelCategoryAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelCategoryAssignments to fetch.
     */
    orderBy?: ChannelCategoryAssignmentOrderByWithRelationInput | ChannelCategoryAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChannelCategoryAssignments.
     */
    cursor?: ChannelCategoryAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChannelCategoryAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelCategoryAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChannelCategoryAssignments.
     */
    distinct?: ChannelCategoryAssignmentScalarFieldEnum | ChannelCategoryAssignmentScalarFieldEnum[]
  }

  /**
   * ChannelCategoryAssignment findFirstOrThrow
   */
  export type ChannelCategoryAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCategoryAssignment
     */
    select?: ChannelCategoryAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelCategoryAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ChannelCategoryAssignment to fetch.
     */
    where?: ChannelCategoryAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelCategoryAssignments to fetch.
     */
    orderBy?: ChannelCategoryAssignmentOrderByWithRelationInput | ChannelCategoryAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChannelCategoryAssignments.
     */
    cursor?: ChannelCategoryAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChannelCategoryAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelCategoryAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChannelCategoryAssignments.
     */
    distinct?: ChannelCategoryAssignmentScalarFieldEnum | ChannelCategoryAssignmentScalarFieldEnum[]
  }

  /**
   * ChannelCategoryAssignment findMany
   */
  export type ChannelCategoryAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCategoryAssignment
     */
    select?: ChannelCategoryAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelCategoryAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ChannelCategoryAssignments to fetch.
     */
    where?: ChannelCategoryAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelCategoryAssignments to fetch.
     */
    orderBy?: ChannelCategoryAssignmentOrderByWithRelationInput | ChannelCategoryAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChannelCategoryAssignments.
     */
    cursor?: ChannelCategoryAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChannelCategoryAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelCategoryAssignments.
     */
    skip?: number
    distinct?: ChannelCategoryAssignmentScalarFieldEnum | ChannelCategoryAssignmentScalarFieldEnum[]
  }

  /**
   * ChannelCategoryAssignment create
   */
  export type ChannelCategoryAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCategoryAssignment
     */
    select?: ChannelCategoryAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelCategoryAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a ChannelCategoryAssignment.
     */
    data: XOR<ChannelCategoryAssignmentCreateInput, ChannelCategoryAssignmentUncheckedCreateInput>
  }

  /**
   * ChannelCategoryAssignment createMany
   */
  export type ChannelCategoryAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChannelCategoryAssignments.
     */
    data: ChannelCategoryAssignmentCreateManyInput | ChannelCategoryAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChannelCategoryAssignment update
   */
  export type ChannelCategoryAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCategoryAssignment
     */
    select?: ChannelCategoryAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelCategoryAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a ChannelCategoryAssignment.
     */
    data: XOR<ChannelCategoryAssignmentUpdateInput, ChannelCategoryAssignmentUncheckedUpdateInput>
    /**
     * Choose, which ChannelCategoryAssignment to update.
     */
    where: ChannelCategoryAssignmentWhereUniqueInput
  }

  /**
   * ChannelCategoryAssignment updateMany
   */
  export type ChannelCategoryAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChannelCategoryAssignments.
     */
    data: XOR<ChannelCategoryAssignmentUpdateManyMutationInput, ChannelCategoryAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which ChannelCategoryAssignments to update
     */
    where?: ChannelCategoryAssignmentWhereInput
  }

  /**
   * ChannelCategoryAssignment upsert
   */
  export type ChannelCategoryAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCategoryAssignment
     */
    select?: ChannelCategoryAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelCategoryAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the ChannelCategoryAssignment to update in case it exists.
     */
    where: ChannelCategoryAssignmentWhereUniqueInput
    /**
     * In case the ChannelCategoryAssignment found by the `where` argument doesn't exist, create a new ChannelCategoryAssignment with this data.
     */
    create: XOR<ChannelCategoryAssignmentCreateInput, ChannelCategoryAssignmentUncheckedCreateInput>
    /**
     * In case the ChannelCategoryAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChannelCategoryAssignmentUpdateInput, ChannelCategoryAssignmentUncheckedUpdateInput>
  }

  /**
   * ChannelCategoryAssignment delete
   */
  export type ChannelCategoryAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCategoryAssignment
     */
    select?: ChannelCategoryAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelCategoryAssignmentInclude<ExtArgs> | null
    /**
     * Filter which ChannelCategoryAssignment to delete.
     */
    where: ChannelCategoryAssignmentWhereUniqueInput
  }

  /**
   * ChannelCategoryAssignment deleteMany
   */
  export type ChannelCategoryAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChannelCategoryAssignments to delete
     */
    where?: ChannelCategoryAssignmentWhereInput
  }

  /**
   * ChannelCategoryAssignment without action
   */
  export type ChannelCategoryAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCategoryAssignment
     */
    select?: ChannelCategoryAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelCategoryAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model MessageView
   */

  export type AggregateMessageView = {
    _count: MessageViewCountAggregateOutputType | null
    _min: MessageViewMinAggregateOutputType | null
    _max: MessageViewMaxAggregateOutputType | null
  }

  export type MessageViewMinAggregateOutputType = {
    id: string | null
    messageId: string | null
    userId: string | null
    viewedAt: Date | null
  }

  export type MessageViewMaxAggregateOutputType = {
    id: string | null
    messageId: string | null
    userId: string | null
    viewedAt: Date | null
  }

  export type MessageViewCountAggregateOutputType = {
    id: number
    messageId: number
    userId: number
    viewedAt: number
    _all: number
  }


  export type MessageViewMinAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    viewedAt?: true
  }

  export type MessageViewMaxAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    viewedAt?: true
  }

  export type MessageViewCountAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    viewedAt?: true
    _all?: true
  }

  export type MessageViewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageView to aggregate.
     */
    where?: MessageViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageViews to fetch.
     */
    orderBy?: MessageViewOrderByWithRelationInput | MessageViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageViews
    **/
    _count?: true | MessageViewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageViewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageViewMaxAggregateInputType
  }

  export type GetMessageViewAggregateType<T extends MessageViewAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageView]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageView[P]>
      : GetScalarType<T[P], AggregateMessageView[P]>
  }




  export type MessageViewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageViewWhereInput
    orderBy?: MessageViewOrderByWithAggregationInput | MessageViewOrderByWithAggregationInput[]
    by: MessageViewScalarFieldEnum[] | MessageViewScalarFieldEnum
    having?: MessageViewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageViewCountAggregateInputType | true
    _min?: MessageViewMinAggregateInputType
    _max?: MessageViewMaxAggregateInputType
  }

  export type MessageViewGroupByOutputType = {
    id: string
    messageId: string
    userId: string | null
    viewedAt: Date
    _count: MessageViewCountAggregateOutputType | null
    _min: MessageViewMinAggregateOutputType | null
    _max: MessageViewMaxAggregateOutputType | null
  }

  type GetMessageViewGroupByPayload<T extends MessageViewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageViewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageViewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageViewGroupByOutputType[P]>
            : GetScalarType<T[P], MessageViewGroupByOutputType[P]>
        }
      >
    >


  export type MessageViewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    userId?: boolean
    viewedAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | MessageView$userArgs<ExtArgs>
  }, ExtArgs["result"]["messageView"]>


  export type MessageViewSelectScalar = {
    id?: boolean
    messageId?: boolean
    userId?: boolean
    viewedAt?: boolean
  }

  export type MessageViewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | MessageView$userArgs<ExtArgs>
  }

  export type $MessageViewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageView"
    objects: {
      message: Prisma.$MessagePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      messageId: string
      userId: string | null
      viewedAt: Date
    }, ExtArgs["result"]["messageView"]>
    composites: {}
  }

  type MessageViewGetPayload<S extends boolean | null | undefined | MessageViewDefaultArgs> = $Result.GetResult<Prisma.$MessageViewPayload, S>

  type MessageViewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageViewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageViewCountAggregateInputType | true
    }

  export interface MessageViewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageView'], meta: { name: 'MessageView' } }
    /**
     * Find zero or one MessageView that matches the filter.
     * @param {MessageViewFindUniqueArgs} args - Arguments to find a MessageView
     * @example
     * // Get one MessageView
     * const messageView = await prisma.messageView.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageViewFindUniqueArgs>(args: SelectSubset<T, MessageViewFindUniqueArgs<ExtArgs>>): Prisma__MessageViewClient<$Result.GetResult<Prisma.$MessageViewPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MessageView that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageViewFindUniqueOrThrowArgs} args - Arguments to find a MessageView
     * @example
     * // Get one MessageView
     * const messageView = await prisma.messageView.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageViewFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageViewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageViewClient<$Result.GetResult<Prisma.$MessageViewPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MessageView that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageViewFindFirstArgs} args - Arguments to find a MessageView
     * @example
     * // Get one MessageView
     * const messageView = await prisma.messageView.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageViewFindFirstArgs>(args?: SelectSubset<T, MessageViewFindFirstArgs<ExtArgs>>): Prisma__MessageViewClient<$Result.GetResult<Prisma.$MessageViewPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MessageView that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageViewFindFirstOrThrowArgs} args - Arguments to find a MessageView
     * @example
     * // Get one MessageView
     * const messageView = await prisma.messageView.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageViewFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageViewFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageViewClient<$Result.GetResult<Prisma.$MessageViewPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MessageViews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageViewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageViews
     * const messageViews = await prisma.messageView.findMany()
     * 
     * // Get first 10 MessageViews
     * const messageViews = await prisma.messageView.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageViewWithIdOnly = await prisma.messageView.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageViewFindManyArgs>(args?: SelectSubset<T, MessageViewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageViewPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MessageView.
     * @param {MessageViewCreateArgs} args - Arguments to create a MessageView.
     * @example
     * // Create one MessageView
     * const MessageView = await prisma.messageView.create({
     *   data: {
     *     // ... data to create a MessageView
     *   }
     * })
     * 
     */
    create<T extends MessageViewCreateArgs>(args: SelectSubset<T, MessageViewCreateArgs<ExtArgs>>): Prisma__MessageViewClient<$Result.GetResult<Prisma.$MessageViewPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MessageViews.
     * @param {MessageViewCreateManyArgs} args - Arguments to create many MessageViews.
     * @example
     * // Create many MessageViews
     * const messageView = await prisma.messageView.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageViewCreateManyArgs>(args?: SelectSubset<T, MessageViewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MessageView.
     * @param {MessageViewDeleteArgs} args - Arguments to delete one MessageView.
     * @example
     * // Delete one MessageView
     * const MessageView = await prisma.messageView.delete({
     *   where: {
     *     // ... filter to delete one MessageView
     *   }
     * })
     * 
     */
    delete<T extends MessageViewDeleteArgs>(args: SelectSubset<T, MessageViewDeleteArgs<ExtArgs>>): Prisma__MessageViewClient<$Result.GetResult<Prisma.$MessageViewPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MessageView.
     * @param {MessageViewUpdateArgs} args - Arguments to update one MessageView.
     * @example
     * // Update one MessageView
     * const messageView = await prisma.messageView.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageViewUpdateArgs>(args: SelectSubset<T, MessageViewUpdateArgs<ExtArgs>>): Prisma__MessageViewClient<$Result.GetResult<Prisma.$MessageViewPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MessageViews.
     * @param {MessageViewDeleteManyArgs} args - Arguments to filter MessageViews to delete.
     * @example
     * // Delete a few MessageViews
     * const { count } = await prisma.messageView.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageViewDeleteManyArgs>(args?: SelectSubset<T, MessageViewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageViewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageViews
     * const messageView = await prisma.messageView.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageViewUpdateManyArgs>(args: SelectSubset<T, MessageViewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MessageView.
     * @param {MessageViewUpsertArgs} args - Arguments to update or create a MessageView.
     * @example
     * // Update or create a MessageView
     * const messageView = await prisma.messageView.upsert({
     *   create: {
     *     // ... data to create a MessageView
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageView we want to update
     *   }
     * })
     */
    upsert<T extends MessageViewUpsertArgs>(args: SelectSubset<T, MessageViewUpsertArgs<ExtArgs>>): Prisma__MessageViewClient<$Result.GetResult<Prisma.$MessageViewPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MessageViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageViewCountArgs} args - Arguments to filter MessageViews to count.
     * @example
     * // Count the number of MessageViews
     * const count = await prisma.messageView.count({
     *   where: {
     *     // ... the filter for the MessageViews we want to count
     *   }
     * })
    **/
    count<T extends MessageViewCountArgs>(
      args?: Subset<T, MessageViewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageViewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageViewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageViewAggregateArgs>(args: Subset<T, MessageViewAggregateArgs>): Prisma.PrismaPromise<GetMessageViewAggregateType<T>>

    /**
     * Group by MessageView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageViewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageViewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageViewGroupByArgs['orderBy'] }
        : { orderBy?: MessageViewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageViewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageViewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageView model
   */
  readonly fields: MessageViewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageView.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageViewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message<T extends MessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessageDefaultArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends MessageView$userArgs<ExtArgs> = {}>(args?: Subset<T, MessageView$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessageView model
   */ 
  interface MessageViewFieldRefs {
    readonly id: FieldRef<"MessageView", 'String'>
    readonly messageId: FieldRef<"MessageView", 'String'>
    readonly userId: FieldRef<"MessageView", 'String'>
    readonly viewedAt: FieldRef<"MessageView", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MessageView findUnique
   */
  export type MessageViewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageView
     */
    select?: MessageViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageViewInclude<ExtArgs> | null
    /**
     * Filter, which MessageView to fetch.
     */
    where: MessageViewWhereUniqueInput
  }

  /**
   * MessageView findUniqueOrThrow
   */
  export type MessageViewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageView
     */
    select?: MessageViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageViewInclude<ExtArgs> | null
    /**
     * Filter, which MessageView to fetch.
     */
    where: MessageViewWhereUniqueInput
  }

  /**
   * MessageView findFirst
   */
  export type MessageViewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageView
     */
    select?: MessageViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageViewInclude<ExtArgs> | null
    /**
     * Filter, which MessageView to fetch.
     */
    where?: MessageViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageViews to fetch.
     */
    orderBy?: MessageViewOrderByWithRelationInput | MessageViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageViews.
     */
    cursor?: MessageViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageViews.
     */
    distinct?: MessageViewScalarFieldEnum | MessageViewScalarFieldEnum[]
  }

  /**
   * MessageView findFirstOrThrow
   */
  export type MessageViewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageView
     */
    select?: MessageViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageViewInclude<ExtArgs> | null
    /**
     * Filter, which MessageView to fetch.
     */
    where?: MessageViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageViews to fetch.
     */
    orderBy?: MessageViewOrderByWithRelationInput | MessageViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageViews.
     */
    cursor?: MessageViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageViews.
     */
    distinct?: MessageViewScalarFieldEnum | MessageViewScalarFieldEnum[]
  }

  /**
   * MessageView findMany
   */
  export type MessageViewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageView
     */
    select?: MessageViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageViewInclude<ExtArgs> | null
    /**
     * Filter, which MessageViews to fetch.
     */
    where?: MessageViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageViews to fetch.
     */
    orderBy?: MessageViewOrderByWithRelationInput | MessageViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageViews.
     */
    cursor?: MessageViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageViews.
     */
    skip?: number
    distinct?: MessageViewScalarFieldEnum | MessageViewScalarFieldEnum[]
  }

  /**
   * MessageView create
   */
  export type MessageViewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageView
     */
    select?: MessageViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageViewInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageView.
     */
    data: XOR<MessageViewCreateInput, MessageViewUncheckedCreateInput>
  }

  /**
   * MessageView createMany
   */
  export type MessageViewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageViews.
     */
    data: MessageViewCreateManyInput | MessageViewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageView update
   */
  export type MessageViewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageView
     */
    select?: MessageViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageViewInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageView.
     */
    data: XOR<MessageViewUpdateInput, MessageViewUncheckedUpdateInput>
    /**
     * Choose, which MessageView to update.
     */
    where: MessageViewWhereUniqueInput
  }

  /**
   * MessageView updateMany
   */
  export type MessageViewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageViews.
     */
    data: XOR<MessageViewUpdateManyMutationInput, MessageViewUncheckedUpdateManyInput>
    /**
     * Filter which MessageViews to update
     */
    where?: MessageViewWhereInput
  }

  /**
   * MessageView upsert
   */
  export type MessageViewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageView
     */
    select?: MessageViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageViewInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageView to update in case it exists.
     */
    where: MessageViewWhereUniqueInput
    /**
     * In case the MessageView found by the `where` argument doesn't exist, create a new MessageView with this data.
     */
    create: XOR<MessageViewCreateInput, MessageViewUncheckedCreateInput>
    /**
     * In case the MessageView was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageViewUpdateInput, MessageViewUncheckedUpdateInput>
  }

  /**
   * MessageView delete
   */
  export type MessageViewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageView
     */
    select?: MessageViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageViewInclude<ExtArgs> | null
    /**
     * Filter which MessageView to delete.
     */
    where: MessageViewWhereUniqueInput
  }

  /**
   * MessageView deleteMany
   */
  export type MessageViewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageViews to delete
     */
    where?: MessageViewWhereInput
  }

  /**
   * MessageView.user
   */
  export type MessageView$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * MessageView without action
   */
  export type MessageViewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageView
     */
    select?: MessageViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageViewInclude<ExtArgs> | null
  }


  /**
   * Model ChannelVisit
   */

  export type AggregateChannelVisit = {
    _count: ChannelVisitCountAggregateOutputType | null
    _min: ChannelVisitMinAggregateOutputType | null
    _max: ChannelVisitMaxAggregateOutputType | null
  }

  export type ChannelVisitMinAggregateOutputType = {
    id: string | null
    channelId: string | null
    userId: string | null
    visitedAt: Date | null
  }

  export type ChannelVisitMaxAggregateOutputType = {
    id: string | null
    channelId: string | null
    userId: string | null
    visitedAt: Date | null
  }

  export type ChannelVisitCountAggregateOutputType = {
    id: number
    channelId: number
    userId: number
    visitedAt: number
    _all: number
  }


  export type ChannelVisitMinAggregateInputType = {
    id?: true
    channelId?: true
    userId?: true
    visitedAt?: true
  }

  export type ChannelVisitMaxAggregateInputType = {
    id?: true
    channelId?: true
    userId?: true
    visitedAt?: true
  }

  export type ChannelVisitCountAggregateInputType = {
    id?: true
    channelId?: true
    userId?: true
    visitedAt?: true
    _all?: true
  }

  export type ChannelVisitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChannelVisit to aggregate.
     */
    where?: ChannelVisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelVisits to fetch.
     */
    orderBy?: ChannelVisitOrderByWithRelationInput | ChannelVisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChannelVisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChannelVisits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelVisits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChannelVisits
    **/
    _count?: true | ChannelVisitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChannelVisitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChannelVisitMaxAggregateInputType
  }

  export type GetChannelVisitAggregateType<T extends ChannelVisitAggregateArgs> = {
        [P in keyof T & keyof AggregateChannelVisit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChannelVisit[P]>
      : GetScalarType<T[P], AggregateChannelVisit[P]>
  }




  export type ChannelVisitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelVisitWhereInput
    orderBy?: ChannelVisitOrderByWithAggregationInput | ChannelVisitOrderByWithAggregationInput[]
    by: ChannelVisitScalarFieldEnum[] | ChannelVisitScalarFieldEnum
    having?: ChannelVisitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChannelVisitCountAggregateInputType | true
    _min?: ChannelVisitMinAggregateInputType
    _max?: ChannelVisitMaxAggregateInputType
  }

  export type ChannelVisitGroupByOutputType = {
    id: string
    channelId: string
    userId: string | null
    visitedAt: Date
    _count: ChannelVisitCountAggregateOutputType | null
    _min: ChannelVisitMinAggregateOutputType | null
    _max: ChannelVisitMaxAggregateOutputType | null
  }

  type GetChannelVisitGroupByPayload<T extends ChannelVisitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChannelVisitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChannelVisitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChannelVisitGroupByOutputType[P]>
            : GetScalarType<T[P], ChannelVisitGroupByOutputType[P]>
        }
      >
    >


  export type ChannelVisitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    channelId?: boolean
    userId?: boolean
    visitedAt?: boolean
    channel?: boolean | ChannelDefaultArgs<ExtArgs>
    user?: boolean | ChannelVisit$userArgs<ExtArgs>
  }, ExtArgs["result"]["channelVisit"]>


  export type ChannelVisitSelectScalar = {
    id?: boolean
    channelId?: boolean
    userId?: boolean
    visitedAt?: boolean
  }

  export type ChannelVisitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    channel?: boolean | ChannelDefaultArgs<ExtArgs>
    user?: boolean | ChannelVisit$userArgs<ExtArgs>
  }

  export type $ChannelVisitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChannelVisit"
    objects: {
      channel: Prisma.$ChannelPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      channelId: string
      userId: string | null
      visitedAt: Date
    }, ExtArgs["result"]["channelVisit"]>
    composites: {}
  }

  type ChannelVisitGetPayload<S extends boolean | null | undefined | ChannelVisitDefaultArgs> = $Result.GetResult<Prisma.$ChannelVisitPayload, S>

  type ChannelVisitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChannelVisitFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChannelVisitCountAggregateInputType | true
    }

  export interface ChannelVisitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChannelVisit'], meta: { name: 'ChannelVisit' } }
    /**
     * Find zero or one ChannelVisit that matches the filter.
     * @param {ChannelVisitFindUniqueArgs} args - Arguments to find a ChannelVisit
     * @example
     * // Get one ChannelVisit
     * const channelVisit = await prisma.channelVisit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChannelVisitFindUniqueArgs>(args: SelectSubset<T, ChannelVisitFindUniqueArgs<ExtArgs>>): Prisma__ChannelVisitClient<$Result.GetResult<Prisma.$ChannelVisitPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ChannelVisit that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChannelVisitFindUniqueOrThrowArgs} args - Arguments to find a ChannelVisit
     * @example
     * // Get one ChannelVisit
     * const channelVisit = await prisma.channelVisit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChannelVisitFindUniqueOrThrowArgs>(args: SelectSubset<T, ChannelVisitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChannelVisitClient<$Result.GetResult<Prisma.$ChannelVisitPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ChannelVisit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelVisitFindFirstArgs} args - Arguments to find a ChannelVisit
     * @example
     * // Get one ChannelVisit
     * const channelVisit = await prisma.channelVisit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChannelVisitFindFirstArgs>(args?: SelectSubset<T, ChannelVisitFindFirstArgs<ExtArgs>>): Prisma__ChannelVisitClient<$Result.GetResult<Prisma.$ChannelVisitPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ChannelVisit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelVisitFindFirstOrThrowArgs} args - Arguments to find a ChannelVisit
     * @example
     * // Get one ChannelVisit
     * const channelVisit = await prisma.channelVisit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChannelVisitFindFirstOrThrowArgs>(args?: SelectSubset<T, ChannelVisitFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChannelVisitClient<$Result.GetResult<Prisma.$ChannelVisitPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ChannelVisits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelVisitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChannelVisits
     * const channelVisits = await prisma.channelVisit.findMany()
     * 
     * // Get first 10 ChannelVisits
     * const channelVisits = await prisma.channelVisit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const channelVisitWithIdOnly = await prisma.channelVisit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChannelVisitFindManyArgs>(args?: SelectSubset<T, ChannelVisitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelVisitPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ChannelVisit.
     * @param {ChannelVisitCreateArgs} args - Arguments to create a ChannelVisit.
     * @example
     * // Create one ChannelVisit
     * const ChannelVisit = await prisma.channelVisit.create({
     *   data: {
     *     // ... data to create a ChannelVisit
     *   }
     * })
     * 
     */
    create<T extends ChannelVisitCreateArgs>(args: SelectSubset<T, ChannelVisitCreateArgs<ExtArgs>>): Prisma__ChannelVisitClient<$Result.GetResult<Prisma.$ChannelVisitPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ChannelVisits.
     * @param {ChannelVisitCreateManyArgs} args - Arguments to create many ChannelVisits.
     * @example
     * // Create many ChannelVisits
     * const channelVisit = await prisma.channelVisit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChannelVisitCreateManyArgs>(args?: SelectSubset<T, ChannelVisitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ChannelVisit.
     * @param {ChannelVisitDeleteArgs} args - Arguments to delete one ChannelVisit.
     * @example
     * // Delete one ChannelVisit
     * const ChannelVisit = await prisma.channelVisit.delete({
     *   where: {
     *     // ... filter to delete one ChannelVisit
     *   }
     * })
     * 
     */
    delete<T extends ChannelVisitDeleteArgs>(args: SelectSubset<T, ChannelVisitDeleteArgs<ExtArgs>>): Prisma__ChannelVisitClient<$Result.GetResult<Prisma.$ChannelVisitPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ChannelVisit.
     * @param {ChannelVisitUpdateArgs} args - Arguments to update one ChannelVisit.
     * @example
     * // Update one ChannelVisit
     * const channelVisit = await prisma.channelVisit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChannelVisitUpdateArgs>(args: SelectSubset<T, ChannelVisitUpdateArgs<ExtArgs>>): Prisma__ChannelVisitClient<$Result.GetResult<Prisma.$ChannelVisitPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ChannelVisits.
     * @param {ChannelVisitDeleteManyArgs} args - Arguments to filter ChannelVisits to delete.
     * @example
     * // Delete a few ChannelVisits
     * const { count } = await prisma.channelVisit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChannelVisitDeleteManyArgs>(args?: SelectSubset<T, ChannelVisitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChannelVisits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelVisitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChannelVisits
     * const channelVisit = await prisma.channelVisit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChannelVisitUpdateManyArgs>(args: SelectSubset<T, ChannelVisitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChannelVisit.
     * @param {ChannelVisitUpsertArgs} args - Arguments to update or create a ChannelVisit.
     * @example
     * // Update or create a ChannelVisit
     * const channelVisit = await prisma.channelVisit.upsert({
     *   create: {
     *     // ... data to create a ChannelVisit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChannelVisit we want to update
     *   }
     * })
     */
    upsert<T extends ChannelVisitUpsertArgs>(args: SelectSubset<T, ChannelVisitUpsertArgs<ExtArgs>>): Prisma__ChannelVisitClient<$Result.GetResult<Prisma.$ChannelVisitPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ChannelVisits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelVisitCountArgs} args - Arguments to filter ChannelVisits to count.
     * @example
     * // Count the number of ChannelVisits
     * const count = await prisma.channelVisit.count({
     *   where: {
     *     // ... the filter for the ChannelVisits we want to count
     *   }
     * })
    **/
    count<T extends ChannelVisitCountArgs>(
      args?: Subset<T, ChannelVisitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChannelVisitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChannelVisit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelVisitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChannelVisitAggregateArgs>(args: Subset<T, ChannelVisitAggregateArgs>): Prisma.PrismaPromise<GetChannelVisitAggregateType<T>>

    /**
     * Group by ChannelVisit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelVisitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChannelVisitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChannelVisitGroupByArgs['orderBy'] }
        : { orderBy?: ChannelVisitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChannelVisitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChannelVisitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChannelVisit model
   */
  readonly fields: ChannelVisitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChannelVisit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChannelVisitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    channel<T extends ChannelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChannelDefaultArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends ChannelVisit$userArgs<ExtArgs> = {}>(args?: Subset<T, ChannelVisit$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChannelVisit model
   */ 
  interface ChannelVisitFieldRefs {
    readonly id: FieldRef<"ChannelVisit", 'String'>
    readonly channelId: FieldRef<"ChannelVisit", 'String'>
    readonly userId: FieldRef<"ChannelVisit", 'String'>
    readonly visitedAt: FieldRef<"ChannelVisit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChannelVisit findUnique
   */
  export type ChannelVisitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelVisit
     */
    select?: ChannelVisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelVisitInclude<ExtArgs> | null
    /**
     * Filter, which ChannelVisit to fetch.
     */
    where: ChannelVisitWhereUniqueInput
  }

  /**
   * ChannelVisit findUniqueOrThrow
   */
  export type ChannelVisitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelVisit
     */
    select?: ChannelVisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelVisitInclude<ExtArgs> | null
    /**
     * Filter, which ChannelVisit to fetch.
     */
    where: ChannelVisitWhereUniqueInput
  }

  /**
   * ChannelVisit findFirst
   */
  export type ChannelVisitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelVisit
     */
    select?: ChannelVisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelVisitInclude<ExtArgs> | null
    /**
     * Filter, which ChannelVisit to fetch.
     */
    where?: ChannelVisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelVisits to fetch.
     */
    orderBy?: ChannelVisitOrderByWithRelationInput | ChannelVisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChannelVisits.
     */
    cursor?: ChannelVisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChannelVisits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelVisits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChannelVisits.
     */
    distinct?: ChannelVisitScalarFieldEnum | ChannelVisitScalarFieldEnum[]
  }

  /**
   * ChannelVisit findFirstOrThrow
   */
  export type ChannelVisitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelVisit
     */
    select?: ChannelVisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelVisitInclude<ExtArgs> | null
    /**
     * Filter, which ChannelVisit to fetch.
     */
    where?: ChannelVisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelVisits to fetch.
     */
    orderBy?: ChannelVisitOrderByWithRelationInput | ChannelVisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChannelVisits.
     */
    cursor?: ChannelVisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChannelVisits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelVisits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChannelVisits.
     */
    distinct?: ChannelVisitScalarFieldEnum | ChannelVisitScalarFieldEnum[]
  }

  /**
   * ChannelVisit findMany
   */
  export type ChannelVisitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelVisit
     */
    select?: ChannelVisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelVisitInclude<ExtArgs> | null
    /**
     * Filter, which ChannelVisits to fetch.
     */
    where?: ChannelVisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelVisits to fetch.
     */
    orderBy?: ChannelVisitOrderByWithRelationInput | ChannelVisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChannelVisits.
     */
    cursor?: ChannelVisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChannelVisits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelVisits.
     */
    skip?: number
    distinct?: ChannelVisitScalarFieldEnum | ChannelVisitScalarFieldEnum[]
  }

  /**
   * ChannelVisit create
   */
  export type ChannelVisitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelVisit
     */
    select?: ChannelVisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelVisitInclude<ExtArgs> | null
    /**
     * The data needed to create a ChannelVisit.
     */
    data: XOR<ChannelVisitCreateInput, ChannelVisitUncheckedCreateInput>
  }

  /**
   * ChannelVisit createMany
   */
  export type ChannelVisitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChannelVisits.
     */
    data: ChannelVisitCreateManyInput | ChannelVisitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChannelVisit update
   */
  export type ChannelVisitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelVisit
     */
    select?: ChannelVisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelVisitInclude<ExtArgs> | null
    /**
     * The data needed to update a ChannelVisit.
     */
    data: XOR<ChannelVisitUpdateInput, ChannelVisitUncheckedUpdateInput>
    /**
     * Choose, which ChannelVisit to update.
     */
    where: ChannelVisitWhereUniqueInput
  }

  /**
   * ChannelVisit updateMany
   */
  export type ChannelVisitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChannelVisits.
     */
    data: XOR<ChannelVisitUpdateManyMutationInput, ChannelVisitUncheckedUpdateManyInput>
    /**
     * Filter which ChannelVisits to update
     */
    where?: ChannelVisitWhereInput
  }

  /**
   * ChannelVisit upsert
   */
  export type ChannelVisitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelVisit
     */
    select?: ChannelVisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelVisitInclude<ExtArgs> | null
    /**
     * The filter to search for the ChannelVisit to update in case it exists.
     */
    where: ChannelVisitWhereUniqueInput
    /**
     * In case the ChannelVisit found by the `where` argument doesn't exist, create a new ChannelVisit with this data.
     */
    create: XOR<ChannelVisitCreateInput, ChannelVisitUncheckedCreateInput>
    /**
     * In case the ChannelVisit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChannelVisitUpdateInput, ChannelVisitUncheckedUpdateInput>
  }

  /**
   * ChannelVisit delete
   */
  export type ChannelVisitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelVisit
     */
    select?: ChannelVisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelVisitInclude<ExtArgs> | null
    /**
     * Filter which ChannelVisit to delete.
     */
    where: ChannelVisitWhereUniqueInput
  }

  /**
   * ChannelVisit deleteMany
   */
  export type ChannelVisitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChannelVisits to delete
     */
    where?: ChannelVisitWhereInput
  }

  /**
   * ChannelVisit.user
   */
  export type ChannelVisit$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ChannelVisit without action
   */
  export type ChannelVisitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelVisit
     */
    select?: ChannelVisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelVisitInclude<ExtArgs> | null
  }


  /**
   * Model Form
   */

  export type AggregateForm = {
    _count: FormCountAggregateOutputType | null
    _min: FormMinAggregateOutputType | null
    _max: FormMaxAggregateOutputType | null
  }

  export type FormMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    slug: string | null
    headerContent: string | null
    footerContent: string | null
    successMessage: string | null
    isActive: boolean | null
    isPublished: boolean | null
    wasPublished: boolean | null
    isDeleted: boolean | null
    collectUserInfo: boolean | null
    expiresAt: Date | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FormMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    slug: string | null
    headerContent: string | null
    footerContent: string | null
    successMessage: string | null
    isActive: boolean | null
    isPublished: boolean | null
    wasPublished: boolean | null
    isDeleted: boolean | null
    collectUserInfo: boolean | null
    expiresAt: Date | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FormCountAggregateOutputType = {
    id: number
    title: number
    description: number
    slug: number
    headerContent: number
    footerContent: number
    successMessage: number
    isActive: number
    isPublished: number
    wasPublished: number
    isDeleted: number
    collectUserInfo: number
    expiresAt: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FormMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    slug?: true
    headerContent?: true
    footerContent?: true
    successMessage?: true
    isActive?: true
    isPublished?: true
    wasPublished?: true
    isDeleted?: true
    collectUserInfo?: true
    expiresAt?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FormMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    slug?: true
    headerContent?: true
    footerContent?: true
    successMessage?: true
    isActive?: true
    isPublished?: true
    wasPublished?: true
    isDeleted?: true
    collectUserInfo?: true
    expiresAt?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FormCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    slug?: true
    headerContent?: true
    footerContent?: true
    successMessage?: true
    isActive?: true
    isPublished?: true
    wasPublished?: true
    isDeleted?: true
    collectUserInfo?: true
    expiresAt?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FormAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Form to aggregate.
     */
    where?: FormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Forms to fetch.
     */
    orderBy?: FormOrderByWithRelationInput | FormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Forms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Forms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Forms
    **/
    _count?: true | FormCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormMaxAggregateInputType
  }

  export type GetFormAggregateType<T extends FormAggregateArgs> = {
        [P in keyof T & keyof AggregateForm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForm[P]>
      : GetScalarType<T[P], AggregateForm[P]>
  }




  export type FormGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormWhereInput
    orderBy?: FormOrderByWithAggregationInput | FormOrderByWithAggregationInput[]
    by: FormScalarFieldEnum[] | FormScalarFieldEnum
    having?: FormScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormCountAggregateInputType | true
    _min?: FormMinAggregateInputType
    _max?: FormMaxAggregateInputType
  }

  export type FormGroupByOutputType = {
    id: string
    title: string
    description: string | null
    slug: string
    headerContent: string | null
    footerContent: string | null
    successMessage: string | null
    isActive: boolean
    isPublished: boolean
    wasPublished: boolean
    isDeleted: boolean
    collectUserInfo: boolean
    expiresAt: Date | null
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: FormCountAggregateOutputType | null
    _min: FormMinAggregateOutputType | null
    _max: FormMaxAggregateOutputType | null
  }

  type GetFormGroupByPayload<T extends FormGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormGroupByOutputType[P]>
            : GetScalarType<T[P], FormGroupByOutputType[P]>
        }
      >
    >


  export type FormSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    slug?: boolean
    headerContent?: boolean
    footerContent?: boolean
    successMessage?: boolean
    isActive?: boolean
    isPublished?: boolean
    wasPublished?: boolean
    isDeleted?: boolean
    collectUserInfo?: boolean
    expiresAt?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    fields?: boolean | Form$fieldsArgs<ExtArgs>
    submissions?: boolean | Form$submissionsArgs<ExtArgs>
    _count?: boolean | FormCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["form"]>


  export type FormSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    slug?: boolean
    headerContent?: boolean
    footerContent?: boolean
    successMessage?: boolean
    isActive?: boolean
    isPublished?: boolean
    wasPublished?: boolean
    isDeleted?: boolean
    collectUserInfo?: boolean
    expiresAt?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FormInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    fields?: boolean | Form$fieldsArgs<ExtArgs>
    submissions?: boolean | Form$submissionsArgs<ExtArgs>
    _count?: boolean | FormCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $FormPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Form"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      fields: Prisma.$FormFieldPayload<ExtArgs>[]
      submissions: Prisma.$FormSubmissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      slug: string
      headerContent: string | null
      footerContent: string | null
      successMessage: string | null
      isActive: boolean
      isPublished: boolean
      wasPublished: boolean
      isDeleted: boolean
      collectUserInfo: boolean
      expiresAt: Date | null
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["form"]>
    composites: {}
  }

  type FormGetPayload<S extends boolean | null | undefined | FormDefaultArgs> = $Result.GetResult<Prisma.$FormPayload, S>

  type FormCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FormFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FormCountAggregateInputType | true
    }

  export interface FormDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Form'], meta: { name: 'Form' } }
    /**
     * Find zero or one Form that matches the filter.
     * @param {FormFindUniqueArgs} args - Arguments to find a Form
     * @example
     * // Get one Form
     * const form = await prisma.form.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FormFindUniqueArgs>(args: SelectSubset<T, FormFindUniqueArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Form that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FormFindUniqueOrThrowArgs} args - Arguments to find a Form
     * @example
     * // Get one Form
     * const form = await prisma.form.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FormFindUniqueOrThrowArgs>(args: SelectSubset<T, FormFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Form that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFindFirstArgs} args - Arguments to find a Form
     * @example
     * // Get one Form
     * const form = await prisma.form.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FormFindFirstArgs>(args?: SelectSubset<T, FormFindFirstArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Form that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFindFirstOrThrowArgs} args - Arguments to find a Form
     * @example
     * // Get one Form
     * const form = await prisma.form.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FormFindFirstOrThrowArgs>(args?: SelectSubset<T, FormFindFirstOrThrowArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Forms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Forms
     * const forms = await prisma.form.findMany()
     * 
     * // Get first 10 Forms
     * const forms = await prisma.form.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formWithIdOnly = await prisma.form.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FormFindManyArgs>(args?: SelectSubset<T, FormFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Form.
     * @param {FormCreateArgs} args - Arguments to create a Form.
     * @example
     * // Create one Form
     * const Form = await prisma.form.create({
     *   data: {
     *     // ... data to create a Form
     *   }
     * })
     * 
     */
    create<T extends FormCreateArgs>(args: SelectSubset<T, FormCreateArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Forms.
     * @param {FormCreateManyArgs} args - Arguments to create many Forms.
     * @example
     * // Create many Forms
     * const form = await prisma.form.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FormCreateManyArgs>(args?: SelectSubset<T, FormCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Form.
     * @param {FormDeleteArgs} args - Arguments to delete one Form.
     * @example
     * // Delete one Form
     * const Form = await prisma.form.delete({
     *   where: {
     *     // ... filter to delete one Form
     *   }
     * })
     * 
     */
    delete<T extends FormDeleteArgs>(args: SelectSubset<T, FormDeleteArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Form.
     * @param {FormUpdateArgs} args - Arguments to update one Form.
     * @example
     * // Update one Form
     * const form = await prisma.form.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FormUpdateArgs>(args: SelectSubset<T, FormUpdateArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Forms.
     * @param {FormDeleteManyArgs} args - Arguments to filter Forms to delete.
     * @example
     * // Delete a few Forms
     * const { count } = await prisma.form.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FormDeleteManyArgs>(args?: SelectSubset<T, FormDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Forms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Forms
     * const form = await prisma.form.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FormUpdateManyArgs>(args: SelectSubset<T, FormUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Form.
     * @param {FormUpsertArgs} args - Arguments to update or create a Form.
     * @example
     * // Update or create a Form
     * const form = await prisma.form.upsert({
     *   create: {
     *     // ... data to create a Form
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Form we want to update
     *   }
     * })
     */
    upsert<T extends FormUpsertArgs>(args: SelectSubset<T, FormUpsertArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Forms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormCountArgs} args - Arguments to filter Forms to count.
     * @example
     * // Count the number of Forms
     * const count = await prisma.form.count({
     *   where: {
     *     // ... the filter for the Forms we want to count
     *   }
     * })
    **/
    count<T extends FormCountArgs>(
      args?: Subset<T, FormCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Form.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormAggregateArgs>(args: Subset<T, FormAggregateArgs>): Prisma.PrismaPromise<GetFormAggregateType<T>>

    /**
     * Group by Form.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormGroupByArgs['orderBy'] }
        : { orderBy?: FormGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Form model
   */
  readonly fields: FormFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Form.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FormClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    fields<T extends Form$fieldsArgs<ExtArgs> = {}>(args?: Subset<T, Form$fieldsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormFieldPayload<ExtArgs>, T, "findMany"> | Null>
    submissions<T extends Form$submissionsArgs<ExtArgs> = {}>(args?: Subset<T, Form$submissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Form model
   */ 
  interface FormFieldRefs {
    readonly id: FieldRef<"Form", 'String'>
    readonly title: FieldRef<"Form", 'String'>
    readonly description: FieldRef<"Form", 'String'>
    readonly slug: FieldRef<"Form", 'String'>
    readonly headerContent: FieldRef<"Form", 'String'>
    readonly footerContent: FieldRef<"Form", 'String'>
    readonly successMessage: FieldRef<"Form", 'String'>
    readonly isActive: FieldRef<"Form", 'Boolean'>
    readonly isPublished: FieldRef<"Form", 'Boolean'>
    readonly wasPublished: FieldRef<"Form", 'Boolean'>
    readonly isDeleted: FieldRef<"Form", 'Boolean'>
    readonly collectUserInfo: FieldRef<"Form", 'Boolean'>
    readonly expiresAt: FieldRef<"Form", 'DateTime'>
    readonly userId: FieldRef<"Form", 'String'>
    readonly createdAt: FieldRef<"Form", 'DateTime'>
    readonly updatedAt: FieldRef<"Form", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Form findUnique
   */
  export type FormFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * Filter, which Form to fetch.
     */
    where: FormWhereUniqueInput
  }

  /**
   * Form findUniqueOrThrow
   */
  export type FormFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * Filter, which Form to fetch.
     */
    where: FormWhereUniqueInput
  }

  /**
   * Form findFirst
   */
  export type FormFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * Filter, which Form to fetch.
     */
    where?: FormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Forms to fetch.
     */
    orderBy?: FormOrderByWithRelationInput | FormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Forms.
     */
    cursor?: FormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Forms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Forms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Forms.
     */
    distinct?: FormScalarFieldEnum | FormScalarFieldEnum[]
  }

  /**
   * Form findFirstOrThrow
   */
  export type FormFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * Filter, which Form to fetch.
     */
    where?: FormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Forms to fetch.
     */
    orderBy?: FormOrderByWithRelationInput | FormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Forms.
     */
    cursor?: FormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Forms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Forms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Forms.
     */
    distinct?: FormScalarFieldEnum | FormScalarFieldEnum[]
  }

  /**
   * Form findMany
   */
  export type FormFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * Filter, which Forms to fetch.
     */
    where?: FormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Forms to fetch.
     */
    orderBy?: FormOrderByWithRelationInput | FormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Forms.
     */
    cursor?: FormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Forms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Forms.
     */
    skip?: number
    distinct?: FormScalarFieldEnum | FormScalarFieldEnum[]
  }

  /**
   * Form create
   */
  export type FormCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * The data needed to create a Form.
     */
    data: XOR<FormCreateInput, FormUncheckedCreateInput>
  }

  /**
   * Form createMany
   */
  export type FormCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Forms.
     */
    data: FormCreateManyInput | FormCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Form update
   */
  export type FormUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * The data needed to update a Form.
     */
    data: XOR<FormUpdateInput, FormUncheckedUpdateInput>
    /**
     * Choose, which Form to update.
     */
    where: FormWhereUniqueInput
  }

  /**
   * Form updateMany
   */
  export type FormUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Forms.
     */
    data: XOR<FormUpdateManyMutationInput, FormUncheckedUpdateManyInput>
    /**
     * Filter which Forms to update
     */
    where?: FormWhereInput
  }

  /**
   * Form upsert
   */
  export type FormUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * The filter to search for the Form to update in case it exists.
     */
    where: FormWhereUniqueInput
    /**
     * In case the Form found by the `where` argument doesn't exist, create a new Form with this data.
     */
    create: XOR<FormCreateInput, FormUncheckedCreateInput>
    /**
     * In case the Form was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FormUpdateInput, FormUncheckedUpdateInput>
  }

  /**
   * Form delete
   */
  export type FormDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * Filter which Form to delete.
     */
    where: FormWhereUniqueInput
  }

  /**
   * Form deleteMany
   */
  export type FormDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Forms to delete
     */
    where?: FormWhereInput
  }

  /**
   * Form.fields
   */
  export type Form$fieldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormField
     */
    select?: FormFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFieldInclude<ExtArgs> | null
    where?: FormFieldWhereInput
    orderBy?: FormFieldOrderByWithRelationInput | FormFieldOrderByWithRelationInput[]
    cursor?: FormFieldWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormFieldScalarFieldEnum | FormFieldScalarFieldEnum[]
  }

  /**
   * Form.submissions
   */
  export type Form$submissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    where?: FormSubmissionWhereInput
    orderBy?: FormSubmissionOrderByWithRelationInput | FormSubmissionOrderByWithRelationInput[]
    cursor?: FormSubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormSubmissionScalarFieldEnum | FormSubmissionScalarFieldEnum[]
  }

  /**
   * Form without action
   */
  export type FormDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
  }


  /**
   * Model FormField
   */

  export type AggregateFormField = {
    _count: FormFieldCountAggregateOutputType | null
    _avg: FormFieldAvgAggregateOutputType | null
    _sum: FormFieldSumAggregateOutputType | null
    _min: FormFieldMinAggregateOutputType | null
    _max: FormFieldMaxAggregateOutputType | null
  }

  export type FormFieldAvgAggregateOutputType = {
    order: number | null
  }

  export type FormFieldSumAggregateOutputType = {
    order: number | null
  }

  export type FormFieldMinAggregateOutputType = {
    id: string | null
    formId: string | null
    type: string | null
    label: string | null
    placeholder: string | null
    required: boolean | null
    isHidden: boolean | null
    order: number | null
    createdAt: Date | null
  }

  export type FormFieldMaxAggregateOutputType = {
    id: string | null
    formId: string | null
    type: string | null
    label: string | null
    placeholder: string | null
    required: boolean | null
    isHidden: boolean | null
    order: number | null
    createdAt: Date | null
  }

  export type FormFieldCountAggregateOutputType = {
    id: number
    formId: number
    type: number
    label: number
    placeholder: number
    required: number
    isHidden: number
    options: number
    order: number
    createdAt: number
    _all: number
  }


  export type FormFieldAvgAggregateInputType = {
    order?: true
  }

  export type FormFieldSumAggregateInputType = {
    order?: true
  }

  export type FormFieldMinAggregateInputType = {
    id?: true
    formId?: true
    type?: true
    label?: true
    placeholder?: true
    required?: true
    isHidden?: true
    order?: true
    createdAt?: true
  }

  export type FormFieldMaxAggregateInputType = {
    id?: true
    formId?: true
    type?: true
    label?: true
    placeholder?: true
    required?: true
    isHidden?: true
    order?: true
    createdAt?: true
  }

  export type FormFieldCountAggregateInputType = {
    id?: true
    formId?: true
    type?: true
    label?: true
    placeholder?: true
    required?: true
    isHidden?: true
    options?: true
    order?: true
    createdAt?: true
    _all?: true
  }

  export type FormFieldAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormField to aggregate.
     */
    where?: FormFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormFields to fetch.
     */
    orderBy?: FormFieldOrderByWithRelationInput | FormFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FormFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FormFields
    **/
    _count?: true | FormFieldCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FormFieldAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FormFieldSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormFieldMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormFieldMaxAggregateInputType
  }

  export type GetFormFieldAggregateType<T extends FormFieldAggregateArgs> = {
        [P in keyof T & keyof AggregateFormField]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormField[P]>
      : GetScalarType<T[P], AggregateFormField[P]>
  }




  export type FormFieldGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormFieldWhereInput
    orderBy?: FormFieldOrderByWithAggregationInput | FormFieldOrderByWithAggregationInput[]
    by: FormFieldScalarFieldEnum[] | FormFieldScalarFieldEnum
    having?: FormFieldScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormFieldCountAggregateInputType | true
    _avg?: FormFieldAvgAggregateInputType
    _sum?: FormFieldSumAggregateInputType
    _min?: FormFieldMinAggregateInputType
    _max?: FormFieldMaxAggregateInputType
  }

  export type FormFieldGroupByOutputType = {
    id: string
    formId: string
    type: string
    label: string
    placeholder: string | null
    required: boolean
    isHidden: boolean
    options: JsonValue | null
    order: number
    createdAt: Date
    _count: FormFieldCountAggregateOutputType | null
    _avg: FormFieldAvgAggregateOutputType | null
    _sum: FormFieldSumAggregateOutputType | null
    _min: FormFieldMinAggregateOutputType | null
    _max: FormFieldMaxAggregateOutputType | null
  }

  type GetFormFieldGroupByPayload<T extends FormFieldGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormFieldGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormFieldGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormFieldGroupByOutputType[P]>
            : GetScalarType<T[P], FormFieldGroupByOutputType[P]>
        }
      >
    >


  export type FormFieldSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    formId?: boolean
    type?: boolean
    label?: boolean
    placeholder?: boolean
    required?: boolean
    isHidden?: boolean
    options?: boolean
    order?: boolean
    createdAt?: boolean
    form?: boolean | FormDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formField"]>


  export type FormFieldSelectScalar = {
    id?: boolean
    formId?: boolean
    type?: boolean
    label?: boolean
    placeholder?: boolean
    required?: boolean
    isHidden?: boolean
    options?: boolean
    order?: boolean
    createdAt?: boolean
  }

  export type FormFieldInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    form?: boolean | FormDefaultArgs<ExtArgs>
  }

  export type $FormFieldPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FormField"
    objects: {
      form: Prisma.$FormPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      formId: string
      type: string
      label: string
      placeholder: string | null
      required: boolean
      isHidden: boolean
      options: Prisma.JsonValue | null
      order: number
      createdAt: Date
    }, ExtArgs["result"]["formField"]>
    composites: {}
  }

  type FormFieldGetPayload<S extends boolean | null | undefined | FormFieldDefaultArgs> = $Result.GetResult<Prisma.$FormFieldPayload, S>

  type FormFieldCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FormFieldFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FormFieldCountAggregateInputType | true
    }

  export interface FormFieldDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FormField'], meta: { name: 'FormField' } }
    /**
     * Find zero or one FormField that matches the filter.
     * @param {FormFieldFindUniqueArgs} args - Arguments to find a FormField
     * @example
     * // Get one FormField
     * const formField = await prisma.formField.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FormFieldFindUniqueArgs>(args: SelectSubset<T, FormFieldFindUniqueArgs<ExtArgs>>): Prisma__FormFieldClient<$Result.GetResult<Prisma.$FormFieldPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FormField that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FormFieldFindUniqueOrThrowArgs} args - Arguments to find a FormField
     * @example
     * // Get one FormField
     * const formField = await prisma.formField.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FormFieldFindUniqueOrThrowArgs>(args: SelectSubset<T, FormFieldFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FormFieldClient<$Result.GetResult<Prisma.$FormFieldPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FormField that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFieldFindFirstArgs} args - Arguments to find a FormField
     * @example
     * // Get one FormField
     * const formField = await prisma.formField.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FormFieldFindFirstArgs>(args?: SelectSubset<T, FormFieldFindFirstArgs<ExtArgs>>): Prisma__FormFieldClient<$Result.GetResult<Prisma.$FormFieldPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FormField that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFieldFindFirstOrThrowArgs} args - Arguments to find a FormField
     * @example
     * // Get one FormField
     * const formField = await prisma.formField.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FormFieldFindFirstOrThrowArgs>(args?: SelectSubset<T, FormFieldFindFirstOrThrowArgs<ExtArgs>>): Prisma__FormFieldClient<$Result.GetResult<Prisma.$FormFieldPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FormFields that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFieldFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FormFields
     * const formFields = await prisma.formField.findMany()
     * 
     * // Get first 10 FormFields
     * const formFields = await prisma.formField.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formFieldWithIdOnly = await prisma.formField.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FormFieldFindManyArgs>(args?: SelectSubset<T, FormFieldFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormFieldPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FormField.
     * @param {FormFieldCreateArgs} args - Arguments to create a FormField.
     * @example
     * // Create one FormField
     * const FormField = await prisma.formField.create({
     *   data: {
     *     // ... data to create a FormField
     *   }
     * })
     * 
     */
    create<T extends FormFieldCreateArgs>(args: SelectSubset<T, FormFieldCreateArgs<ExtArgs>>): Prisma__FormFieldClient<$Result.GetResult<Prisma.$FormFieldPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FormFields.
     * @param {FormFieldCreateManyArgs} args - Arguments to create many FormFields.
     * @example
     * // Create many FormFields
     * const formField = await prisma.formField.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FormFieldCreateManyArgs>(args?: SelectSubset<T, FormFieldCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FormField.
     * @param {FormFieldDeleteArgs} args - Arguments to delete one FormField.
     * @example
     * // Delete one FormField
     * const FormField = await prisma.formField.delete({
     *   where: {
     *     // ... filter to delete one FormField
     *   }
     * })
     * 
     */
    delete<T extends FormFieldDeleteArgs>(args: SelectSubset<T, FormFieldDeleteArgs<ExtArgs>>): Prisma__FormFieldClient<$Result.GetResult<Prisma.$FormFieldPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FormField.
     * @param {FormFieldUpdateArgs} args - Arguments to update one FormField.
     * @example
     * // Update one FormField
     * const formField = await prisma.formField.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FormFieldUpdateArgs>(args: SelectSubset<T, FormFieldUpdateArgs<ExtArgs>>): Prisma__FormFieldClient<$Result.GetResult<Prisma.$FormFieldPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FormFields.
     * @param {FormFieldDeleteManyArgs} args - Arguments to filter FormFields to delete.
     * @example
     * // Delete a few FormFields
     * const { count } = await prisma.formField.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FormFieldDeleteManyArgs>(args?: SelectSubset<T, FormFieldDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFieldUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FormFields
     * const formField = await prisma.formField.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FormFieldUpdateManyArgs>(args: SelectSubset<T, FormFieldUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FormField.
     * @param {FormFieldUpsertArgs} args - Arguments to update or create a FormField.
     * @example
     * // Update or create a FormField
     * const formField = await prisma.formField.upsert({
     *   create: {
     *     // ... data to create a FormField
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FormField we want to update
     *   }
     * })
     */
    upsert<T extends FormFieldUpsertArgs>(args: SelectSubset<T, FormFieldUpsertArgs<ExtArgs>>): Prisma__FormFieldClient<$Result.GetResult<Prisma.$FormFieldPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FormFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFieldCountArgs} args - Arguments to filter FormFields to count.
     * @example
     * // Count the number of FormFields
     * const count = await prisma.formField.count({
     *   where: {
     *     // ... the filter for the FormFields we want to count
     *   }
     * })
    **/
    count<T extends FormFieldCountArgs>(
      args?: Subset<T, FormFieldCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormFieldCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FormField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFieldAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormFieldAggregateArgs>(args: Subset<T, FormFieldAggregateArgs>): Prisma.PrismaPromise<GetFormFieldAggregateType<T>>

    /**
     * Group by FormField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFieldGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormFieldGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormFieldGroupByArgs['orderBy'] }
        : { orderBy?: FormFieldGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormFieldGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormFieldGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FormField model
   */
  readonly fields: FormFieldFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FormField.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FormFieldClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    form<T extends FormDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FormDefaultArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FormField model
   */ 
  interface FormFieldFieldRefs {
    readonly id: FieldRef<"FormField", 'String'>
    readonly formId: FieldRef<"FormField", 'String'>
    readonly type: FieldRef<"FormField", 'String'>
    readonly label: FieldRef<"FormField", 'String'>
    readonly placeholder: FieldRef<"FormField", 'String'>
    readonly required: FieldRef<"FormField", 'Boolean'>
    readonly isHidden: FieldRef<"FormField", 'Boolean'>
    readonly options: FieldRef<"FormField", 'Json'>
    readonly order: FieldRef<"FormField", 'Int'>
    readonly createdAt: FieldRef<"FormField", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FormField findUnique
   */
  export type FormFieldFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormField
     */
    select?: FormFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFieldInclude<ExtArgs> | null
    /**
     * Filter, which FormField to fetch.
     */
    where: FormFieldWhereUniqueInput
  }

  /**
   * FormField findUniqueOrThrow
   */
  export type FormFieldFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormField
     */
    select?: FormFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFieldInclude<ExtArgs> | null
    /**
     * Filter, which FormField to fetch.
     */
    where: FormFieldWhereUniqueInput
  }

  /**
   * FormField findFirst
   */
  export type FormFieldFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormField
     */
    select?: FormFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFieldInclude<ExtArgs> | null
    /**
     * Filter, which FormField to fetch.
     */
    where?: FormFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormFields to fetch.
     */
    orderBy?: FormFieldOrderByWithRelationInput | FormFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormFields.
     */
    cursor?: FormFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormFields.
     */
    distinct?: FormFieldScalarFieldEnum | FormFieldScalarFieldEnum[]
  }

  /**
   * FormField findFirstOrThrow
   */
  export type FormFieldFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormField
     */
    select?: FormFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFieldInclude<ExtArgs> | null
    /**
     * Filter, which FormField to fetch.
     */
    where?: FormFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormFields to fetch.
     */
    orderBy?: FormFieldOrderByWithRelationInput | FormFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormFields.
     */
    cursor?: FormFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormFields.
     */
    distinct?: FormFieldScalarFieldEnum | FormFieldScalarFieldEnum[]
  }

  /**
   * FormField findMany
   */
  export type FormFieldFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormField
     */
    select?: FormFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFieldInclude<ExtArgs> | null
    /**
     * Filter, which FormFields to fetch.
     */
    where?: FormFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormFields to fetch.
     */
    orderBy?: FormFieldOrderByWithRelationInput | FormFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FormFields.
     */
    cursor?: FormFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormFields.
     */
    skip?: number
    distinct?: FormFieldScalarFieldEnum | FormFieldScalarFieldEnum[]
  }

  /**
   * FormField create
   */
  export type FormFieldCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormField
     */
    select?: FormFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFieldInclude<ExtArgs> | null
    /**
     * The data needed to create a FormField.
     */
    data: XOR<FormFieldCreateInput, FormFieldUncheckedCreateInput>
  }

  /**
   * FormField createMany
   */
  export type FormFieldCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FormFields.
     */
    data: FormFieldCreateManyInput | FormFieldCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FormField update
   */
  export type FormFieldUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormField
     */
    select?: FormFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFieldInclude<ExtArgs> | null
    /**
     * The data needed to update a FormField.
     */
    data: XOR<FormFieldUpdateInput, FormFieldUncheckedUpdateInput>
    /**
     * Choose, which FormField to update.
     */
    where: FormFieldWhereUniqueInput
  }

  /**
   * FormField updateMany
   */
  export type FormFieldUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FormFields.
     */
    data: XOR<FormFieldUpdateManyMutationInput, FormFieldUncheckedUpdateManyInput>
    /**
     * Filter which FormFields to update
     */
    where?: FormFieldWhereInput
  }

  /**
   * FormField upsert
   */
  export type FormFieldUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormField
     */
    select?: FormFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFieldInclude<ExtArgs> | null
    /**
     * The filter to search for the FormField to update in case it exists.
     */
    where: FormFieldWhereUniqueInput
    /**
     * In case the FormField found by the `where` argument doesn't exist, create a new FormField with this data.
     */
    create: XOR<FormFieldCreateInput, FormFieldUncheckedCreateInput>
    /**
     * In case the FormField was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FormFieldUpdateInput, FormFieldUncheckedUpdateInput>
  }

  /**
   * FormField delete
   */
  export type FormFieldDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormField
     */
    select?: FormFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFieldInclude<ExtArgs> | null
    /**
     * Filter which FormField to delete.
     */
    where: FormFieldWhereUniqueInput
  }

  /**
   * FormField deleteMany
   */
  export type FormFieldDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormFields to delete
     */
    where?: FormFieldWhereInput
  }

  /**
   * FormField without action
   */
  export type FormFieldDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormField
     */
    select?: FormFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFieldInclude<ExtArgs> | null
  }


  /**
   * Model FormSubmission
   */

  export type AggregateFormSubmission = {
    _count: FormSubmissionCountAggregateOutputType | null
    _min: FormSubmissionMinAggregateOutputType | null
    _max: FormSubmissionMaxAggregateOutputType | null
  }

  export type FormSubmissionMinAggregateOutputType = {
    id: string | null
    formId: string | null
    ipAddress: string | null
    country: string | null
    city: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type FormSubmissionMaxAggregateOutputType = {
    id: string | null
    formId: string | null
    ipAddress: string | null
    country: string | null
    city: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type FormSubmissionCountAggregateOutputType = {
    id: number
    formId: number
    data: number
    ipAddress: number
    country: number
    city: number
    userAgent: number
    deviceInfo: number
    createdAt: number
    _all: number
  }


  export type FormSubmissionMinAggregateInputType = {
    id?: true
    formId?: true
    ipAddress?: true
    country?: true
    city?: true
    userAgent?: true
    createdAt?: true
  }

  export type FormSubmissionMaxAggregateInputType = {
    id?: true
    formId?: true
    ipAddress?: true
    country?: true
    city?: true
    userAgent?: true
    createdAt?: true
  }

  export type FormSubmissionCountAggregateInputType = {
    id?: true
    formId?: true
    data?: true
    ipAddress?: true
    country?: true
    city?: true
    userAgent?: true
    deviceInfo?: true
    createdAt?: true
    _all?: true
  }

  export type FormSubmissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormSubmission to aggregate.
     */
    where?: FormSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormSubmissions to fetch.
     */
    orderBy?: FormSubmissionOrderByWithRelationInput | FormSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FormSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FormSubmissions
    **/
    _count?: true | FormSubmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormSubmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormSubmissionMaxAggregateInputType
  }

  export type GetFormSubmissionAggregateType<T extends FormSubmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateFormSubmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormSubmission[P]>
      : GetScalarType<T[P], AggregateFormSubmission[P]>
  }




  export type FormSubmissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormSubmissionWhereInput
    orderBy?: FormSubmissionOrderByWithAggregationInput | FormSubmissionOrderByWithAggregationInput[]
    by: FormSubmissionScalarFieldEnum[] | FormSubmissionScalarFieldEnum
    having?: FormSubmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormSubmissionCountAggregateInputType | true
    _min?: FormSubmissionMinAggregateInputType
    _max?: FormSubmissionMaxAggregateInputType
  }

  export type FormSubmissionGroupByOutputType = {
    id: string
    formId: string
    data: JsonValue
    ipAddress: string | null
    country: string | null
    city: string | null
    userAgent: string | null
    deviceInfo: JsonValue | null
    createdAt: Date
    _count: FormSubmissionCountAggregateOutputType | null
    _min: FormSubmissionMinAggregateOutputType | null
    _max: FormSubmissionMaxAggregateOutputType | null
  }

  type GetFormSubmissionGroupByPayload<T extends FormSubmissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormSubmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormSubmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormSubmissionGroupByOutputType[P]>
            : GetScalarType<T[P], FormSubmissionGroupByOutputType[P]>
        }
      >
    >


  export type FormSubmissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    formId?: boolean
    data?: boolean
    ipAddress?: boolean
    country?: boolean
    city?: boolean
    userAgent?: boolean
    deviceInfo?: boolean
    createdAt?: boolean
    form?: boolean | FormDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formSubmission"]>


  export type FormSubmissionSelectScalar = {
    id?: boolean
    formId?: boolean
    data?: boolean
    ipAddress?: boolean
    country?: boolean
    city?: boolean
    userAgent?: boolean
    deviceInfo?: boolean
    createdAt?: boolean
  }

  export type FormSubmissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    form?: boolean | FormDefaultArgs<ExtArgs>
  }

  export type $FormSubmissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FormSubmission"
    objects: {
      form: Prisma.$FormPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      formId: string
      data: Prisma.JsonValue
      ipAddress: string | null
      country: string | null
      city: string | null
      userAgent: string | null
      deviceInfo: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["formSubmission"]>
    composites: {}
  }

  type FormSubmissionGetPayload<S extends boolean | null | undefined | FormSubmissionDefaultArgs> = $Result.GetResult<Prisma.$FormSubmissionPayload, S>

  type FormSubmissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FormSubmissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FormSubmissionCountAggregateInputType | true
    }

  export interface FormSubmissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FormSubmission'], meta: { name: 'FormSubmission' } }
    /**
     * Find zero or one FormSubmission that matches the filter.
     * @param {FormSubmissionFindUniqueArgs} args - Arguments to find a FormSubmission
     * @example
     * // Get one FormSubmission
     * const formSubmission = await prisma.formSubmission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FormSubmissionFindUniqueArgs>(args: SelectSubset<T, FormSubmissionFindUniqueArgs<ExtArgs>>): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FormSubmission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FormSubmissionFindUniqueOrThrowArgs} args - Arguments to find a FormSubmission
     * @example
     * // Get one FormSubmission
     * const formSubmission = await prisma.formSubmission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FormSubmissionFindUniqueOrThrowArgs>(args: SelectSubset<T, FormSubmissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FormSubmission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionFindFirstArgs} args - Arguments to find a FormSubmission
     * @example
     * // Get one FormSubmission
     * const formSubmission = await prisma.formSubmission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FormSubmissionFindFirstArgs>(args?: SelectSubset<T, FormSubmissionFindFirstArgs<ExtArgs>>): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FormSubmission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionFindFirstOrThrowArgs} args - Arguments to find a FormSubmission
     * @example
     * // Get one FormSubmission
     * const formSubmission = await prisma.formSubmission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FormSubmissionFindFirstOrThrowArgs>(args?: SelectSubset<T, FormSubmissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FormSubmissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FormSubmissions
     * const formSubmissions = await prisma.formSubmission.findMany()
     * 
     * // Get first 10 FormSubmissions
     * const formSubmissions = await prisma.formSubmission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formSubmissionWithIdOnly = await prisma.formSubmission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FormSubmissionFindManyArgs>(args?: SelectSubset<T, FormSubmissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FormSubmission.
     * @param {FormSubmissionCreateArgs} args - Arguments to create a FormSubmission.
     * @example
     * // Create one FormSubmission
     * const FormSubmission = await prisma.formSubmission.create({
     *   data: {
     *     // ... data to create a FormSubmission
     *   }
     * })
     * 
     */
    create<T extends FormSubmissionCreateArgs>(args: SelectSubset<T, FormSubmissionCreateArgs<ExtArgs>>): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FormSubmissions.
     * @param {FormSubmissionCreateManyArgs} args - Arguments to create many FormSubmissions.
     * @example
     * // Create many FormSubmissions
     * const formSubmission = await prisma.formSubmission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FormSubmissionCreateManyArgs>(args?: SelectSubset<T, FormSubmissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FormSubmission.
     * @param {FormSubmissionDeleteArgs} args - Arguments to delete one FormSubmission.
     * @example
     * // Delete one FormSubmission
     * const FormSubmission = await prisma.formSubmission.delete({
     *   where: {
     *     // ... filter to delete one FormSubmission
     *   }
     * })
     * 
     */
    delete<T extends FormSubmissionDeleteArgs>(args: SelectSubset<T, FormSubmissionDeleteArgs<ExtArgs>>): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FormSubmission.
     * @param {FormSubmissionUpdateArgs} args - Arguments to update one FormSubmission.
     * @example
     * // Update one FormSubmission
     * const formSubmission = await prisma.formSubmission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FormSubmissionUpdateArgs>(args: SelectSubset<T, FormSubmissionUpdateArgs<ExtArgs>>): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FormSubmissions.
     * @param {FormSubmissionDeleteManyArgs} args - Arguments to filter FormSubmissions to delete.
     * @example
     * // Delete a few FormSubmissions
     * const { count } = await prisma.formSubmission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FormSubmissionDeleteManyArgs>(args?: SelectSubset<T, FormSubmissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FormSubmissions
     * const formSubmission = await prisma.formSubmission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FormSubmissionUpdateManyArgs>(args: SelectSubset<T, FormSubmissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FormSubmission.
     * @param {FormSubmissionUpsertArgs} args - Arguments to update or create a FormSubmission.
     * @example
     * // Update or create a FormSubmission
     * const formSubmission = await prisma.formSubmission.upsert({
     *   create: {
     *     // ... data to create a FormSubmission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FormSubmission we want to update
     *   }
     * })
     */
    upsert<T extends FormSubmissionUpsertArgs>(args: SelectSubset<T, FormSubmissionUpsertArgs<ExtArgs>>): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FormSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionCountArgs} args - Arguments to filter FormSubmissions to count.
     * @example
     * // Count the number of FormSubmissions
     * const count = await prisma.formSubmission.count({
     *   where: {
     *     // ... the filter for the FormSubmissions we want to count
     *   }
     * })
    **/
    count<T extends FormSubmissionCountArgs>(
      args?: Subset<T, FormSubmissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormSubmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FormSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormSubmissionAggregateArgs>(args: Subset<T, FormSubmissionAggregateArgs>): Prisma.PrismaPromise<GetFormSubmissionAggregateType<T>>

    /**
     * Group by FormSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormSubmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormSubmissionGroupByArgs['orderBy'] }
        : { orderBy?: FormSubmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormSubmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormSubmissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FormSubmission model
   */
  readonly fields: FormSubmissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FormSubmission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FormSubmissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    form<T extends FormDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FormDefaultArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FormSubmission model
   */ 
  interface FormSubmissionFieldRefs {
    readonly id: FieldRef<"FormSubmission", 'String'>
    readonly formId: FieldRef<"FormSubmission", 'String'>
    readonly data: FieldRef<"FormSubmission", 'Json'>
    readonly ipAddress: FieldRef<"FormSubmission", 'String'>
    readonly country: FieldRef<"FormSubmission", 'String'>
    readonly city: FieldRef<"FormSubmission", 'String'>
    readonly userAgent: FieldRef<"FormSubmission", 'String'>
    readonly deviceInfo: FieldRef<"FormSubmission", 'Json'>
    readonly createdAt: FieldRef<"FormSubmission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FormSubmission findUnique
   */
  export type FormSubmissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which FormSubmission to fetch.
     */
    where: FormSubmissionWhereUniqueInput
  }

  /**
   * FormSubmission findUniqueOrThrow
   */
  export type FormSubmissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which FormSubmission to fetch.
     */
    where: FormSubmissionWhereUniqueInput
  }

  /**
   * FormSubmission findFirst
   */
  export type FormSubmissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which FormSubmission to fetch.
     */
    where?: FormSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormSubmissions to fetch.
     */
    orderBy?: FormSubmissionOrderByWithRelationInput | FormSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormSubmissions.
     */
    cursor?: FormSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormSubmissions.
     */
    distinct?: FormSubmissionScalarFieldEnum | FormSubmissionScalarFieldEnum[]
  }

  /**
   * FormSubmission findFirstOrThrow
   */
  export type FormSubmissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which FormSubmission to fetch.
     */
    where?: FormSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormSubmissions to fetch.
     */
    orderBy?: FormSubmissionOrderByWithRelationInput | FormSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormSubmissions.
     */
    cursor?: FormSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormSubmissions.
     */
    distinct?: FormSubmissionScalarFieldEnum | FormSubmissionScalarFieldEnum[]
  }

  /**
   * FormSubmission findMany
   */
  export type FormSubmissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which FormSubmissions to fetch.
     */
    where?: FormSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormSubmissions to fetch.
     */
    orderBy?: FormSubmissionOrderByWithRelationInput | FormSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FormSubmissions.
     */
    cursor?: FormSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormSubmissions.
     */
    skip?: number
    distinct?: FormSubmissionScalarFieldEnum | FormSubmissionScalarFieldEnum[]
  }

  /**
   * FormSubmission create
   */
  export type FormSubmissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * The data needed to create a FormSubmission.
     */
    data: XOR<FormSubmissionCreateInput, FormSubmissionUncheckedCreateInput>
  }

  /**
   * FormSubmission createMany
   */
  export type FormSubmissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FormSubmissions.
     */
    data: FormSubmissionCreateManyInput | FormSubmissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FormSubmission update
   */
  export type FormSubmissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * The data needed to update a FormSubmission.
     */
    data: XOR<FormSubmissionUpdateInput, FormSubmissionUncheckedUpdateInput>
    /**
     * Choose, which FormSubmission to update.
     */
    where: FormSubmissionWhereUniqueInput
  }

  /**
   * FormSubmission updateMany
   */
  export type FormSubmissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FormSubmissions.
     */
    data: XOR<FormSubmissionUpdateManyMutationInput, FormSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which FormSubmissions to update
     */
    where?: FormSubmissionWhereInput
  }

  /**
   * FormSubmission upsert
   */
  export type FormSubmissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * The filter to search for the FormSubmission to update in case it exists.
     */
    where: FormSubmissionWhereUniqueInput
    /**
     * In case the FormSubmission found by the `where` argument doesn't exist, create a new FormSubmission with this data.
     */
    create: XOR<FormSubmissionCreateInput, FormSubmissionUncheckedCreateInput>
    /**
     * In case the FormSubmission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FormSubmissionUpdateInput, FormSubmissionUncheckedUpdateInput>
  }

  /**
   * FormSubmission delete
   */
  export type FormSubmissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * Filter which FormSubmission to delete.
     */
    where: FormSubmissionWhereUniqueInput
  }

  /**
   * FormSubmission deleteMany
   */
  export type FormSubmissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormSubmissions to delete
     */
    where?: FormSubmissionWhereInput
  }

  /**
   * FormSubmission without action
   */
  export type FormSubmissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
  }


  /**
   * Model Event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    location: string | null
    imageUrl: string | null
    status: $Enums.EventStatus | null
    paymentInfo: string | null
    organizerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    location: string | null
    imageUrl: string | null
    status: $Enums.EventStatus | null
    paymentInfo: string | null
    organizerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventCountAggregateOutputType = {
    id: number
    title: number
    description: number
    startDate: number
    endDate: number
    location: number
    imageUrl: number
    status: number
    categories: number
    paymentInfo: number
    organizerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EventMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startDate?: true
    endDate?: true
    location?: true
    imageUrl?: true
    status?: true
    paymentInfo?: true
    organizerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startDate?: true
    endDate?: true
    location?: true
    imageUrl?: true
    status?: true
    paymentInfo?: true
    organizerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startDate?: true
    endDate?: true
    location?: true
    imageUrl?: true
    status?: true
    categories?: true
    paymentInfo?: true
    organizerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Event to aggregate.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type EventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
    orderBy?: EventOrderByWithAggregationInput | EventOrderByWithAggregationInput[]
    by: EventScalarFieldEnum[] | EventScalarFieldEnum
    having?: EventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }

  export type EventGroupByOutputType = {
    id: string
    title: string
    description: string | null
    startDate: Date
    endDate: Date
    location: string
    imageUrl: string | null
    status: $Enums.EventStatus
    categories: JsonValue | null
    paymentInfo: string | null
    organizerId: string
    createdAt: Date
    updatedAt: Date
    _count: EventCountAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends EventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type EventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    location?: boolean
    imageUrl?: boolean
    status?: boolean
    categories?: boolean
    paymentInfo?: boolean
    organizerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organizer?: boolean | UserDefaultArgs<ExtArgs>
    zones?: boolean | Event$zonesArgs<ExtArgs>
    seats?: boolean | Event$seatsArgs<ExtArgs>
    tickets?: boolean | Event$ticketsArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>


  export type EventSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    location?: boolean
    imageUrl?: boolean
    status?: boolean
    categories?: boolean
    paymentInfo?: boolean
    organizerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizer?: boolean | UserDefaultArgs<ExtArgs>
    zones?: boolean | Event$zonesArgs<ExtArgs>
    seats?: boolean | Event$seatsArgs<ExtArgs>
    tickets?: boolean | Event$ticketsArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Event"
    objects: {
      organizer: Prisma.$UserPayload<ExtArgs>
      zones: Prisma.$EventZonePayload<ExtArgs>[]
      seats: Prisma.$EventSeatPayload<ExtArgs>[]
      tickets: Prisma.$TicketPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      startDate: Date
      endDate: Date
      location: string
      imageUrl: string | null
      status: $Enums.EventStatus
      categories: Prisma.JsonValue | null
      paymentInfo: string | null
      organizerId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["event"]>
    composites: {}
  }

  type EventGetPayload<S extends boolean | null | undefined | EventDefaultArgs> = $Result.GetResult<Prisma.$EventPayload, S>

  type EventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventCountAggregateInputType | true
    }

  export interface EventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Event'], meta: { name: 'Event' } }
    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventFindUniqueArgs>(args: SelectSubset<T, EventFindUniqueArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Event that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventFindUniqueOrThrowArgs>(args: SelectSubset<T, EventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventFindFirstArgs>(args?: SelectSubset<T, EventFindFirstArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventFindFirstOrThrowArgs>(args?: SelectSubset<T, EventFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventFindManyArgs>(args?: SelectSubset<T, EventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
     */
    create<T extends EventCreateArgs>(args: SelectSubset<T, EventCreateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Events.
     * @param {EventCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventCreateManyArgs>(args?: SelectSubset<T, EventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
     */
    delete<T extends EventDeleteArgs>(args: SelectSubset<T, EventDeleteArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventUpdateArgs>(args: SelectSubset<T, EventUpdateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventDeleteManyArgs>(args?: SelectSubset<T, EventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventUpdateManyArgs>(args: SelectSubset<T, EventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
     */
    upsert<T extends EventUpsertArgs>(args: SelectSubset<T, EventUpsertArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): Prisma.PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs['orderBy'] }
        : { orderBy?: EventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Event model
   */
  readonly fields: EventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organizer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    zones<T extends Event$zonesArgs<ExtArgs> = {}>(args?: Subset<T, Event$zonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventZonePayload<ExtArgs>, T, "findMany"> | Null>
    seats<T extends Event$seatsArgs<ExtArgs> = {}>(args?: Subset<T, Event$seatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventSeatPayload<ExtArgs>, T, "findMany"> | Null>
    tickets<T extends Event$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, Event$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Event model
   */ 
  interface EventFieldRefs {
    readonly id: FieldRef<"Event", 'String'>
    readonly title: FieldRef<"Event", 'String'>
    readonly description: FieldRef<"Event", 'String'>
    readonly startDate: FieldRef<"Event", 'DateTime'>
    readonly endDate: FieldRef<"Event", 'DateTime'>
    readonly location: FieldRef<"Event", 'String'>
    readonly imageUrl: FieldRef<"Event", 'String'>
    readonly status: FieldRef<"Event", 'EventStatus'>
    readonly categories: FieldRef<"Event", 'Json'>
    readonly paymentInfo: FieldRef<"Event", 'String'>
    readonly organizerId: FieldRef<"Event", 'String'>
    readonly createdAt: FieldRef<"Event", 'DateTime'>
    readonly updatedAt: FieldRef<"Event", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Event findUnique
   */
  export type EventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findUniqueOrThrow
   */
  export type EventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findFirst
   */
  export type EventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findFirstOrThrow
   */
  export type EventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findMany
   */
  export type EventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event create
   */
  export type EventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to create a Event.
     */
    data: XOR<EventCreateInput, EventUncheckedCreateInput>
  }

  /**
   * Event createMany
   */
  export type EventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Event update
   */
  export type EventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to update a Event.
     */
    data: XOR<EventUpdateInput, EventUncheckedUpdateInput>
    /**
     * Choose, which Event to update.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
  }

  /**
   * Event upsert
   */
  export type EventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The filter to search for the Event to update in case it exists.
     */
    where: EventWhereUniqueInput
    /**
     * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
     */
    create: XOR<EventCreateInput, EventUncheckedCreateInput>
    /**
     * In case the Event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventUpdateInput, EventUncheckedUpdateInput>
  }

  /**
   * Event delete
   */
  export type EventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter which Event to delete.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to delete
     */
    where?: EventWhereInput
  }

  /**
   * Event.zones
   */
  export type Event$zonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventZone
     */
    select?: EventZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventZoneInclude<ExtArgs> | null
    where?: EventZoneWhereInput
    orderBy?: EventZoneOrderByWithRelationInput | EventZoneOrderByWithRelationInput[]
    cursor?: EventZoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventZoneScalarFieldEnum | EventZoneScalarFieldEnum[]
  }

  /**
   * Event.seats
   */
  export type Event$seatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSeat
     */
    select?: EventSeatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventSeatInclude<ExtArgs> | null
    where?: EventSeatWhereInput
    orderBy?: EventSeatOrderByWithRelationInput | EventSeatOrderByWithRelationInput[]
    cursor?: EventSeatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventSeatScalarFieldEnum | EventSeatScalarFieldEnum[]
  }

  /**
   * Event.tickets
   */
  export type Event$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Event without action
   */
  export type EventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
  }


  /**
   * Model EventZone
   */

  export type AggregateEventZone = {
    _count: EventZoneCountAggregateOutputType | null
    _avg: EventZoneAvgAggregateOutputType | null
    _sum: EventZoneSumAggregateOutputType | null
    _min: EventZoneMinAggregateOutputType | null
    _max: EventZoneMaxAggregateOutputType | null
  }

  export type EventZoneAvgAggregateOutputType = {
    price: number | null
    rows: number | null
    cols: number | null
    capacity: number | null
    seatGap: number | null
    startNumber: number | null
  }

  export type EventZoneSumAggregateOutputType = {
    price: number | null
    rows: number | null
    cols: number | null
    capacity: number | null
    seatGap: number | null
    startNumber: number | null
  }

  export type EventZoneMinAggregateOutputType = {
    id: string | null
    eventId: string | null
    name: string | null
    color: string | null
    price: number | null
    rows: number | null
    cols: number | null
    capacity: number | null
    type: $Enums.ZoneType | null
    seatGap: number | null
    startNumber: number | null
    numberingDirection: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventZoneMaxAggregateOutputType = {
    id: string | null
    eventId: string | null
    name: string | null
    color: string | null
    price: number | null
    rows: number | null
    cols: number | null
    capacity: number | null
    type: $Enums.ZoneType | null
    seatGap: number | null
    startNumber: number | null
    numberingDirection: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventZoneCountAggregateOutputType = {
    id: number
    eventId: number
    name: number
    color: number
    price: number
    rows: number
    cols: number
    capacity: number
    type: number
    layout: number
    seatGap: number
    startNumber: number
    numberingDirection: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EventZoneAvgAggregateInputType = {
    price?: true
    rows?: true
    cols?: true
    capacity?: true
    seatGap?: true
    startNumber?: true
  }

  export type EventZoneSumAggregateInputType = {
    price?: true
    rows?: true
    cols?: true
    capacity?: true
    seatGap?: true
    startNumber?: true
  }

  export type EventZoneMinAggregateInputType = {
    id?: true
    eventId?: true
    name?: true
    color?: true
    price?: true
    rows?: true
    cols?: true
    capacity?: true
    type?: true
    seatGap?: true
    startNumber?: true
    numberingDirection?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventZoneMaxAggregateInputType = {
    id?: true
    eventId?: true
    name?: true
    color?: true
    price?: true
    rows?: true
    cols?: true
    capacity?: true
    type?: true
    seatGap?: true
    startNumber?: true
    numberingDirection?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventZoneCountAggregateInputType = {
    id?: true
    eventId?: true
    name?: true
    color?: true
    price?: true
    rows?: true
    cols?: true
    capacity?: true
    type?: true
    layout?: true
    seatGap?: true
    startNumber?: true
    numberingDirection?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EventZoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventZone to aggregate.
     */
    where?: EventZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventZones to fetch.
     */
    orderBy?: EventZoneOrderByWithRelationInput | EventZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventZones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventZones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventZones
    **/
    _count?: true | EventZoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventZoneAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventZoneSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventZoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventZoneMaxAggregateInputType
  }

  export type GetEventZoneAggregateType<T extends EventZoneAggregateArgs> = {
        [P in keyof T & keyof AggregateEventZone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventZone[P]>
      : GetScalarType<T[P], AggregateEventZone[P]>
  }




  export type EventZoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventZoneWhereInput
    orderBy?: EventZoneOrderByWithAggregationInput | EventZoneOrderByWithAggregationInput[]
    by: EventZoneScalarFieldEnum[] | EventZoneScalarFieldEnum
    having?: EventZoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventZoneCountAggregateInputType | true
    _avg?: EventZoneAvgAggregateInputType
    _sum?: EventZoneSumAggregateInputType
    _min?: EventZoneMinAggregateInputType
    _max?: EventZoneMaxAggregateInputType
  }

  export type EventZoneGroupByOutputType = {
    id: string
    eventId: string
    name: string
    color: string
    price: number
    rows: number
    cols: number
    capacity: number | null
    type: $Enums.ZoneType
    layout: JsonValue | null
    seatGap: number | null
    startNumber: number
    numberingDirection: string
    createdAt: Date
    updatedAt: Date
    _count: EventZoneCountAggregateOutputType | null
    _avg: EventZoneAvgAggregateOutputType | null
    _sum: EventZoneSumAggregateOutputType | null
    _min: EventZoneMinAggregateOutputType | null
    _max: EventZoneMaxAggregateOutputType | null
  }

  type GetEventZoneGroupByPayload<T extends EventZoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventZoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventZoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventZoneGroupByOutputType[P]>
            : GetScalarType<T[P], EventZoneGroupByOutputType[P]>
        }
      >
    >


  export type EventZoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    name?: boolean
    color?: boolean
    price?: boolean
    rows?: boolean
    cols?: boolean
    capacity?: boolean
    type?: boolean
    layout?: boolean
    seatGap?: boolean
    startNumber?: boolean
    numberingDirection?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
    seats?: boolean | EventZone$seatsArgs<ExtArgs>
    tickets?: boolean | EventZone$ticketsArgs<ExtArgs>
    _count?: boolean | EventZoneCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventZone"]>


  export type EventZoneSelectScalar = {
    id?: boolean
    eventId?: boolean
    name?: boolean
    color?: boolean
    price?: boolean
    rows?: boolean
    cols?: boolean
    capacity?: boolean
    type?: boolean
    layout?: boolean
    seatGap?: boolean
    startNumber?: boolean
    numberingDirection?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EventZoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
    seats?: boolean | EventZone$seatsArgs<ExtArgs>
    tickets?: boolean | EventZone$ticketsArgs<ExtArgs>
    _count?: boolean | EventZoneCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EventZonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventZone"
    objects: {
      event: Prisma.$EventPayload<ExtArgs>
      seats: Prisma.$EventSeatPayload<ExtArgs>[]
      tickets: Prisma.$TicketPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventId: string
      name: string
      color: string
      price: number
      rows: number
      cols: number
      capacity: number | null
      type: $Enums.ZoneType
      layout: Prisma.JsonValue | null
      seatGap: number | null
      startNumber: number
      numberingDirection: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["eventZone"]>
    composites: {}
  }

  type EventZoneGetPayload<S extends boolean | null | undefined | EventZoneDefaultArgs> = $Result.GetResult<Prisma.$EventZonePayload, S>

  type EventZoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EventZoneFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventZoneCountAggregateInputType | true
    }

  export interface EventZoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventZone'], meta: { name: 'EventZone' } }
    /**
     * Find zero or one EventZone that matches the filter.
     * @param {EventZoneFindUniqueArgs} args - Arguments to find a EventZone
     * @example
     * // Get one EventZone
     * const eventZone = await prisma.eventZone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventZoneFindUniqueArgs>(args: SelectSubset<T, EventZoneFindUniqueArgs<ExtArgs>>): Prisma__EventZoneClient<$Result.GetResult<Prisma.$EventZonePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EventZone that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EventZoneFindUniqueOrThrowArgs} args - Arguments to find a EventZone
     * @example
     * // Get one EventZone
     * const eventZone = await prisma.eventZone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventZoneFindUniqueOrThrowArgs>(args: SelectSubset<T, EventZoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventZoneClient<$Result.GetResult<Prisma.$EventZonePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EventZone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventZoneFindFirstArgs} args - Arguments to find a EventZone
     * @example
     * // Get one EventZone
     * const eventZone = await prisma.eventZone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventZoneFindFirstArgs>(args?: SelectSubset<T, EventZoneFindFirstArgs<ExtArgs>>): Prisma__EventZoneClient<$Result.GetResult<Prisma.$EventZonePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EventZone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventZoneFindFirstOrThrowArgs} args - Arguments to find a EventZone
     * @example
     * // Get one EventZone
     * const eventZone = await prisma.eventZone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventZoneFindFirstOrThrowArgs>(args?: SelectSubset<T, EventZoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventZoneClient<$Result.GetResult<Prisma.$EventZonePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EventZones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventZoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventZones
     * const eventZones = await prisma.eventZone.findMany()
     * 
     * // Get first 10 EventZones
     * const eventZones = await prisma.eventZone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventZoneWithIdOnly = await prisma.eventZone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventZoneFindManyArgs>(args?: SelectSubset<T, EventZoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventZonePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EventZone.
     * @param {EventZoneCreateArgs} args - Arguments to create a EventZone.
     * @example
     * // Create one EventZone
     * const EventZone = await prisma.eventZone.create({
     *   data: {
     *     // ... data to create a EventZone
     *   }
     * })
     * 
     */
    create<T extends EventZoneCreateArgs>(args: SelectSubset<T, EventZoneCreateArgs<ExtArgs>>): Prisma__EventZoneClient<$Result.GetResult<Prisma.$EventZonePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EventZones.
     * @param {EventZoneCreateManyArgs} args - Arguments to create many EventZones.
     * @example
     * // Create many EventZones
     * const eventZone = await prisma.eventZone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventZoneCreateManyArgs>(args?: SelectSubset<T, EventZoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EventZone.
     * @param {EventZoneDeleteArgs} args - Arguments to delete one EventZone.
     * @example
     * // Delete one EventZone
     * const EventZone = await prisma.eventZone.delete({
     *   where: {
     *     // ... filter to delete one EventZone
     *   }
     * })
     * 
     */
    delete<T extends EventZoneDeleteArgs>(args: SelectSubset<T, EventZoneDeleteArgs<ExtArgs>>): Prisma__EventZoneClient<$Result.GetResult<Prisma.$EventZonePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EventZone.
     * @param {EventZoneUpdateArgs} args - Arguments to update one EventZone.
     * @example
     * // Update one EventZone
     * const eventZone = await prisma.eventZone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventZoneUpdateArgs>(args: SelectSubset<T, EventZoneUpdateArgs<ExtArgs>>): Prisma__EventZoneClient<$Result.GetResult<Prisma.$EventZonePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EventZones.
     * @param {EventZoneDeleteManyArgs} args - Arguments to filter EventZones to delete.
     * @example
     * // Delete a few EventZones
     * const { count } = await prisma.eventZone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventZoneDeleteManyArgs>(args?: SelectSubset<T, EventZoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventZones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventZoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventZones
     * const eventZone = await prisma.eventZone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventZoneUpdateManyArgs>(args: SelectSubset<T, EventZoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EventZone.
     * @param {EventZoneUpsertArgs} args - Arguments to update or create a EventZone.
     * @example
     * // Update or create a EventZone
     * const eventZone = await prisma.eventZone.upsert({
     *   create: {
     *     // ... data to create a EventZone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventZone we want to update
     *   }
     * })
     */
    upsert<T extends EventZoneUpsertArgs>(args: SelectSubset<T, EventZoneUpsertArgs<ExtArgs>>): Prisma__EventZoneClient<$Result.GetResult<Prisma.$EventZonePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EventZones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventZoneCountArgs} args - Arguments to filter EventZones to count.
     * @example
     * // Count the number of EventZones
     * const count = await prisma.eventZone.count({
     *   where: {
     *     // ... the filter for the EventZones we want to count
     *   }
     * })
    **/
    count<T extends EventZoneCountArgs>(
      args?: Subset<T, EventZoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventZoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventZone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventZoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventZoneAggregateArgs>(args: Subset<T, EventZoneAggregateArgs>): Prisma.PrismaPromise<GetEventZoneAggregateType<T>>

    /**
     * Group by EventZone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventZoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventZoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventZoneGroupByArgs['orderBy'] }
        : { orderBy?: EventZoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventZoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventZoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventZone model
   */
  readonly fields: EventZoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventZone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventZoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    seats<T extends EventZone$seatsArgs<ExtArgs> = {}>(args?: Subset<T, EventZone$seatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventSeatPayload<ExtArgs>, T, "findMany"> | Null>
    tickets<T extends EventZone$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, EventZone$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EventZone model
   */ 
  interface EventZoneFieldRefs {
    readonly id: FieldRef<"EventZone", 'String'>
    readonly eventId: FieldRef<"EventZone", 'String'>
    readonly name: FieldRef<"EventZone", 'String'>
    readonly color: FieldRef<"EventZone", 'String'>
    readonly price: FieldRef<"EventZone", 'Float'>
    readonly rows: FieldRef<"EventZone", 'Int'>
    readonly cols: FieldRef<"EventZone", 'Int'>
    readonly capacity: FieldRef<"EventZone", 'Int'>
    readonly type: FieldRef<"EventZone", 'ZoneType'>
    readonly layout: FieldRef<"EventZone", 'Json'>
    readonly seatGap: FieldRef<"EventZone", 'Int'>
    readonly startNumber: FieldRef<"EventZone", 'Int'>
    readonly numberingDirection: FieldRef<"EventZone", 'String'>
    readonly createdAt: FieldRef<"EventZone", 'DateTime'>
    readonly updatedAt: FieldRef<"EventZone", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EventZone findUnique
   */
  export type EventZoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventZone
     */
    select?: EventZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventZoneInclude<ExtArgs> | null
    /**
     * Filter, which EventZone to fetch.
     */
    where: EventZoneWhereUniqueInput
  }

  /**
   * EventZone findUniqueOrThrow
   */
  export type EventZoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventZone
     */
    select?: EventZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventZoneInclude<ExtArgs> | null
    /**
     * Filter, which EventZone to fetch.
     */
    where: EventZoneWhereUniqueInput
  }

  /**
   * EventZone findFirst
   */
  export type EventZoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventZone
     */
    select?: EventZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventZoneInclude<ExtArgs> | null
    /**
     * Filter, which EventZone to fetch.
     */
    where?: EventZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventZones to fetch.
     */
    orderBy?: EventZoneOrderByWithRelationInput | EventZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventZones.
     */
    cursor?: EventZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventZones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventZones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventZones.
     */
    distinct?: EventZoneScalarFieldEnum | EventZoneScalarFieldEnum[]
  }

  /**
   * EventZone findFirstOrThrow
   */
  export type EventZoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventZone
     */
    select?: EventZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventZoneInclude<ExtArgs> | null
    /**
     * Filter, which EventZone to fetch.
     */
    where?: EventZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventZones to fetch.
     */
    orderBy?: EventZoneOrderByWithRelationInput | EventZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventZones.
     */
    cursor?: EventZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventZones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventZones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventZones.
     */
    distinct?: EventZoneScalarFieldEnum | EventZoneScalarFieldEnum[]
  }

  /**
   * EventZone findMany
   */
  export type EventZoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventZone
     */
    select?: EventZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventZoneInclude<ExtArgs> | null
    /**
     * Filter, which EventZones to fetch.
     */
    where?: EventZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventZones to fetch.
     */
    orderBy?: EventZoneOrderByWithRelationInput | EventZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventZones.
     */
    cursor?: EventZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventZones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventZones.
     */
    skip?: number
    distinct?: EventZoneScalarFieldEnum | EventZoneScalarFieldEnum[]
  }

  /**
   * EventZone create
   */
  export type EventZoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventZone
     */
    select?: EventZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventZoneInclude<ExtArgs> | null
    /**
     * The data needed to create a EventZone.
     */
    data: XOR<EventZoneCreateInput, EventZoneUncheckedCreateInput>
  }

  /**
   * EventZone createMany
   */
  export type EventZoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventZones.
     */
    data: EventZoneCreateManyInput | EventZoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventZone update
   */
  export type EventZoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventZone
     */
    select?: EventZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventZoneInclude<ExtArgs> | null
    /**
     * The data needed to update a EventZone.
     */
    data: XOR<EventZoneUpdateInput, EventZoneUncheckedUpdateInput>
    /**
     * Choose, which EventZone to update.
     */
    where: EventZoneWhereUniqueInput
  }

  /**
   * EventZone updateMany
   */
  export type EventZoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventZones.
     */
    data: XOR<EventZoneUpdateManyMutationInput, EventZoneUncheckedUpdateManyInput>
    /**
     * Filter which EventZones to update
     */
    where?: EventZoneWhereInput
  }

  /**
   * EventZone upsert
   */
  export type EventZoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventZone
     */
    select?: EventZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventZoneInclude<ExtArgs> | null
    /**
     * The filter to search for the EventZone to update in case it exists.
     */
    where: EventZoneWhereUniqueInput
    /**
     * In case the EventZone found by the `where` argument doesn't exist, create a new EventZone with this data.
     */
    create: XOR<EventZoneCreateInput, EventZoneUncheckedCreateInput>
    /**
     * In case the EventZone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventZoneUpdateInput, EventZoneUncheckedUpdateInput>
  }

  /**
   * EventZone delete
   */
  export type EventZoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventZone
     */
    select?: EventZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventZoneInclude<ExtArgs> | null
    /**
     * Filter which EventZone to delete.
     */
    where: EventZoneWhereUniqueInput
  }

  /**
   * EventZone deleteMany
   */
  export type EventZoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventZones to delete
     */
    where?: EventZoneWhereInput
  }

  /**
   * EventZone.seats
   */
  export type EventZone$seatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSeat
     */
    select?: EventSeatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventSeatInclude<ExtArgs> | null
    where?: EventSeatWhereInput
    orderBy?: EventSeatOrderByWithRelationInput | EventSeatOrderByWithRelationInput[]
    cursor?: EventSeatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventSeatScalarFieldEnum | EventSeatScalarFieldEnum[]
  }

  /**
   * EventZone.tickets
   */
  export type EventZone$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * EventZone without action
   */
  export type EventZoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventZone
     */
    select?: EventZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventZoneInclude<ExtArgs> | null
  }


  /**
   * Model EventSeat
   */

  export type AggregateEventSeat = {
    _count: EventSeatCountAggregateOutputType | null
    _avg: EventSeatAvgAggregateOutputType | null
    _sum: EventSeatSumAggregateOutputType | null
    _min: EventSeatMinAggregateOutputType | null
    _max: EventSeatMaxAggregateOutputType | null
  }

  export type EventSeatAvgAggregateOutputType = {
    price: number | null
    x: number | null
    y: number | null
  }

  export type EventSeatSumAggregateOutputType = {
    price: number | null
    x: number | null
    y: number | null
  }

  export type EventSeatMinAggregateOutputType = {
    id: string | null
    eventId: string | null
    zoneId: string | null
    rowLabel: string | null
    colLabel: string | null
    status: $Enums.SeatStatus | null
    type: $Enums.SeatType | null
    price: number | null
    x: number | null
    y: number | null
    holderName: string | null
    ticketCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventSeatMaxAggregateOutputType = {
    id: string | null
    eventId: string | null
    zoneId: string | null
    rowLabel: string | null
    colLabel: string | null
    status: $Enums.SeatStatus | null
    type: $Enums.SeatType | null
    price: number | null
    x: number | null
    y: number | null
    holderName: string | null
    ticketCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventSeatCountAggregateOutputType = {
    id: number
    eventId: number
    zoneId: number
    rowLabel: number
    colLabel: number
    status: number
    type: number
    price: number
    x: number
    y: number
    holderName: number
    ticketCode: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EventSeatAvgAggregateInputType = {
    price?: true
    x?: true
    y?: true
  }

  export type EventSeatSumAggregateInputType = {
    price?: true
    x?: true
    y?: true
  }

  export type EventSeatMinAggregateInputType = {
    id?: true
    eventId?: true
    zoneId?: true
    rowLabel?: true
    colLabel?: true
    status?: true
    type?: true
    price?: true
    x?: true
    y?: true
    holderName?: true
    ticketCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventSeatMaxAggregateInputType = {
    id?: true
    eventId?: true
    zoneId?: true
    rowLabel?: true
    colLabel?: true
    status?: true
    type?: true
    price?: true
    x?: true
    y?: true
    holderName?: true
    ticketCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventSeatCountAggregateInputType = {
    id?: true
    eventId?: true
    zoneId?: true
    rowLabel?: true
    colLabel?: true
    status?: true
    type?: true
    price?: true
    x?: true
    y?: true
    holderName?: true
    ticketCode?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EventSeatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventSeat to aggregate.
     */
    where?: EventSeatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventSeats to fetch.
     */
    orderBy?: EventSeatOrderByWithRelationInput | EventSeatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventSeatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventSeats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventSeats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventSeats
    **/
    _count?: true | EventSeatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventSeatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventSeatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventSeatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventSeatMaxAggregateInputType
  }

  export type GetEventSeatAggregateType<T extends EventSeatAggregateArgs> = {
        [P in keyof T & keyof AggregateEventSeat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventSeat[P]>
      : GetScalarType<T[P], AggregateEventSeat[P]>
  }




  export type EventSeatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventSeatWhereInput
    orderBy?: EventSeatOrderByWithAggregationInput | EventSeatOrderByWithAggregationInput[]
    by: EventSeatScalarFieldEnum[] | EventSeatScalarFieldEnum
    having?: EventSeatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventSeatCountAggregateInputType | true
    _avg?: EventSeatAvgAggregateInputType
    _sum?: EventSeatSumAggregateInputType
    _min?: EventSeatMinAggregateInputType
    _max?: EventSeatMaxAggregateInputType
  }

  export type EventSeatGroupByOutputType = {
    id: string
    eventId: string
    zoneId: string
    rowLabel: string
    colLabel: string
    status: $Enums.SeatStatus
    type: $Enums.SeatType
    price: number | null
    x: number | null
    y: number | null
    holderName: string | null
    ticketCode: string | null
    createdAt: Date
    updatedAt: Date
    _count: EventSeatCountAggregateOutputType | null
    _avg: EventSeatAvgAggregateOutputType | null
    _sum: EventSeatSumAggregateOutputType | null
    _min: EventSeatMinAggregateOutputType | null
    _max: EventSeatMaxAggregateOutputType | null
  }

  type GetEventSeatGroupByPayload<T extends EventSeatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventSeatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventSeatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventSeatGroupByOutputType[P]>
            : GetScalarType<T[P], EventSeatGroupByOutputType[P]>
        }
      >
    >


  export type EventSeatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    zoneId?: boolean
    rowLabel?: boolean
    colLabel?: boolean
    status?: boolean
    type?: boolean
    price?: boolean
    x?: boolean
    y?: boolean
    holderName?: boolean
    ticketCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
    zone?: boolean | EventZoneDefaultArgs<ExtArgs>
    tickets?: boolean | EventSeat$ticketsArgs<ExtArgs>
    _count?: boolean | EventSeatCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventSeat"]>


  export type EventSeatSelectScalar = {
    id?: boolean
    eventId?: boolean
    zoneId?: boolean
    rowLabel?: boolean
    colLabel?: boolean
    status?: boolean
    type?: boolean
    price?: boolean
    x?: boolean
    y?: boolean
    holderName?: boolean
    ticketCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EventSeatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
    zone?: boolean | EventZoneDefaultArgs<ExtArgs>
    tickets?: boolean | EventSeat$ticketsArgs<ExtArgs>
    _count?: boolean | EventSeatCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EventSeatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventSeat"
    objects: {
      event: Prisma.$EventPayload<ExtArgs>
      zone: Prisma.$EventZonePayload<ExtArgs>
      tickets: Prisma.$TicketPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventId: string
      zoneId: string
      rowLabel: string
      colLabel: string
      status: $Enums.SeatStatus
      type: $Enums.SeatType
      price: number | null
      x: number | null
      y: number | null
      holderName: string | null
      ticketCode: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["eventSeat"]>
    composites: {}
  }

  type EventSeatGetPayload<S extends boolean | null | undefined | EventSeatDefaultArgs> = $Result.GetResult<Prisma.$EventSeatPayload, S>

  type EventSeatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EventSeatFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventSeatCountAggregateInputType | true
    }

  export interface EventSeatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventSeat'], meta: { name: 'EventSeat' } }
    /**
     * Find zero or one EventSeat that matches the filter.
     * @param {EventSeatFindUniqueArgs} args - Arguments to find a EventSeat
     * @example
     * // Get one EventSeat
     * const eventSeat = await prisma.eventSeat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventSeatFindUniqueArgs>(args: SelectSubset<T, EventSeatFindUniqueArgs<ExtArgs>>): Prisma__EventSeatClient<$Result.GetResult<Prisma.$EventSeatPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EventSeat that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EventSeatFindUniqueOrThrowArgs} args - Arguments to find a EventSeat
     * @example
     * // Get one EventSeat
     * const eventSeat = await prisma.eventSeat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventSeatFindUniqueOrThrowArgs>(args: SelectSubset<T, EventSeatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventSeatClient<$Result.GetResult<Prisma.$EventSeatPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EventSeat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventSeatFindFirstArgs} args - Arguments to find a EventSeat
     * @example
     * // Get one EventSeat
     * const eventSeat = await prisma.eventSeat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventSeatFindFirstArgs>(args?: SelectSubset<T, EventSeatFindFirstArgs<ExtArgs>>): Prisma__EventSeatClient<$Result.GetResult<Prisma.$EventSeatPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EventSeat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventSeatFindFirstOrThrowArgs} args - Arguments to find a EventSeat
     * @example
     * // Get one EventSeat
     * const eventSeat = await prisma.eventSeat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventSeatFindFirstOrThrowArgs>(args?: SelectSubset<T, EventSeatFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventSeatClient<$Result.GetResult<Prisma.$EventSeatPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EventSeats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventSeatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventSeats
     * const eventSeats = await prisma.eventSeat.findMany()
     * 
     * // Get first 10 EventSeats
     * const eventSeats = await prisma.eventSeat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventSeatWithIdOnly = await prisma.eventSeat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventSeatFindManyArgs>(args?: SelectSubset<T, EventSeatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventSeatPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EventSeat.
     * @param {EventSeatCreateArgs} args - Arguments to create a EventSeat.
     * @example
     * // Create one EventSeat
     * const EventSeat = await prisma.eventSeat.create({
     *   data: {
     *     // ... data to create a EventSeat
     *   }
     * })
     * 
     */
    create<T extends EventSeatCreateArgs>(args: SelectSubset<T, EventSeatCreateArgs<ExtArgs>>): Prisma__EventSeatClient<$Result.GetResult<Prisma.$EventSeatPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EventSeats.
     * @param {EventSeatCreateManyArgs} args - Arguments to create many EventSeats.
     * @example
     * // Create many EventSeats
     * const eventSeat = await prisma.eventSeat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventSeatCreateManyArgs>(args?: SelectSubset<T, EventSeatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EventSeat.
     * @param {EventSeatDeleteArgs} args - Arguments to delete one EventSeat.
     * @example
     * // Delete one EventSeat
     * const EventSeat = await prisma.eventSeat.delete({
     *   where: {
     *     // ... filter to delete one EventSeat
     *   }
     * })
     * 
     */
    delete<T extends EventSeatDeleteArgs>(args: SelectSubset<T, EventSeatDeleteArgs<ExtArgs>>): Prisma__EventSeatClient<$Result.GetResult<Prisma.$EventSeatPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EventSeat.
     * @param {EventSeatUpdateArgs} args - Arguments to update one EventSeat.
     * @example
     * // Update one EventSeat
     * const eventSeat = await prisma.eventSeat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventSeatUpdateArgs>(args: SelectSubset<T, EventSeatUpdateArgs<ExtArgs>>): Prisma__EventSeatClient<$Result.GetResult<Prisma.$EventSeatPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EventSeats.
     * @param {EventSeatDeleteManyArgs} args - Arguments to filter EventSeats to delete.
     * @example
     * // Delete a few EventSeats
     * const { count } = await prisma.eventSeat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventSeatDeleteManyArgs>(args?: SelectSubset<T, EventSeatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventSeats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventSeatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventSeats
     * const eventSeat = await prisma.eventSeat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventSeatUpdateManyArgs>(args: SelectSubset<T, EventSeatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EventSeat.
     * @param {EventSeatUpsertArgs} args - Arguments to update or create a EventSeat.
     * @example
     * // Update or create a EventSeat
     * const eventSeat = await prisma.eventSeat.upsert({
     *   create: {
     *     // ... data to create a EventSeat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventSeat we want to update
     *   }
     * })
     */
    upsert<T extends EventSeatUpsertArgs>(args: SelectSubset<T, EventSeatUpsertArgs<ExtArgs>>): Prisma__EventSeatClient<$Result.GetResult<Prisma.$EventSeatPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EventSeats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventSeatCountArgs} args - Arguments to filter EventSeats to count.
     * @example
     * // Count the number of EventSeats
     * const count = await prisma.eventSeat.count({
     *   where: {
     *     // ... the filter for the EventSeats we want to count
     *   }
     * })
    **/
    count<T extends EventSeatCountArgs>(
      args?: Subset<T, EventSeatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventSeatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventSeat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventSeatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventSeatAggregateArgs>(args: Subset<T, EventSeatAggregateArgs>): Prisma.PrismaPromise<GetEventSeatAggregateType<T>>

    /**
     * Group by EventSeat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventSeatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventSeatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventSeatGroupByArgs['orderBy'] }
        : { orderBy?: EventSeatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventSeatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventSeatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventSeat model
   */
  readonly fields: EventSeatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventSeat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventSeatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    zone<T extends EventZoneDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventZoneDefaultArgs<ExtArgs>>): Prisma__EventZoneClient<$Result.GetResult<Prisma.$EventZonePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tickets<T extends EventSeat$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, EventSeat$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EventSeat model
   */ 
  interface EventSeatFieldRefs {
    readonly id: FieldRef<"EventSeat", 'String'>
    readonly eventId: FieldRef<"EventSeat", 'String'>
    readonly zoneId: FieldRef<"EventSeat", 'String'>
    readonly rowLabel: FieldRef<"EventSeat", 'String'>
    readonly colLabel: FieldRef<"EventSeat", 'String'>
    readonly status: FieldRef<"EventSeat", 'SeatStatus'>
    readonly type: FieldRef<"EventSeat", 'SeatType'>
    readonly price: FieldRef<"EventSeat", 'Float'>
    readonly x: FieldRef<"EventSeat", 'Int'>
    readonly y: FieldRef<"EventSeat", 'Int'>
    readonly holderName: FieldRef<"EventSeat", 'String'>
    readonly ticketCode: FieldRef<"EventSeat", 'String'>
    readonly createdAt: FieldRef<"EventSeat", 'DateTime'>
    readonly updatedAt: FieldRef<"EventSeat", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EventSeat findUnique
   */
  export type EventSeatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSeat
     */
    select?: EventSeatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventSeatInclude<ExtArgs> | null
    /**
     * Filter, which EventSeat to fetch.
     */
    where: EventSeatWhereUniqueInput
  }

  /**
   * EventSeat findUniqueOrThrow
   */
  export type EventSeatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSeat
     */
    select?: EventSeatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventSeatInclude<ExtArgs> | null
    /**
     * Filter, which EventSeat to fetch.
     */
    where: EventSeatWhereUniqueInput
  }

  /**
   * EventSeat findFirst
   */
  export type EventSeatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSeat
     */
    select?: EventSeatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventSeatInclude<ExtArgs> | null
    /**
     * Filter, which EventSeat to fetch.
     */
    where?: EventSeatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventSeats to fetch.
     */
    orderBy?: EventSeatOrderByWithRelationInput | EventSeatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventSeats.
     */
    cursor?: EventSeatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventSeats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventSeats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventSeats.
     */
    distinct?: EventSeatScalarFieldEnum | EventSeatScalarFieldEnum[]
  }

  /**
   * EventSeat findFirstOrThrow
   */
  export type EventSeatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSeat
     */
    select?: EventSeatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventSeatInclude<ExtArgs> | null
    /**
     * Filter, which EventSeat to fetch.
     */
    where?: EventSeatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventSeats to fetch.
     */
    orderBy?: EventSeatOrderByWithRelationInput | EventSeatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventSeats.
     */
    cursor?: EventSeatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventSeats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventSeats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventSeats.
     */
    distinct?: EventSeatScalarFieldEnum | EventSeatScalarFieldEnum[]
  }

  /**
   * EventSeat findMany
   */
  export type EventSeatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSeat
     */
    select?: EventSeatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventSeatInclude<ExtArgs> | null
    /**
     * Filter, which EventSeats to fetch.
     */
    where?: EventSeatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventSeats to fetch.
     */
    orderBy?: EventSeatOrderByWithRelationInput | EventSeatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventSeats.
     */
    cursor?: EventSeatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventSeats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventSeats.
     */
    skip?: number
    distinct?: EventSeatScalarFieldEnum | EventSeatScalarFieldEnum[]
  }

  /**
   * EventSeat create
   */
  export type EventSeatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSeat
     */
    select?: EventSeatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventSeatInclude<ExtArgs> | null
    /**
     * The data needed to create a EventSeat.
     */
    data: XOR<EventSeatCreateInput, EventSeatUncheckedCreateInput>
  }

  /**
   * EventSeat createMany
   */
  export type EventSeatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventSeats.
     */
    data: EventSeatCreateManyInput | EventSeatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventSeat update
   */
  export type EventSeatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSeat
     */
    select?: EventSeatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventSeatInclude<ExtArgs> | null
    /**
     * The data needed to update a EventSeat.
     */
    data: XOR<EventSeatUpdateInput, EventSeatUncheckedUpdateInput>
    /**
     * Choose, which EventSeat to update.
     */
    where: EventSeatWhereUniqueInput
  }

  /**
   * EventSeat updateMany
   */
  export type EventSeatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventSeats.
     */
    data: XOR<EventSeatUpdateManyMutationInput, EventSeatUncheckedUpdateManyInput>
    /**
     * Filter which EventSeats to update
     */
    where?: EventSeatWhereInput
  }

  /**
   * EventSeat upsert
   */
  export type EventSeatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSeat
     */
    select?: EventSeatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventSeatInclude<ExtArgs> | null
    /**
     * The filter to search for the EventSeat to update in case it exists.
     */
    where: EventSeatWhereUniqueInput
    /**
     * In case the EventSeat found by the `where` argument doesn't exist, create a new EventSeat with this data.
     */
    create: XOR<EventSeatCreateInput, EventSeatUncheckedCreateInput>
    /**
     * In case the EventSeat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventSeatUpdateInput, EventSeatUncheckedUpdateInput>
  }

  /**
   * EventSeat delete
   */
  export type EventSeatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSeat
     */
    select?: EventSeatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventSeatInclude<ExtArgs> | null
    /**
     * Filter which EventSeat to delete.
     */
    where: EventSeatWhereUniqueInput
  }

  /**
   * EventSeat deleteMany
   */
  export type EventSeatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventSeats to delete
     */
    where?: EventSeatWhereInput
  }

  /**
   * EventSeat.tickets
   */
  export type EventSeat$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * EventSeat without action
   */
  export type EventSeatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSeat
     */
    select?: EventSeatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventSeatInclude<ExtArgs> | null
  }


  /**
   * Model Ticket
   */

  export type AggregateTicket = {
    _count: TicketCountAggregateOutputType | null
    _avg: TicketAvgAggregateOutputType | null
    _sum: TicketSumAggregateOutputType | null
    _min: TicketMinAggregateOutputType | null
    _max: TicketMaxAggregateOutputType | null
  }

  export type TicketAvgAggregateOutputType = {
    price: number | null
  }

  export type TicketSumAggregateOutputType = {
    price: number | null
  }

  export type TicketMinAggregateOutputType = {
    id: string | null
    eventId: string | null
    zoneId: string | null
    seatId: string | null
    customerName: string | null
    customerEmail: string | null
    price: number | null
    status: $Enums.TicketStatus | null
    purchaseDate: Date | null
    qrCode: string | null
  }

  export type TicketMaxAggregateOutputType = {
    id: string | null
    eventId: string | null
    zoneId: string | null
    seatId: string | null
    customerName: string | null
    customerEmail: string | null
    price: number | null
    status: $Enums.TicketStatus | null
    purchaseDate: Date | null
    qrCode: string | null
  }

  export type TicketCountAggregateOutputType = {
    id: number
    eventId: number
    zoneId: number
    seatId: number
    customerName: number
    customerEmail: number
    price: number
    status: number
    purchaseDate: number
    qrCode: number
    _all: number
  }


  export type TicketAvgAggregateInputType = {
    price?: true
  }

  export type TicketSumAggregateInputType = {
    price?: true
  }

  export type TicketMinAggregateInputType = {
    id?: true
    eventId?: true
    zoneId?: true
    seatId?: true
    customerName?: true
    customerEmail?: true
    price?: true
    status?: true
    purchaseDate?: true
    qrCode?: true
  }

  export type TicketMaxAggregateInputType = {
    id?: true
    eventId?: true
    zoneId?: true
    seatId?: true
    customerName?: true
    customerEmail?: true
    price?: true
    status?: true
    purchaseDate?: true
    qrCode?: true
  }

  export type TicketCountAggregateInputType = {
    id?: true
    eventId?: true
    zoneId?: true
    seatId?: true
    customerName?: true
    customerEmail?: true
    price?: true
    status?: true
    purchaseDate?: true
    qrCode?: true
    _all?: true
  }

  export type TicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ticket to aggregate.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tickets
    **/
    _count?: true | TicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TicketAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TicketSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketMaxAggregateInputType
  }

  export type GetTicketAggregateType<T extends TicketAggregateArgs> = {
        [P in keyof T & keyof AggregateTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicket[P]>
      : GetScalarType<T[P], AggregateTicket[P]>
  }




  export type TicketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithAggregationInput | TicketOrderByWithAggregationInput[]
    by: TicketScalarFieldEnum[] | TicketScalarFieldEnum
    having?: TicketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketCountAggregateInputType | true
    _avg?: TicketAvgAggregateInputType
    _sum?: TicketSumAggregateInputType
    _min?: TicketMinAggregateInputType
    _max?: TicketMaxAggregateInputType
  }

  export type TicketGroupByOutputType = {
    id: string
    eventId: string
    zoneId: string
    seatId: string | null
    customerName: string
    customerEmail: string
    price: number
    status: $Enums.TicketStatus
    purchaseDate: Date
    qrCode: string | null
    _count: TicketCountAggregateOutputType | null
    _avg: TicketAvgAggregateOutputType | null
    _sum: TicketSumAggregateOutputType | null
    _min: TicketMinAggregateOutputType | null
    _max: TicketMaxAggregateOutputType | null
  }

  type GetTicketGroupByPayload<T extends TicketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketGroupByOutputType[P]>
            : GetScalarType<T[P], TicketGroupByOutputType[P]>
        }
      >
    >


  export type TicketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    zoneId?: boolean
    seatId?: boolean
    customerName?: boolean
    customerEmail?: boolean
    price?: boolean
    status?: boolean
    purchaseDate?: boolean
    qrCode?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
    zone?: boolean | EventZoneDefaultArgs<ExtArgs>
    seat?: boolean | Ticket$seatArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>


  export type TicketSelectScalar = {
    id?: boolean
    eventId?: boolean
    zoneId?: boolean
    seatId?: boolean
    customerName?: boolean
    customerEmail?: boolean
    price?: boolean
    status?: boolean
    purchaseDate?: boolean
    qrCode?: boolean
  }

  export type TicketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
    zone?: boolean | EventZoneDefaultArgs<ExtArgs>
    seat?: boolean | Ticket$seatArgs<ExtArgs>
  }

  export type $TicketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ticket"
    objects: {
      event: Prisma.$EventPayload<ExtArgs>
      zone: Prisma.$EventZonePayload<ExtArgs>
      seat: Prisma.$EventSeatPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventId: string
      zoneId: string
      seatId: string | null
      customerName: string
      customerEmail: string
      price: number
      status: $Enums.TicketStatus
      purchaseDate: Date
      qrCode: string | null
    }, ExtArgs["result"]["ticket"]>
    composites: {}
  }

  type TicketGetPayload<S extends boolean | null | undefined | TicketDefaultArgs> = $Result.GetResult<Prisma.$TicketPayload, S>

  type TicketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TicketFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TicketCountAggregateInputType | true
    }

  export interface TicketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ticket'], meta: { name: 'Ticket' } }
    /**
     * Find zero or one Ticket that matches the filter.
     * @param {TicketFindUniqueArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketFindUniqueArgs>(args: SelectSubset<T, TicketFindUniqueArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Ticket that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TicketFindUniqueOrThrowArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Ticket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindFirstArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketFindFirstArgs>(args?: SelectSubset<T, TicketFindFirstArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Ticket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindFirstOrThrowArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tickets
     * const tickets = await prisma.ticket.findMany()
     * 
     * // Get first 10 Tickets
     * const tickets = await prisma.ticket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketWithIdOnly = await prisma.ticket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketFindManyArgs>(args?: SelectSubset<T, TicketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Ticket.
     * @param {TicketCreateArgs} args - Arguments to create a Ticket.
     * @example
     * // Create one Ticket
     * const Ticket = await prisma.ticket.create({
     *   data: {
     *     // ... data to create a Ticket
     *   }
     * })
     * 
     */
    create<T extends TicketCreateArgs>(args: SelectSubset<T, TicketCreateArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tickets.
     * @param {TicketCreateManyArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const ticket = await prisma.ticket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketCreateManyArgs>(args?: SelectSubset<T, TicketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ticket.
     * @param {TicketDeleteArgs} args - Arguments to delete one Ticket.
     * @example
     * // Delete one Ticket
     * const Ticket = await prisma.ticket.delete({
     *   where: {
     *     // ... filter to delete one Ticket
     *   }
     * })
     * 
     */
    delete<T extends TicketDeleteArgs>(args: SelectSubset<T, TicketDeleteArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Ticket.
     * @param {TicketUpdateArgs} args - Arguments to update one Ticket.
     * @example
     * // Update one Ticket
     * const ticket = await prisma.ticket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketUpdateArgs>(args: SelectSubset<T, TicketUpdateArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tickets.
     * @param {TicketDeleteManyArgs} args - Arguments to filter Tickets to delete.
     * @example
     * // Delete a few Tickets
     * const { count } = await prisma.ticket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketDeleteManyArgs>(args?: SelectSubset<T, TicketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tickets
     * const ticket = await prisma.ticket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketUpdateManyArgs>(args: SelectSubset<T, TicketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ticket.
     * @param {TicketUpsertArgs} args - Arguments to update or create a Ticket.
     * @example
     * // Update or create a Ticket
     * const ticket = await prisma.ticket.upsert({
     *   create: {
     *     // ... data to create a Ticket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ticket we want to update
     *   }
     * })
     */
    upsert<T extends TicketUpsertArgs>(args: SelectSubset<T, TicketUpsertArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCountArgs} args - Arguments to filter Tickets to count.
     * @example
     * // Count the number of Tickets
     * const count = await prisma.ticket.count({
     *   where: {
     *     // ... the filter for the Tickets we want to count
     *   }
     * })
    **/
    count<T extends TicketCountArgs>(
      args?: Subset<T, TicketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketAggregateArgs>(args: Subset<T, TicketAggregateArgs>): Prisma.PrismaPromise<GetTicketAggregateType<T>>

    /**
     * Group by Ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketGroupByArgs['orderBy'] }
        : { orderBy?: TicketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ticket model
   */
  readonly fields: TicketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ticket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    zone<T extends EventZoneDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventZoneDefaultArgs<ExtArgs>>): Prisma__EventZoneClient<$Result.GetResult<Prisma.$EventZonePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    seat<T extends Ticket$seatArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$seatArgs<ExtArgs>>): Prisma__EventSeatClient<$Result.GetResult<Prisma.$EventSeatPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ticket model
   */ 
  interface TicketFieldRefs {
    readonly id: FieldRef<"Ticket", 'String'>
    readonly eventId: FieldRef<"Ticket", 'String'>
    readonly zoneId: FieldRef<"Ticket", 'String'>
    readonly seatId: FieldRef<"Ticket", 'String'>
    readonly customerName: FieldRef<"Ticket", 'String'>
    readonly customerEmail: FieldRef<"Ticket", 'String'>
    readonly price: FieldRef<"Ticket", 'Float'>
    readonly status: FieldRef<"Ticket", 'TicketStatus'>
    readonly purchaseDate: FieldRef<"Ticket", 'DateTime'>
    readonly qrCode: FieldRef<"Ticket", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Ticket findUnique
   */
  export type TicketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket findUniqueOrThrow
   */
  export type TicketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket findFirst
   */
  export type TicketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket findFirstOrThrow
   */
  export type TicketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket findMany
   */
  export type TicketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Tickets to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket create
   */
  export type TicketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The data needed to create a Ticket.
     */
    data: XOR<TicketCreateInput, TicketUncheckedCreateInput>
  }

  /**
   * Ticket createMany
   */
  export type TicketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tickets.
     */
    data: TicketCreateManyInput | TicketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ticket update
   */
  export type TicketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The data needed to update a Ticket.
     */
    data: XOR<TicketUpdateInput, TicketUncheckedUpdateInput>
    /**
     * Choose, which Ticket to update.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket updateMany
   */
  export type TicketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tickets.
     */
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyInput>
    /**
     * Filter which Tickets to update
     */
    where?: TicketWhereInput
  }

  /**
   * Ticket upsert
   */
  export type TicketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The filter to search for the Ticket to update in case it exists.
     */
    where: TicketWhereUniqueInput
    /**
     * In case the Ticket found by the `where` argument doesn't exist, create a new Ticket with this data.
     */
    create: XOR<TicketCreateInput, TicketUncheckedCreateInput>
    /**
     * In case the Ticket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketUpdateInput, TicketUncheckedUpdateInput>
  }

  /**
   * Ticket delete
   */
  export type TicketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter which Ticket to delete.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket deleteMany
   */
  export type TicketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tickets to delete
     */
    where?: TicketWhereInput
  }

  /**
   * Ticket.seat
   */
  export type Ticket$seatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSeat
     */
    select?: EventSeatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventSeatInclude<ExtArgs> | null
    where?: EventSeatWhereInput
  }

  /**
   * Ticket without action
   */
  export type TicketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    username: 'username',
    fullName: 'fullName',
    avatarUrl: 'avatarUrl',
    passwordHash: 'passwordHash',
    deviceId: 'deviceId',
    isGuest: 'isGuest',
    phoneNumber: 'phoneNumber',
    isPhoneVerified: 'isPhoneVerified',
    verificationCode: 'verificationCode',
    verificationCodeExpiresAt: 'verificationCodeExpiresAt',
    isAdmin: 'isAdmin',
    isCoordinator: 'isCoordinator',
    isDisabled: 'isDisabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ChannelScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    websiteUrl: 'websiteUrl',
    socialLinks: 'socialLinks',
    logoUrl: 'logoUrl',
    icon: 'icon',
    parentId: 'parentId',
    ownerId: 'ownerId',
    organizationId: 'organizationId',
    isPublic: 'isPublic',
    isHidden: 'isHidden',
    searchExactOnly: 'searchExactOnly',
    passwordHash: 'passwordHash',
    referenceCode: 'referenceCode',
    verificationStatus: 'verificationStatus',
    approvalPolicy: 'approvalPolicy',
    memberCount: 'memberCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChannelScalarFieldEnum = (typeof ChannelScalarFieldEnum)[keyof typeof ChannelScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    channelId: 'channelId',
    senderId: 'senderId',
    categoryId: 'categoryId',
    content: 'content',
    durationSeconds: 'durationSeconds',
    expiresAt: 'expiresAt',
    isEmergency: 'isEmergency',
    isImmediate: 'isImmediate',
    priority: 'priority',
    approvalOverride: 'approvalOverride',
    approvalOverrideSetBy: 'approvalOverrideSetBy',
    approvalOverrideSetAt: 'approvalOverrideSetAt',
    deliveryMethod: 'deliveryMethod',
    eventAt: 'eventAt',
    publishedAt: 'publishedAt',
    state: 'state',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const ChannelSubscriptionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    channelId: 'channelId',
    subscribedAt: 'subscribedAt',
    isActive: 'isActive',
    isFavorite: 'isFavorite',
    receiveMessages: 'receiveMessages'
  };

  export type ChannelSubscriptionScalarFieldEnum = (typeof ChannelSubscriptionScalarFieldEnum)[keyof typeof ChannelSubscriptionScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    actorId: 'actorId',
    action: 'action',
    targetUserId: 'targetUserId',
    targetChannelId: 'targetChannelId',
    details: 'details',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const MessageDeliveryScalarFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    userId: 'userId',
    deliveryStatus: 'deliveryStatus',
    deliveryMethod: 'deliveryMethod',
    deliveredAt: 'deliveredAt',
    readAt: 'readAt',
    createdAt: 'createdAt'
  };

  export type MessageDeliveryScalarFieldEnum = (typeof MessageDeliveryScalarFieldEnum)[keyof typeof MessageDeliveryScalarFieldEnum]


  export const InvitationLinkScalarFieldEnum: {
    id: 'id',
    channelId: 'channelId',
    createdBy: 'createdBy',
    linkCode: 'linkCode',
    expiresAt: 'expiresAt',
    maxUses: 'maxUses',
    currentUses: 'currentUses',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type InvitationLinkScalarFieldEnum = (typeof InvitationLinkScalarFieldEnum)[keyof typeof InvitationLinkScalarFieldEnum]


  export const QrCodeScalarFieldEnum: {
    id: 'id',
    channelId: 'channelId',
    createdBy: 'createdBy',
    qrData: 'qrData',
    expiresAt: 'expiresAt',
    scanCount: 'scanCount',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type QrCodeScalarFieldEnum = (typeof QrCodeScalarFieldEnum)[keyof typeof QrCodeScalarFieldEnum]


  export const OrganizationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    nit: 'nit',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


  export const ChannelApproverScalarFieldEnum: {
    id: 'id',
    channelId: 'channelId',
    userId: 'userId',
    isActive: 'isActive',
    removedAt: 'removedAt',
    removedBy: 'removedBy',
    createdAt: 'createdAt'
  };

  export type ChannelApproverScalarFieldEnum = (typeof ChannelApproverScalarFieldEnum)[keyof typeof ChannelApproverScalarFieldEnum]


  export const MessageApprovalScalarFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    approverId: 'approverId',
    status: 'status',
    decidedAt: 'decidedAt'
  };

  export type MessageApprovalScalarFieldEnum = (typeof MessageApprovalScalarFieldEnum)[keyof typeof MessageApprovalScalarFieldEnum]


  export const MessageCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    scope: 'scope',
    channelId: 'channelId',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type MessageCategoryScalarFieldEnum = (typeof MessageCategoryScalarFieldEnum)[keyof typeof MessageCategoryScalarFieldEnum]


  export const MessageAttachmentScalarFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    type: 'type',
    url: 'url',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type MessageAttachmentScalarFieldEnum = (typeof MessageAttachmentScalarFieldEnum)[keyof typeof MessageAttachmentScalarFieldEnum]


  export const MessageRevisionScalarFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    editorId: 'editorId',
    previousContent: 'previousContent',
    previousCategoryId: 'previousCategoryId',
    previousPriority: 'previousPriority',
    previousIsImmediate: 'previousIsImmediate',
    previousDeliveryMethod: 'previousDeliveryMethod',
    changedAt: 'changedAt'
  };

  export type MessageRevisionScalarFieldEnum = (typeof MessageRevisionScalarFieldEnum)[keyof typeof MessageRevisionScalarFieldEnum]


  export const ChannelVerificationDocumentScalarFieldEnum: {
    id: 'id',
    channelId: 'channelId',
    title: 'title',
    docUrl: 'docUrl',
    issuer: 'issuer',
    issuedAt: 'issuedAt',
    createdAt: 'createdAt'
  };

  export type ChannelVerificationDocumentScalarFieldEnum = (typeof ChannelVerificationDocumentScalarFieldEnum)[keyof typeof ChannelVerificationDocumentScalarFieldEnum]


  export const UserProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    country: 'country',
    department: 'department',
    city: 'city',
    extra: 'extra'
  };

  export type UserProfileScalarFieldEnum = (typeof UserProfileScalarFieldEnum)[keyof typeof UserProfileScalarFieldEnum]


  export const UserMessagingSettingScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    platform: 'platform',
    handle: 'handle',
    isEnabled: 'isEnabled',
    verified: 'verified',
    createdAt: 'createdAt'
  };

  export type UserMessagingSettingScalarFieldEnum = (typeof UserMessagingSettingScalarFieldEnum)[keyof typeof UserMessagingSettingScalarFieldEnum]


  export const ChannelCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type ChannelCategoryScalarFieldEnum = (typeof ChannelCategoryScalarFieldEnum)[keyof typeof ChannelCategoryScalarFieldEnum]


  export const ChannelCategoryAssignmentScalarFieldEnum: {
    id: 'id',
    channelId: 'channelId',
    categoryId: 'categoryId'
  };

  export type ChannelCategoryAssignmentScalarFieldEnum = (typeof ChannelCategoryAssignmentScalarFieldEnum)[keyof typeof ChannelCategoryAssignmentScalarFieldEnum]


  export const MessageViewScalarFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    userId: 'userId',
    viewedAt: 'viewedAt'
  };

  export type MessageViewScalarFieldEnum = (typeof MessageViewScalarFieldEnum)[keyof typeof MessageViewScalarFieldEnum]


  export const ChannelVisitScalarFieldEnum: {
    id: 'id',
    channelId: 'channelId',
    userId: 'userId',
    visitedAt: 'visitedAt'
  };

  export type ChannelVisitScalarFieldEnum = (typeof ChannelVisitScalarFieldEnum)[keyof typeof ChannelVisitScalarFieldEnum]


  export const FormScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    slug: 'slug',
    headerContent: 'headerContent',
    footerContent: 'footerContent',
    successMessage: 'successMessage',
    isActive: 'isActive',
    isPublished: 'isPublished',
    wasPublished: 'wasPublished',
    isDeleted: 'isDeleted',
    collectUserInfo: 'collectUserInfo',
    expiresAt: 'expiresAt',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FormScalarFieldEnum = (typeof FormScalarFieldEnum)[keyof typeof FormScalarFieldEnum]


  export const FormFieldScalarFieldEnum: {
    id: 'id',
    formId: 'formId',
    type: 'type',
    label: 'label',
    placeholder: 'placeholder',
    required: 'required',
    isHidden: 'isHidden',
    options: 'options',
    order: 'order',
    createdAt: 'createdAt'
  };

  export type FormFieldScalarFieldEnum = (typeof FormFieldScalarFieldEnum)[keyof typeof FormFieldScalarFieldEnum]


  export const FormSubmissionScalarFieldEnum: {
    id: 'id',
    formId: 'formId',
    data: 'data',
    ipAddress: 'ipAddress',
    country: 'country',
    city: 'city',
    userAgent: 'userAgent',
    deviceInfo: 'deviceInfo',
    createdAt: 'createdAt'
  };

  export type FormSubmissionScalarFieldEnum = (typeof FormSubmissionScalarFieldEnum)[keyof typeof FormSubmissionScalarFieldEnum]


  export const EventScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    startDate: 'startDate',
    endDate: 'endDate',
    location: 'location',
    imageUrl: 'imageUrl',
    status: 'status',
    categories: 'categories',
    paymentInfo: 'paymentInfo',
    organizerId: 'organizerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const EventZoneScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    name: 'name',
    color: 'color',
    price: 'price',
    rows: 'rows',
    cols: 'cols',
    capacity: 'capacity',
    type: 'type',
    layout: 'layout',
    seatGap: 'seatGap',
    startNumber: 'startNumber',
    numberingDirection: 'numberingDirection',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EventZoneScalarFieldEnum = (typeof EventZoneScalarFieldEnum)[keyof typeof EventZoneScalarFieldEnum]


  export const EventSeatScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    zoneId: 'zoneId',
    rowLabel: 'rowLabel',
    colLabel: 'colLabel',
    status: 'status',
    type: 'type',
    price: 'price',
    x: 'x',
    y: 'y',
    holderName: 'holderName',
    ticketCode: 'ticketCode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EventSeatScalarFieldEnum = (typeof EventSeatScalarFieldEnum)[keyof typeof EventSeatScalarFieldEnum]


  export const TicketScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    zoneId: 'zoneId',
    seatId: 'seatId',
    customerName: 'customerName',
    customerEmail: 'customerEmail',
    price: 'price',
    status: 'status',
    purchaseDate: 'purchaseDate',
    qrCode: 'qrCode'
  };

  export type TicketScalarFieldEnum = (typeof TicketScalarFieldEnum)[keyof typeof TicketScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'VerificationStatus'
   */
  export type EnumVerificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerificationStatus'>
    


  /**
   * Reference to a field of type 'ApprovalPolicy'
   */
  export type EnumApprovalPolicyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApprovalPolicy'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'MessagePriority'
   */
  export type EnumMessagePriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessagePriority'>
    


  /**
   * Reference to a field of type 'DeliveryMethod'
   */
  export type EnumDeliveryMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeliveryMethod'>
    


  /**
   * Reference to a field of type 'MessageState'
   */
  export type EnumMessageStateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageState'>
    


  /**
   * Reference to a field of type 'DeliveryStatus'
   */
  export type EnumDeliveryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeliveryStatus'>
    


  /**
   * Reference to a field of type 'ApprovalStatus'
   */
  export type EnumApprovalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApprovalStatus'>
    


  /**
   * Reference to a field of type 'CategoryScope'
   */
  export type EnumCategoryScopeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CategoryScope'>
    


  /**
   * Reference to a field of type 'AttachmentType'
   */
  export type EnumAttachmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttachmentType'>
    


  /**
   * Reference to a field of type 'MessagingPlatform'
   */
  export type EnumMessagingPlatformFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessagingPlatform'>
    


  /**
   * Reference to a field of type 'EventStatus'
   */
  export type EnumEventStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventStatus'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'ZoneType'
   */
  export type EnumZoneTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ZoneType'>
    


  /**
   * Reference to a field of type 'SeatStatus'
   */
  export type EnumSeatStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SeatStatus'>
    


  /**
   * Reference to a field of type 'SeatType'
   */
  export type EnumSeatTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SeatType'>
    


  /**
   * Reference to a field of type 'TicketStatus'
   */
  export type EnumTicketStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketStatus'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    fullName?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringNullableFilter<"User"> | string | null
    deviceId?: StringNullableFilter<"User"> | string | null
    isGuest?: BoolFilter<"User"> | boolean
    phoneNumber?: StringNullableFilter<"User"> | string | null
    isPhoneVerified?: BoolFilter<"User"> | boolean
    verificationCode?: StringNullableFilter<"User"> | string | null
    verificationCodeExpiresAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isAdmin?: BoolFilter<"User"> | boolean
    isCoordinator?: BoolFilter<"User"> | boolean
    isDisabled?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    ownedChannels?: ChannelListRelationFilter
    messagesSent?: MessageListRelationFilter
    messagesOverrideSet?: MessageListRelationFilter
    subscriptions?: ChannelSubscriptionListRelationFilter
    invitationLinks?: InvitationLinkListRelationFilter
    qrCodes?: QrCodeListRelationFilter
    messageDeliveries?: MessageDeliveryListRelationFilter
    messageApprovals?: MessageApprovalListRelationFilter
    messageRevisionsEdited?: MessageRevisionListRelationFilter
    profile?: XOR<UserProfileNullableRelationFilter, UserProfileWhereInput> | null
    messagingSettings?: UserMessagingSettingListRelationFilter
    approverAssignments?: ChannelApproverListRelationFilter
    createdCategories?: MessageCategoryListRelationFilter
    messageViews?: MessageViewListRelationFilter
    channelVisits?: ChannelVisitListRelationFilter
    createdForms?: FormListRelationFilter
    organizedEvents?: EventListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    fullName?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    passwordHash?: SortOrderInput | SortOrder
    deviceId?: SortOrderInput | SortOrder
    isGuest?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    isPhoneVerified?: SortOrder
    verificationCode?: SortOrderInput | SortOrder
    verificationCodeExpiresAt?: SortOrderInput | SortOrder
    isAdmin?: SortOrder
    isCoordinator?: SortOrder
    isDisabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownedChannels?: ChannelOrderByRelationAggregateInput
    messagesSent?: MessageOrderByRelationAggregateInput
    messagesOverrideSet?: MessageOrderByRelationAggregateInput
    subscriptions?: ChannelSubscriptionOrderByRelationAggregateInput
    invitationLinks?: InvitationLinkOrderByRelationAggregateInput
    qrCodes?: QrCodeOrderByRelationAggregateInput
    messageDeliveries?: MessageDeliveryOrderByRelationAggregateInput
    messageApprovals?: MessageApprovalOrderByRelationAggregateInput
    messageRevisionsEdited?: MessageRevisionOrderByRelationAggregateInput
    profile?: UserProfileOrderByWithRelationInput
    messagingSettings?: UserMessagingSettingOrderByRelationAggregateInput
    approverAssignments?: ChannelApproverOrderByRelationAggregateInput
    createdCategories?: MessageCategoryOrderByRelationAggregateInput
    messageViews?: MessageViewOrderByRelationAggregateInput
    channelVisits?: ChannelVisitOrderByRelationAggregateInput
    createdForms?: FormOrderByRelationAggregateInput
    organizedEvents?: EventOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    deviceId?: string
    phoneNumber?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    fullName?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringNullableFilter<"User"> | string | null
    isGuest?: BoolFilter<"User"> | boolean
    isPhoneVerified?: BoolFilter<"User"> | boolean
    verificationCode?: StringNullableFilter<"User"> | string | null
    verificationCodeExpiresAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isAdmin?: BoolFilter<"User"> | boolean
    isCoordinator?: BoolFilter<"User"> | boolean
    isDisabled?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    ownedChannels?: ChannelListRelationFilter
    messagesSent?: MessageListRelationFilter
    messagesOverrideSet?: MessageListRelationFilter
    subscriptions?: ChannelSubscriptionListRelationFilter
    invitationLinks?: InvitationLinkListRelationFilter
    qrCodes?: QrCodeListRelationFilter
    messageDeliveries?: MessageDeliveryListRelationFilter
    messageApprovals?: MessageApprovalListRelationFilter
    messageRevisionsEdited?: MessageRevisionListRelationFilter
    profile?: XOR<UserProfileNullableRelationFilter, UserProfileWhereInput> | null
    messagingSettings?: UserMessagingSettingListRelationFilter
    approverAssignments?: ChannelApproverListRelationFilter
    createdCategories?: MessageCategoryListRelationFilter
    messageViews?: MessageViewListRelationFilter
    channelVisits?: ChannelVisitListRelationFilter
    createdForms?: FormListRelationFilter
    organizedEvents?: EventListRelationFilter
  }, "id" | "email" | "username" | "deviceId" | "phoneNumber">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    fullName?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    passwordHash?: SortOrderInput | SortOrder
    deviceId?: SortOrderInput | SortOrder
    isGuest?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    isPhoneVerified?: SortOrder
    verificationCode?: SortOrderInput | SortOrder
    verificationCodeExpiresAt?: SortOrderInput | SortOrder
    isAdmin?: SortOrder
    isCoordinator?: SortOrder
    isDisabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    fullName?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    deviceId?: StringNullableWithAggregatesFilter<"User"> | string | null
    isGuest?: BoolWithAggregatesFilter<"User"> | boolean
    phoneNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    isPhoneVerified?: BoolWithAggregatesFilter<"User"> | boolean
    verificationCode?: StringNullableWithAggregatesFilter<"User"> | string | null
    verificationCodeExpiresAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    isAdmin?: BoolWithAggregatesFilter<"User"> | boolean
    isCoordinator?: BoolWithAggregatesFilter<"User"> | boolean
    isDisabled?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ChannelWhereInput = {
    AND?: ChannelWhereInput | ChannelWhereInput[]
    OR?: ChannelWhereInput[]
    NOT?: ChannelWhereInput | ChannelWhereInput[]
    id?: StringFilter<"Channel"> | string
    title?: StringFilter<"Channel"> | string
    description?: StringNullableFilter<"Channel"> | string | null
    websiteUrl?: StringNullableFilter<"Channel"> | string | null
    socialLinks?: JsonNullableFilter<"Channel">
    logoUrl?: StringNullableFilter<"Channel"> | string | null
    icon?: StringFilter<"Channel"> | string
    parentId?: StringNullableFilter<"Channel"> | string | null
    ownerId?: StringFilter<"Channel"> | string
    organizationId?: StringFilter<"Channel"> | string
    isPublic?: BoolFilter<"Channel"> | boolean
    isHidden?: BoolFilter<"Channel"> | boolean
    searchExactOnly?: BoolFilter<"Channel"> | boolean
    passwordHash?: StringNullableFilter<"Channel"> | string | null
    referenceCode?: StringNullableFilter<"Channel"> | string | null
    verificationStatus?: EnumVerificationStatusFilter<"Channel"> | $Enums.VerificationStatus
    approvalPolicy?: EnumApprovalPolicyFilter<"Channel"> | $Enums.ApprovalPolicy
    memberCount?: IntFilter<"Channel"> | number
    createdAt?: DateTimeFilter<"Channel"> | Date | string
    updatedAt?: DateTimeFilter<"Channel"> | Date | string
    owner?: XOR<UserRelationFilter, UserWhereInput>
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    parent?: XOR<ChannelNullableRelationFilter, ChannelWhereInput> | null
    subchannels?: ChannelListRelationFilter
    messages?: MessageListRelationFilter
    subscriptions?: ChannelSubscriptionListRelationFilter
    invitationLinks?: InvitationLinkListRelationFilter
    qrCodes?: QrCodeListRelationFilter
    approvers?: ChannelApproverListRelationFilter
    verificationDocs?: ChannelVerificationDocumentListRelationFilter
    categories?: ChannelCategoryAssignmentListRelationFilter
    messageCategories?: MessageCategoryListRelationFilter
    visits?: ChannelVisitListRelationFilter
  }

  export type ChannelOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    websiteUrl?: SortOrderInput | SortOrder
    socialLinks?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    icon?: SortOrder
    parentId?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    organizationId?: SortOrder
    isPublic?: SortOrder
    isHidden?: SortOrder
    searchExactOnly?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    referenceCode?: SortOrderInput | SortOrder
    verificationStatus?: SortOrder
    approvalPolicy?: SortOrder
    memberCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    owner?: UserOrderByWithRelationInput
    organization?: OrganizationOrderByWithRelationInput
    parent?: ChannelOrderByWithRelationInput
    subchannels?: ChannelOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
    subscriptions?: ChannelSubscriptionOrderByRelationAggregateInput
    invitationLinks?: InvitationLinkOrderByRelationAggregateInput
    qrCodes?: QrCodeOrderByRelationAggregateInput
    approvers?: ChannelApproverOrderByRelationAggregateInput
    verificationDocs?: ChannelVerificationDocumentOrderByRelationAggregateInput
    categories?: ChannelCategoryAssignmentOrderByRelationAggregateInput
    messageCategories?: MessageCategoryOrderByRelationAggregateInput
    visits?: ChannelVisitOrderByRelationAggregateInput
  }

  export type ChannelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    referenceCode?: string
    AND?: ChannelWhereInput | ChannelWhereInput[]
    OR?: ChannelWhereInput[]
    NOT?: ChannelWhereInput | ChannelWhereInput[]
    title?: StringFilter<"Channel"> | string
    description?: StringNullableFilter<"Channel"> | string | null
    websiteUrl?: StringNullableFilter<"Channel"> | string | null
    socialLinks?: JsonNullableFilter<"Channel">
    logoUrl?: StringNullableFilter<"Channel"> | string | null
    icon?: StringFilter<"Channel"> | string
    parentId?: StringNullableFilter<"Channel"> | string | null
    ownerId?: StringFilter<"Channel"> | string
    organizationId?: StringFilter<"Channel"> | string
    isPublic?: BoolFilter<"Channel"> | boolean
    isHidden?: BoolFilter<"Channel"> | boolean
    searchExactOnly?: BoolFilter<"Channel"> | boolean
    passwordHash?: StringNullableFilter<"Channel"> | string | null
    verificationStatus?: EnumVerificationStatusFilter<"Channel"> | $Enums.VerificationStatus
    approvalPolicy?: EnumApprovalPolicyFilter<"Channel"> | $Enums.ApprovalPolicy
    memberCount?: IntFilter<"Channel"> | number
    createdAt?: DateTimeFilter<"Channel"> | Date | string
    updatedAt?: DateTimeFilter<"Channel"> | Date | string
    owner?: XOR<UserRelationFilter, UserWhereInput>
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    parent?: XOR<ChannelNullableRelationFilter, ChannelWhereInput> | null
    subchannels?: ChannelListRelationFilter
    messages?: MessageListRelationFilter
    subscriptions?: ChannelSubscriptionListRelationFilter
    invitationLinks?: InvitationLinkListRelationFilter
    qrCodes?: QrCodeListRelationFilter
    approvers?: ChannelApproverListRelationFilter
    verificationDocs?: ChannelVerificationDocumentListRelationFilter
    categories?: ChannelCategoryAssignmentListRelationFilter
    messageCategories?: MessageCategoryListRelationFilter
    visits?: ChannelVisitListRelationFilter
  }, "id" | "referenceCode">

  export type ChannelOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    websiteUrl?: SortOrderInput | SortOrder
    socialLinks?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    icon?: SortOrder
    parentId?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    organizationId?: SortOrder
    isPublic?: SortOrder
    isHidden?: SortOrder
    searchExactOnly?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    referenceCode?: SortOrderInput | SortOrder
    verificationStatus?: SortOrder
    approvalPolicy?: SortOrder
    memberCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChannelCountOrderByAggregateInput
    _avg?: ChannelAvgOrderByAggregateInput
    _max?: ChannelMaxOrderByAggregateInput
    _min?: ChannelMinOrderByAggregateInput
    _sum?: ChannelSumOrderByAggregateInput
  }

  export type ChannelScalarWhereWithAggregatesInput = {
    AND?: ChannelScalarWhereWithAggregatesInput | ChannelScalarWhereWithAggregatesInput[]
    OR?: ChannelScalarWhereWithAggregatesInput[]
    NOT?: ChannelScalarWhereWithAggregatesInput | ChannelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Channel"> | string
    title?: StringWithAggregatesFilter<"Channel"> | string
    description?: StringNullableWithAggregatesFilter<"Channel"> | string | null
    websiteUrl?: StringNullableWithAggregatesFilter<"Channel"> | string | null
    socialLinks?: JsonNullableWithAggregatesFilter<"Channel">
    logoUrl?: StringNullableWithAggregatesFilter<"Channel"> | string | null
    icon?: StringWithAggregatesFilter<"Channel"> | string
    parentId?: StringNullableWithAggregatesFilter<"Channel"> | string | null
    ownerId?: StringWithAggregatesFilter<"Channel"> | string
    organizationId?: StringWithAggregatesFilter<"Channel"> | string
    isPublic?: BoolWithAggregatesFilter<"Channel"> | boolean
    isHidden?: BoolWithAggregatesFilter<"Channel"> | boolean
    searchExactOnly?: BoolWithAggregatesFilter<"Channel"> | boolean
    passwordHash?: StringNullableWithAggregatesFilter<"Channel"> | string | null
    referenceCode?: StringNullableWithAggregatesFilter<"Channel"> | string | null
    verificationStatus?: EnumVerificationStatusWithAggregatesFilter<"Channel"> | $Enums.VerificationStatus
    approvalPolicy?: EnumApprovalPolicyWithAggregatesFilter<"Channel"> | $Enums.ApprovalPolicy
    memberCount?: IntWithAggregatesFilter<"Channel"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Channel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Channel"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    channelId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    categoryId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    durationSeconds?: IntFilter<"Message"> | number
    expiresAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    isEmergency?: BoolFilter<"Message"> | boolean
    isImmediate?: BoolFilter<"Message"> | boolean
    priority?: EnumMessagePriorityFilter<"Message"> | $Enums.MessagePriority
    approvalOverride?: EnumApprovalPolicyNullableFilter<"Message"> | $Enums.ApprovalPolicy | null
    approvalOverrideSetBy?: StringNullableFilter<"Message"> | string | null
    approvalOverrideSetAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    deliveryMethod?: EnumDeliveryMethodFilter<"Message"> | $Enums.DeliveryMethod
    eventAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    publishedAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    state?: EnumMessageStateFilter<"Message"> | $Enums.MessageState
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    channel?: XOR<ChannelRelationFilter, ChannelWhereInput>
    sender?: XOR<UserRelationFilter, UserWhereInput>
    category?: XOR<MessageCategoryRelationFilter, MessageCategoryWhereInput>
    overrideSetter?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    deliveries?: MessageDeliveryListRelationFilter
    approvals?: MessageApprovalListRelationFilter
    attachments?: MessageAttachmentListRelationFilter
    revisions?: MessageRevisionListRelationFilter
    views?: MessageViewListRelationFilter
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    channelId?: SortOrder
    senderId?: SortOrder
    categoryId?: SortOrder
    content?: SortOrder
    durationSeconds?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    isEmergency?: SortOrder
    isImmediate?: SortOrder
    priority?: SortOrder
    approvalOverride?: SortOrderInput | SortOrder
    approvalOverrideSetBy?: SortOrderInput | SortOrder
    approvalOverrideSetAt?: SortOrderInput | SortOrder
    deliveryMethod?: SortOrder
    eventAt?: SortOrderInput | SortOrder
    publishedAt?: SortOrderInput | SortOrder
    state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    channel?: ChannelOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
    category?: MessageCategoryOrderByWithRelationInput
    overrideSetter?: UserOrderByWithRelationInput
    deliveries?: MessageDeliveryOrderByRelationAggregateInput
    approvals?: MessageApprovalOrderByRelationAggregateInput
    attachments?: MessageAttachmentOrderByRelationAggregateInput
    revisions?: MessageRevisionOrderByRelationAggregateInput
    views?: MessageViewOrderByRelationAggregateInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    channelId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    categoryId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    durationSeconds?: IntFilter<"Message"> | number
    expiresAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    isEmergency?: BoolFilter<"Message"> | boolean
    isImmediate?: BoolFilter<"Message"> | boolean
    priority?: EnumMessagePriorityFilter<"Message"> | $Enums.MessagePriority
    approvalOverride?: EnumApprovalPolicyNullableFilter<"Message"> | $Enums.ApprovalPolicy | null
    approvalOverrideSetBy?: StringNullableFilter<"Message"> | string | null
    approvalOverrideSetAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    deliveryMethod?: EnumDeliveryMethodFilter<"Message"> | $Enums.DeliveryMethod
    eventAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    publishedAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    state?: EnumMessageStateFilter<"Message"> | $Enums.MessageState
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    channel?: XOR<ChannelRelationFilter, ChannelWhereInput>
    sender?: XOR<UserRelationFilter, UserWhereInput>
    category?: XOR<MessageCategoryRelationFilter, MessageCategoryWhereInput>
    overrideSetter?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    deliveries?: MessageDeliveryListRelationFilter
    approvals?: MessageApprovalListRelationFilter
    attachments?: MessageAttachmentListRelationFilter
    revisions?: MessageRevisionListRelationFilter
    views?: MessageViewListRelationFilter
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    channelId?: SortOrder
    senderId?: SortOrder
    categoryId?: SortOrder
    content?: SortOrder
    durationSeconds?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    isEmergency?: SortOrder
    isImmediate?: SortOrder
    priority?: SortOrder
    approvalOverride?: SortOrderInput | SortOrder
    approvalOverrideSetBy?: SortOrderInput | SortOrder
    approvalOverrideSetAt?: SortOrderInput | SortOrder
    deliveryMethod?: SortOrder
    eventAt?: SortOrderInput | SortOrder
    publishedAt?: SortOrderInput | SortOrder
    state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _avg?: MessageAvgOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
    _sum?: MessageSumOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    channelId?: StringWithAggregatesFilter<"Message"> | string
    senderId?: StringWithAggregatesFilter<"Message"> | string
    categoryId?: StringWithAggregatesFilter<"Message"> | string
    content?: StringWithAggregatesFilter<"Message"> | string
    durationSeconds?: IntWithAggregatesFilter<"Message"> | number
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Message"> | Date | string | null
    isEmergency?: BoolWithAggregatesFilter<"Message"> | boolean
    isImmediate?: BoolWithAggregatesFilter<"Message"> | boolean
    priority?: EnumMessagePriorityWithAggregatesFilter<"Message"> | $Enums.MessagePriority
    approvalOverride?: EnumApprovalPolicyNullableWithAggregatesFilter<"Message"> | $Enums.ApprovalPolicy | null
    approvalOverrideSetBy?: StringNullableWithAggregatesFilter<"Message"> | string | null
    approvalOverrideSetAt?: DateTimeNullableWithAggregatesFilter<"Message"> | Date | string | null
    deliveryMethod?: EnumDeliveryMethodWithAggregatesFilter<"Message"> | $Enums.DeliveryMethod
    eventAt?: DateTimeNullableWithAggregatesFilter<"Message"> | Date | string | null
    publishedAt?: DateTimeNullableWithAggregatesFilter<"Message"> | Date | string | null
    state?: EnumMessageStateWithAggregatesFilter<"Message"> | $Enums.MessageState
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type ChannelSubscriptionWhereInput = {
    AND?: ChannelSubscriptionWhereInput | ChannelSubscriptionWhereInput[]
    OR?: ChannelSubscriptionWhereInput[]
    NOT?: ChannelSubscriptionWhereInput | ChannelSubscriptionWhereInput[]
    id?: StringFilter<"ChannelSubscription"> | string
    userId?: StringFilter<"ChannelSubscription"> | string
    channelId?: StringFilter<"ChannelSubscription"> | string
    subscribedAt?: DateTimeFilter<"ChannelSubscription"> | Date | string
    isActive?: BoolFilter<"ChannelSubscription"> | boolean
    isFavorite?: BoolFilter<"ChannelSubscription"> | boolean
    receiveMessages?: BoolFilter<"ChannelSubscription"> | boolean
    user?: XOR<UserRelationFilter, UserWhereInput>
    channel?: XOR<ChannelRelationFilter, ChannelWhereInput>
  }

  export type ChannelSubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    channelId?: SortOrder
    subscribedAt?: SortOrder
    isActive?: SortOrder
    isFavorite?: SortOrder
    receiveMessages?: SortOrder
    user?: UserOrderByWithRelationInput
    channel?: ChannelOrderByWithRelationInput
  }

  export type ChannelSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_channelId?: ChannelSubscriptionUserIdChannelIdCompoundUniqueInput
    AND?: ChannelSubscriptionWhereInput | ChannelSubscriptionWhereInput[]
    OR?: ChannelSubscriptionWhereInput[]
    NOT?: ChannelSubscriptionWhereInput | ChannelSubscriptionWhereInput[]
    userId?: StringFilter<"ChannelSubscription"> | string
    channelId?: StringFilter<"ChannelSubscription"> | string
    subscribedAt?: DateTimeFilter<"ChannelSubscription"> | Date | string
    isActive?: BoolFilter<"ChannelSubscription"> | boolean
    isFavorite?: BoolFilter<"ChannelSubscription"> | boolean
    receiveMessages?: BoolFilter<"ChannelSubscription"> | boolean
    user?: XOR<UserRelationFilter, UserWhereInput>
    channel?: XOR<ChannelRelationFilter, ChannelWhereInput>
  }, "id" | "userId_channelId">

  export type ChannelSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    channelId?: SortOrder
    subscribedAt?: SortOrder
    isActive?: SortOrder
    isFavorite?: SortOrder
    receiveMessages?: SortOrder
    _count?: ChannelSubscriptionCountOrderByAggregateInput
    _max?: ChannelSubscriptionMaxOrderByAggregateInput
    _min?: ChannelSubscriptionMinOrderByAggregateInput
  }

  export type ChannelSubscriptionScalarWhereWithAggregatesInput = {
    AND?: ChannelSubscriptionScalarWhereWithAggregatesInput | ChannelSubscriptionScalarWhereWithAggregatesInput[]
    OR?: ChannelSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: ChannelSubscriptionScalarWhereWithAggregatesInput | ChannelSubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChannelSubscription"> | string
    userId?: StringWithAggregatesFilter<"ChannelSubscription"> | string
    channelId?: StringWithAggregatesFilter<"ChannelSubscription"> | string
    subscribedAt?: DateTimeWithAggregatesFilter<"ChannelSubscription"> | Date | string
    isActive?: BoolWithAggregatesFilter<"ChannelSubscription"> | boolean
    isFavorite?: BoolWithAggregatesFilter<"ChannelSubscription"> | boolean
    receiveMessages?: BoolWithAggregatesFilter<"ChannelSubscription"> | boolean
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    actorId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    targetUserId?: StringNullableFilter<"AuditLog"> | string | null
    targetChannelId?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    actorId?: SortOrder
    action?: SortOrder
    targetUserId?: SortOrderInput | SortOrder
    targetChannelId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    actorId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    targetUserId?: StringNullableFilter<"AuditLog"> | string | null
    targetChannelId?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    actorId?: SortOrder
    action?: SortOrder
    targetUserId?: SortOrderInput | SortOrder
    targetChannelId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    actorId?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    targetUserId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    targetChannelId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    details?: JsonNullableWithAggregatesFilter<"AuditLog">
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type MessageDeliveryWhereInput = {
    AND?: MessageDeliveryWhereInput | MessageDeliveryWhereInput[]
    OR?: MessageDeliveryWhereInput[]
    NOT?: MessageDeliveryWhereInput | MessageDeliveryWhereInput[]
    id?: StringFilter<"MessageDelivery"> | string
    messageId?: StringFilter<"MessageDelivery"> | string
    userId?: StringFilter<"MessageDelivery"> | string
    deliveryStatus?: EnumDeliveryStatusFilter<"MessageDelivery"> | $Enums.DeliveryStatus
    deliveryMethod?: EnumDeliveryMethodNullableFilter<"MessageDelivery"> | $Enums.DeliveryMethod | null
    deliveredAt?: DateTimeNullableFilter<"MessageDelivery"> | Date | string | null
    readAt?: DateTimeNullableFilter<"MessageDelivery"> | Date | string | null
    createdAt?: DateTimeFilter<"MessageDelivery"> | Date | string
    message?: XOR<MessageRelationFilter, MessageWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type MessageDeliveryOrderByWithRelationInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    deliveryStatus?: SortOrder
    deliveryMethod?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    message?: MessageOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type MessageDeliveryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageDeliveryWhereInput | MessageDeliveryWhereInput[]
    OR?: MessageDeliveryWhereInput[]
    NOT?: MessageDeliveryWhereInput | MessageDeliveryWhereInput[]
    messageId?: StringFilter<"MessageDelivery"> | string
    userId?: StringFilter<"MessageDelivery"> | string
    deliveryStatus?: EnumDeliveryStatusFilter<"MessageDelivery"> | $Enums.DeliveryStatus
    deliveryMethod?: EnumDeliveryMethodNullableFilter<"MessageDelivery"> | $Enums.DeliveryMethod | null
    deliveredAt?: DateTimeNullableFilter<"MessageDelivery"> | Date | string | null
    readAt?: DateTimeNullableFilter<"MessageDelivery"> | Date | string | null
    createdAt?: DateTimeFilter<"MessageDelivery"> | Date | string
    message?: XOR<MessageRelationFilter, MessageWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type MessageDeliveryOrderByWithAggregationInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    deliveryStatus?: SortOrder
    deliveryMethod?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MessageDeliveryCountOrderByAggregateInput
    _max?: MessageDeliveryMaxOrderByAggregateInput
    _min?: MessageDeliveryMinOrderByAggregateInput
  }

  export type MessageDeliveryScalarWhereWithAggregatesInput = {
    AND?: MessageDeliveryScalarWhereWithAggregatesInput | MessageDeliveryScalarWhereWithAggregatesInput[]
    OR?: MessageDeliveryScalarWhereWithAggregatesInput[]
    NOT?: MessageDeliveryScalarWhereWithAggregatesInput | MessageDeliveryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MessageDelivery"> | string
    messageId?: StringWithAggregatesFilter<"MessageDelivery"> | string
    userId?: StringWithAggregatesFilter<"MessageDelivery"> | string
    deliveryStatus?: EnumDeliveryStatusWithAggregatesFilter<"MessageDelivery"> | $Enums.DeliveryStatus
    deliveryMethod?: EnumDeliveryMethodNullableWithAggregatesFilter<"MessageDelivery"> | $Enums.DeliveryMethod | null
    deliveredAt?: DateTimeNullableWithAggregatesFilter<"MessageDelivery"> | Date | string | null
    readAt?: DateTimeNullableWithAggregatesFilter<"MessageDelivery"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MessageDelivery"> | Date | string
  }

  export type InvitationLinkWhereInput = {
    AND?: InvitationLinkWhereInput | InvitationLinkWhereInput[]
    OR?: InvitationLinkWhereInput[]
    NOT?: InvitationLinkWhereInput | InvitationLinkWhereInput[]
    id?: StringFilter<"InvitationLink"> | string
    channelId?: StringFilter<"InvitationLink"> | string
    createdBy?: StringFilter<"InvitationLink"> | string
    linkCode?: StringFilter<"InvitationLink"> | string
    expiresAt?: DateTimeNullableFilter<"InvitationLink"> | Date | string | null
    maxUses?: IntNullableFilter<"InvitationLink"> | number | null
    currentUses?: IntFilter<"InvitationLink"> | number
    isActive?: BoolFilter<"InvitationLink"> | boolean
    createdAt?: DateTimeFilter<"InvitationLink"> | Date | string
    channel?: XOR<ChannelRelationFilter, ChannelWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type InvitationLinkOrderByWithRelationInput = {
    id?: SortOrder
    channelId?: SortOrder
    createdBy?: SortOrder
    linkCode?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    maxUses?: SortOrderInput | SortOrder
    currentUses?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    channel?: ChannelOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
  }

  export type InvitationLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    linkCode?: string
    AND?: InvitationLinkWhereInput | InvitationLinkWhereInput[]
    OR?: InvitationLinkWhereInput[]
    NOT?: InvitationLinkWhereInput | InvitationLinkWhereInput[]
    channelId?: StringFilter<"InvitationLink"> | string
    createdBy?: StringFilter<"InvitationLink"> | string
    expiresAt?: DateTimeNullableFilter<"InvitationLink"> | Date | string | null
    maxUses?: IntNullableFilter<"InvitationLink"> | number | null
    currentUses?: IntFilter<"InvitationLink"> | number
    isActive?: BoolFilter<"InvitationLink"> | boolean
    createdAt?: DateTimeFilter<"InvitationLink"> | Date | string
    channel?: XOR<ChannelRelationFilter, ChannelWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "linkCode">

  export type InvitationLinkOrderByWithAggregationInput = {
    id?: SortOrder
    channelId?: SortOrder
    createdBy?: SortOrder
    linkCode?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    maxUses?: SortOrderInput | SortOrder
    currentUses?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: InvitationLinkCountOrderByAggregateInput
    _avg?: InvitationLinkAvgOrderByAggregateInput
    _max?: InvitationLinkMaxOrderByAggregateInput
    _min?: InvitationLinkMinOrderByAggregateInput
    _sum?: InvitationLinkSumOrderByAggregateInput
  }

  export type InvitationLinkScalarWhereWithAggregatesInput = {
    AND?: InvitationLinkScalarWhereWithAggregatesInput | InvitationLinkScalarWhereWithAggregatesInput[]
    OR?: InvitationLinkScalarWhereWithAggregatesInput[]
    NOT?: InvitationLinkScalarWhereWithAggregatesInput | InvitationLinkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InvitationLink"> | string
    channelId?: StringWithAggregatesFilter<"InvitationLink"> | string
    createdBy?: StringWithAggregatesFilter<"InvitationLink"> | string
    linkCode?: StringWithAggregatesFilter<"InvitationLink"> | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"InvitationLink"> | Date | string | null
    maxUses?: IntNullableWithAggregatesFilter<"InvitationLink"> | number | null
    currentUses?: IntWithAggregatesFilter<"InvitationLink"> | number
    isActive?: BoolWithAggregatesFilter<"InvitationLink"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"InvitationLink"> | Date | string
  }

  export type QrCodeWhereInput = {
    AND?: QrCodeWhereInput | QrCodeWhereInput[]
    OR?: QrCodeWhereInput[]
    NOT?: QrCodeWhereInput | QrCodeWhereInput[]
    id?: StringFilter<"QrCode"> | string
    channelId?: StringFilter<"QrCode"> | string
    createdBy?: StringFilter<"QrCode"> | string
    qrData?: StringFilter<"QrCode"> | string
    expiresAt?: DateTimeNullableFilter<"QrCode"> | Date | string | null
    scanCount?: IntFilter<"QrCode"> | number
    isActive?: BoolFilter<"QrCode"> | boolean
    createdAt?: DateTimeFilter<"QrCode"> | Date | string
    channel?: XOR<ChannelRelationFilter, ChannelWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type QrCodeOrderByWithRelationInput = {
    id?: SortOrder
    channelId?: SortOrder
    createdBy?: SortOrder
    qrData?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    scanCount?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    channel?: ChannelOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
  }

  export type QrCodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QrCodeWhereInput | QrCodeWhereInput[]
    OR?: QrCodeWhereInput[]
    NOT?: QrCodeWhereInput | QrCodeWhereInput[]
    channelId?: StringFilter<"QrCode"> | string
    createdBy?: StringFilter<"QrCode"> | string
    qrData?: StringFilter<"QrCode"> | string
    expiresAt?: DateTimeNullableFilter<"QrCode"> | Date | string | null
    scanCount?: IntFilter<"QrCode"> | number
    isActive?: BoolFilter<"QrCode"> | boolean
    createdAt?: DateTimeFilter<"QrCode"> | Date | string
    channel?: XOR<ChannelRelationFilter, ChannelWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type QrCodeOrderByWithAggregationInput = {
    id?: SortOrder
    channelId?: SortOrder
    createdBy?: SortOrder
    qrData?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    scanCount?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: QrCodeCountOrderByAggregateInput
    _avg?: QrCodeAvgOrderByAggregateInput
    _max?: QrCodeMaxOrderByAggregateInput
    _min?: QrCodeMinOrderByAggregateInput
    _sum?: QrCodeSumOrderByAggregateInput
  }

  export type QrCodeScalarWhereWithAggregatesInput = {
    AND?: QrCodeScalarWhereWithAggregatesInput | QrCodeScalarWhereWithAggregatesInput[]
    OR?: QrCodeScalarWhereWithAggregatesInput[]
    NOT?: QrCodeScalarWhereWithAggregatesInput | QrCodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QrCode"> | string
    channelId?: StringWithAggregatesFilter<"QrCode"> | string
    createdBy?: StringWithAggregatesFilter<"QrCode"> | string
    qrData?: StringWithAggregatesFilter<"QrCode"> | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"QrCode"> | Date | string | null
    scanCount?: IntWithAggregatesFilter<"QrCode"> | number
    isActive?: BoolWithAggregatesFilter<"QrCode"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"QrCode"> | Date | string
  }

  export type OrganizationWhereInput = {
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    id?: StringFilter<"Organization"> | string
    name?: StringFilter<"Organization"> | string
    nit?: StringFilter<"Organization"> | string
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    channels?: ChannelListRelationFilter
  }

  export type OrganizationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    nit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    channels?: ChannelOrderByRelationAggregateInput
  }

  export type OrganizationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    nit?: string
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    name?: StringFilter<"Organization"> | string
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    channels?: ChannelListRelationFilter
  }, "id" | "nit">

  export type OrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    nit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrganizationCountOrderByAggregateInput
    _max?: OrganizationMaxOrderByAggregateInput
    _min?: OrganizationMinOrderByAggregateInput
  }

  export type OrganizationScalarWhereWithAggregatesInput = {
    AND?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    OR?: OrganizationScalarWhereWithAggregatesInput[]
    NOT?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Organization"> | string
    name?: StringWithAggregatesFilter<"Organization"> | string
    nit?: StringWithAggregatesFilter<"Organization"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
  }

  export type ChannelApproverWhereInput = {
    AND?: ChannelApproverWhereInput | ChannelApproverWhereInput[]
    OR?: ChannelApproverWhereInput[]
    NOT?: ChannelApproverWhereInput | ChannelApproverWhereInput[]
    id?: StringFilter<"ChannelApprover"> | string
    channelId?: StringFilter<"ChannelApprover"> | string
    userId?: StringFilter<"ChannelApprover"> | string
    isActive?: BoolFilter<"ChannelApprover"> | boolean
    removedAt?: DateTimeNullableFilter<"ChannelApprover"> | Date | string | null
    removedBy?: StringNullableFilter<"ChannelApprover"> | string | null
    createdAt?: DateTimeFilter<"ChannelApprover"> | Date | string
    channel?: XOR<ChannelRelationFilter, ChannelWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ChannelApproverOrderByWithRelationInput = {
    id?: SortOrder
    channelId?: SortOrder
    userId?: SortOrder
    isActive?: SortOrder
    removedAt?: SortOrderInput | SortOrder
    removedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    channel?: ChannelOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ChannelApproverWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    channelId_userId?: ChannelApproverChannelIdUserIdCompoundUniqueInput
    AND?: ChannelApproverWhereInput | ChannelApproverWhereInput[]
    OR?: ChannelApproverWhereInput[]
    NOT?: ChannelApproverWhereInput | ChannelApproverWhereInput[]
    channelId?: StringFilter<"ChannelApprover"> | string
    userId?: StringFilter<"ChannelApprover"> | string
    isActive?: BoolFilter<"ChannelApprover"> | boolean
    removedAt?: DateTimeNullableFilter<"ChannelApprover"> | Date | string | null
    removedBy?: StringNullableFilter<"ChannelApprover"> | string | null
    createdAt?: DateTimeFilter<"ChannelApprover"> | Date | string
    channel?: XOR<ChannelRelationFilter, ChannelWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "channelId_userId">

  export type ChannelApproverOrderByWithAggregationInput = {
    id?: SortOrder
    channelId?: SortOrder
    userId?: SortOrder
    isActive?: SortOrder
    removedAt?: SortOrderInput | SortOrder
    removedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ChannelApproverCountOrderByAggregateInput
    _max?: ChannelApproverMaxOrderByAggregateInput
    _min?: ChannelApproverMinOrderByAggregateInput
  }

  export type ChannelApproverScalarWhereWithAggregatesInput = {
    AND?: ChannelApproverScalarWhereWithAggregatesInput | ChannelApproverScalarWhereWithAggregatesInput[]
    OR?: ChannelApproverScalarWhereWithAggregatesInput[]
    NOT?: ChannelApproverScalarWhereWithAggregatesInput | ChannelApproverScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChannelApprover"> | string
    channelId?: StringWithAggregatesFilter<"ChannelApprover"> | string
    userId?: StringWithAggregatesFilter<"ChannelApprover"> | string
    isActive?: BoolWithAggregatesFilter<"ChannelApprover"> | boolean
    removedAt?: DateTimeNullableWithAggregatesFilter<"ChannelApprover"> | Date | string | null
    removedBy?: StringNullableWithAggregatesFilter<"ChannelApprover"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ChannelApprover"> | Date | string
  }

  export type MessageApprovalWhereInput = {
    AND?: MessageApprovalWhereInput | MessageApprovalWhereInput[]
    OR?: MessageApprovalWhereInput[]
    NOT?: MessageApprovalWhereInput | MessageApprovalWhereInput[]
    id?: StringFilter<"MessageApproval"> | string
    messageId?: StringFilter<"MessageApproval"> | string
    approverId?: StringFilter<"MessageApproval"> | string
    status?: EnumApprovalStatusFilter<"MessageApproval"> | $Enums.ApprovalStatus
    decidedAt?: DateTimeNullableFilter<"MessageApproval"> | Date | string | null
    message?: XOR<MessageRelationFilter, MessageWhereInput>
    approver?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type MessageApprovalOrderByWithRelationInput = {
    id?: SortOrder
    messageId?: SortOrder
    approverId?: SortOrder
    status?: SortOrder
    decidedAt?: SortOrderInput | SortOrder
    message?: MessageOrderByWithRelationInput
    approver?: UserOrderByWithRelationInput
  }

  export type MessageApprovalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    messageId_approverId?: MessageApprovalMessageIdApproverIdCompoundUniqueInput
    AND?: MessageApprovalWhereInput | MessageApprovalWhereInput[]
    OR?: MessageApprovalWhereInput[]
    NOT?: MessageApprovalWhereInput | MessageApprovalWhereInput[]
    messageId?: StringFilter<"MessageApproval"> | string
    approverId?: StringFilter<"MessageApproval"> | string
    status?: EnumApprovalStatusFilter<"MessageApproval"> | $Enums.ApprovalStatus
    decidedAt?: DateTimeNullableFilter<"MessageApproval"> | Date | string | null
    message?: XOR<MessageRelationFilter, MessageWhereInput>
    approver?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "messageId_approverId">

  export type MessageApprovalOrderByWithAggregationInput = {
    id?: SortOrder
    messageId?: SortOrder
    approverId?: SortOrder
    status?: SortOrder
    decidedAt?: SortOrderInput | SortOrder
    _count?: MessageApprovalCountOrderByAggregateInput
    _max?: MessageApprovalMaxOrderByAggregateInput
    _min?: MessageApprovalMinOrderByAggregateInput
  }

  export type MessageApprovalScalarWhereWithAggregatesInput = {
    AND?: MessageApprovalScalarWhereWithAggregatesInput | MessageApprovalScalarWhereWithAggregatesInput[]
    OR?: MessageApprovalScalarWhereWithAggregatesInput[]
    NOT?: MessageApprovalScalarWhereWithAggregatesInput | MessageApprovalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MessageApproval"> | string
    messageId?: StringWithAggregatesFilter<"MessageApproval"> | string
    approverId?: StringWithAggregatesFilter<"MessageApproval"> | string
    status?: EnumApprovalStatusWithAggregatesFilter<"MessageApproval"> | $Enums.ApprovalStatus
    decidedAt?: DateTimeNullableWithAggregatesFilter<"MessageApproval"> | Date | string | null
  }

  export type MessageCategoryWhereInput = {
    AND?: MessageCategoryWhereInput | MessageCategoryWhereInput[]
    OR?: MessageCategoryWhereInput[]
    NOT?: MessageCategoryWhereInput | MessageCategoryWhereInput[]
    id?: StringFilter<"MessageCategory"> | string
    name?: StringFilter<"MessageCategory"> | string
    scope?: EnumCategoryScopeFilter<"MessageCategory"> | $Enums.CategoryScope
    channelId?: StringNullableFilter<"MessageCategory"> | string | null
    createdBy?: StringNullableFilter<"MessageCategory"> | string | null
    createdAt?: DateTimeFilter<"MessageCategory"> | Date | string
    channel?: XOR<ChannelNullableRelationFilter, ChannelWhereInput> | null
    creator?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    messages?: MessageListRelationFilter
  }

  export type MessageCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    scope?: SortOrder
    channelId?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    channel?: ChannelOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    messages?: MessageOrderByRelationAggregateInput
  }

  export type MessageCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    channelId_name?: MessageCategoryChannelIdNameCompoundUniqueInput
    AND?: MessageCategoryWhereInput | MessageCategoryWhereInput[]
    OR?: MessageCategoryWhereInput[]
    NOT?: MessageCategoryWhereInput | MessageCategoryWhereInput[]
    name?: StringFilter<"MessageCategory"> | string
    scope?: EnumCategoryScopeFilter<"MessageCategory"> | $Enums.CategoryScope
    channelId?: StringNullableFilter<"MessageCategory"> | string | null
    createdBy?: StringNullableFilter<"MessageCategory"> | string | null
    createdAt?: DateTimeFilter<"MessageCategory"> | Date | string
    channel?: XOR<ChannelNullableRelationFilter, ChannelWhereInput> | null
    creator?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    messages?: MessageListRelationFilter
  }, "id" | "channelId_name">

  export type MessageCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    scope?: SortOrder
    channelId?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MessageCategoryCountOrderByAggregateInput
    _max?: MessageCategoryMaxOrderByAggregateInput
    _min?: MessageCategoryMinOrderByAggregateInput
  }

  export type MessageCategoryScalarWhereWithAggregatesInput = {
    AND?: MessageCategoryScalarWhereWithAggregatesInput | MessageCategoryScalarWhereWithAggregatesInput[]
    OR?: MessageCategoryScalarWhereWithAggregatesInput[]
    NOT?: MessageCategoryScalarWhereWithAggregatesInput | MessageCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MessageCategory"> | string
    name?: StringWithAggregatesFilter<"MessageCategory"> | string
    scope?: EnumCategoryScopeWithAggregatesFilter<"MessageCategory"> | $Enums.CategoryScope
    channelId?: StringNullableWithAggregatesFilter<"MessageCategory"> | string | null
    createdBy?: StringNullableWithAggregatesFilter<"MessageCategory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MessageCategory"> | Date | string
  }

  export type MessageAttachmentWhereInput = {
    AND?: MessageAttachmentWhereInput | MessageAttachmentWhereInput[]
    OR?: MessageAttachmentWhereInput[]
    NOT?: MessageAttachmentWhereInput | MessageAttachmentWhereInput[]
    id?: StringFilter<"MessageAttachment"> | string
    messageId?: StringFilter<"MessageAttachment"> | string
    type?: EnumAttachmentTypeFilter<"MessageAttachment"> | $Enums.AttachmentType
    url?: StringFilter<"MessageAttachment"> | string
    metadata?: JsonNullableFilter<"MessageAttachment">
    createdAt?: DateTimeFilter<"MessageAttachment"> | Date | string
    message?: XOR<MessageRelationFilter, MessageWhereInput>
  }

  export type MessageAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    messageId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    message?: MessageOrderByWithRelationInput
  }

  export type MessageAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageAttachmentWhereInput | MessageAttachmentWhereInput[]
    OR?: MessageAttachmentWhereInput[]
    NOT?: MessageAttachmentWhereInput | MessageAttachmentWhereInput[]
    messageId?: StringFilter<"MessageAttachment"> | string
    type?: EnumAttachmentTypeFilter<"MessageAttachment"> | $Enums.AttachmentType
    url?: StringFilter<"MessageAttachment"> | string
    metadata?: JsonNullableFilter<"MessageAttachment">
    createdAt?: DateTimeFilter<"MessageAttachment"> | Date | string
    message?: XOR<MessageRelationFilter, MessageWhereInput>
  }, "id">

  export type MessageAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    messageId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MessageAttachmentCountOrderByAggregateInput
    _max?: MessageAttachmentMaxOrderByAggregateInput
    _min?: MessageAttachmentMinOrderByAggregateInput
  }

  export type MessageAttachmentScalarWhereWithAggregatesInput = {
    AND?: MessageAttachmentScalarWhereWithAggregatesInput | MessageAttachmentScalarWhereWithAggregatesInput[]
    OR?: MessageAttachmentScalarWhereWithAggregatesInput[]
    NOT?: MessageAttachmentScalarWhereWithAggregatesInput | MessageAttachmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MessageAttachment"> | string
    messageId?: StringWithAggregatesFilter<"MessageAttachment"> | string
    type?: EnumAttachmentTypeWithAggregatesFilter<"MessageAttachment"> | $Enums.AttachmentType
    url?: StringWithAggregatesFilter<"MessageAttachment"> | string
    metadata?: JsonNullableWithAggregatesFilter<"MessageAttachment">
    createdAt?: DateTimeWithAggregatesFilter<"MessageAttachment"> | Date | string
  }

  export type MessageRevisionWhereInput = {
    AND?: MessageRevisionWhereInput | MessageRevisionWhereInput[]
    OR?: MessageRevisionWhereInput[]
    NOT?: MessageRevisionWhereInput | MessageRevisionWhereInput[]
    id?: StringFilter<"MessageRevision"> | string
    messageId?: StringFilter<"MessageRevision"> | string
    editorId?: StringFilter<"MessageRevision"> | string
    previousContent?: StringFilter<"MessageRevision"> | string
    previousCategoryId?: StringNullableFilter<"MessageRevision"> | string | null
    previousPriority?: EnumMessagePriorityFilter<"MessageRevision"> | $Enums.MessagePriority
    previousIsImmediate?: BoolFilter<"MessageRevision"> | boolean
    previousDeliveryMethod?: EnumDeliveryMethodFilter<"MessageRevision"> | $Enums.DeliveryMethod
    changedAt?: DateTimeFilter<"MessageRevision"> | Date | string
    message?: XOR<MessageRelationFilter, MessageWhereInput>
    editor?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type MessageRevisionOrderByWithRelationInput = {
    id?: SortOrder
    messageId?: SortOrder
    editorId?: SortOrder
    previousContent?: SortOrder
    previousCategoryId?: SortOrderInput | SortOrder
    previousPriority?: SortOrder
    previousIsImmediate?: SortOrder
    previousDeliveryMethod?: SortOrder
    changedAt?: SortOrder
    message?: MessageOrderByWithRelationInput
    editor?: UserOrderByWithRelationInput
  }

  export type MessageRevisionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageRevisionWhereInput | MessageRevisionWhereInput[]
    OR?: MessageRevisionWhereInput[]
    NOT?: MessageRevisionWhereInput | MessageRevisionWhereInput[]
    messageId?: StringFilter<"MessageRevision"> | string
    editorId?: StringFilter<"MessageRevision"> | string
    previousContent?: StringFilter<"MessageRevision"> | string
    previousCategoryId?: StringNullableFilter<"MessageRevision"> | string | null
    previousPriority?: EnumMessagePriorityFilter<"MessageRevision"> | $Enums.MessagePriority
    previousIsImmediate?: BoolFilter<"MessageRevision"> | boolean
    previousDeliveryMethod?: EnumDeliveryMethodFilter<"MessageRevision"> | $Enums.DeliveryMethod
    changedAt?: DateTimeFilter<"MessageRevision"> | Date | string
    message?: XOR<MessageRelationFilter, MessageWhereInput>
    editor?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type MessageRevisionOrderByWithAggregationInput = {
    id?: SortOrder
    messageId?: SortOrder
    editorId?: SortOrder
    previousContent?: SortOrder
    previousCategoryId?: SortOrderInput | SortOrder
    previousPriority?: SortOrder
    previousIsImmediate?: SortOrder
    previousDeliveryMethod?: SortOrder
    changedAt?: SortOrder
    _count?: MessageRevisionCountOrderByAggregateInput
    _max?: MessageRevisionMaxOrderByAggregateInput
    _min?: MessageRevisionMinOrderByAggregateInput
  }

  export type MessageRevisionScalarWhereWithAggregatesInput = {
    AND?: MessageRevisionScalarWhereWithAggregatesInput | MessageRevisionScalarWhereWithAggregatesInput[]
    OR?: MessageRevisionScalarWhereWithAggregatesInput[]
    NOT?: MessageRevisionScalarWhereWithAggregatesInput | MessageRevisionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MessageRevision"> | string
    messageId?: StringWithAggregatesFilter<"MessageRevision"> | string
    editorId?: StringWithAggregatesFilter<"MessageRevision"> | string
    previousContent?: StringWithAggregatesFilter<"MessageRevision"> | string
    previousCategoryId?: StringNullableWithAggregatesFilter<"MessageRevision"> | string | null
    previousPriority?: EnumMessagePriorityWithAggregatesFilter<"MessageRevision"> | $Enums.MessagePriority
    previousIsImmediate?: BoolWithAggregatesFilter<"MessageRevision"> | boolean
    previousDeliveryMethod?: EnumDeliveryMethodWithAggregatesFilter<"MessageRevision"> | $Enums.DeliveryMethod
    changedAt?: DateTimeWithAggregatesFilter<"MessageRevision"> | Date | string
  }

  export type ChannelVerificationDocumentWhereInput = {
    AND?: ChannelVerificationDocumentWhereInput | ChannelVerificationDocumentWhereInput[]
    OR?: ChannelVerificationDocumentWhereInput[]
    NOT?: ChannelVerificationDocumentWhereInput | ChannelVerificationDocumentWhereInput[]
    id?: StringFilter<"ChannelVerificationDocument"> | string
    channelId?: StringFilter<"ChannelVerificationDocument"> | string
    title?: StringFilter<"ChannelVerificationDocument"> | string
    docUrl?: StringFilter<"ChannelVerificationDocument"> | string
    issuer?: StringNullableFilter<"ChannelVerificationDocument"> | string | null
    issuedAt?: DateTimeNullableFilter<"ChannelVerificationDocument"> | Date | string | null
    createdAt?: DateTimeFilter<"ChannelVerificationDocument"> | Date | string
    channel?: XOR<ChannelRelationFilter, ChannelWhereInput>
  }

  export type ChannelVerificationDocumentOrderByWithRelationInput = {
    id?: SortOrder
    channelId?: SortOrder
    title?: SortOrder
    docUrl?: SortOrder
    issuer?: SortOrderInput | SortOrder
    issuedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    channel?: ChannelOrderByWithRelationInput
  }

  export type ChannelVerificationDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChannelVerificationDocumentWhereInput | ChannelVerificationDocumentWhereInput[]
    OR?: ChannelVerificationDocumentWhereInput[]
    NOT?: ChannelVerificationDocumentWhereInput | ChannelVerificationDocumentWhereInput[]
    channelId?: StringFilter<"ChannelVerificationDocument"> | string
    title?: StringFilter<"ChannelVerificationDocument"> | string
    docUrl?: StringFilter<"ChannelVerificationDocument"> | string
    issuer?: StringNullableFilter<"ChannelVerificationDocument"> | string | null
    issuedAt?: DateTimeNullableFilter<"ChannelVerificationDocument"> | Date | string | null
    createdAt?: DateTimeFilter<"ChannelVerificationDocument"> | Date | string
    channel?: XOR<ChannelRelationFilter, ChannelWhereInput>
  }, "id">

  export type ChannelVerificationDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    channelId?: SortOrder
    title?: SortOrder
    docUrl?: SortOrder
    issuer?: SortOrderInput | SortOrder
    issuedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ChannelVerificationDocumentCountOrderByAggregateInput
    _max?: ChannelVerificationDocumentMaxOrderByAggregateInput
    _min?: ChannelVerificationDocumentMinOrderByAggregateInput
  }

  export type ChannelVerificationDocumentScalarWhereWithAggregatesInput = {
    AND?: ChannelVerificationDocumentScalarWhereWithAggregatesInput | ChannelVerificationDocumentScalarWhereWithAggregatesInput[]
    OR?: ChannelVerificationDocumentScalarWhereWithAggregatesInput[]
    NOT?: ChannelVerificationDocumentScalarWhereWithAggregatesInput | ChannelVerificationDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChannelVerificationDocument"> | string
    channelId?: StringWithAggregatesFilter<"ChannelVerificationDocument"> | string
    title?: StringWithAggregatesFilter<"ChannelVerificationDocument"> | string
    docUrl?: StringWithAggregatesFilter<"ChannelVerificationDocument"> | string
    issuer?: StringNullableWithAggregatesFilter<"ChannelVerificationDocument"> | string | null
    issuedAt?: DateTimeNullableWithAggregatesFilter<"ChannelVerificationDocument"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ChannelVerificationDocument"> | Date | string
  }

  export type UserProfileWhereInput = {
    AND?: UserProfileWhereInput | UserProfileWhereInput[]
    OR?: UserProfileWhereInput[]
    NOT?: UserProfileWhereInput | UserProfileWhereInput[]
    id?: StringFilter<"UserProfile"> | string
    userId?: StringFilter<"UserProfile"> | string
    country?: StringNullableFilter<"UserProfile"> | string | null
    department?: StringNullableFilter<"UserProfile"> | string | null
    city?: StringNullableFilter<"UserProfile"> | string | null
    extra?: JsonNullableFilter<"UserProfile">
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    country?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    extra?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserProfileWhereInput | UserProfileWhereInput[]
    OR?: UserProfileWhereInput[]
    NOT?: UserProfileWhereInput | UserProfileWhereInput[]
    country?: StringNullableFilter<"UserProfile"> | string | null
    department?: StringNullableFilter<"UserProfile"> | string | null
    city?: StringNullableFilter<"UserProfile"> | string | null
    extra?: JsonNullableFilter<"UserProfile">
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    country?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    extra?: SortOrderInput | SortOrder
    _count?: UserProfileCountOrderByAggregateInput
    _max?: UserProfileMaxOrderByAggregateInput
    _min?: UserProfileMinOrderByAggregateInput
  }

  export type UserProfileScalarWhereWithAggregatesInput = {
    AND?: UserProfileScalarWhereWithAggregatesInput | UserProfileScalarWhereWithAggregatesInput[]
    OR?: UserProfileScalarWhereWithAggregatesInput[]
    NOT?: UserProfileScalarWhereWithAggregatesInput | UserProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserProfile"> | string
    userId?: StringWithAggregatesFilter<"UserProfile"> | string
    country?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    department?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    city?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    extra?: JsonNullableWithAggregatesFilter<"UserProfile">
  }

  export type UserMessagingSettingWhereInput = {
    AND?: UserMessagingSettingWhereInput | UserMessagingSettingWhereInput[]
    OR?: UserMessagingSettingWhereInput[]
    NOT?: UserMessagingSettingWhereInput | UserMessagingSettingWhereInput[]
    id?: StringFilter<"UserMessagingSetting"> | string
    userId?: StringFilter<"UserMessagingSetting"> | string
    platform?: EnumMessagingPlatformFilter<"UserMessagingSetting"> | $Enums.MessagingPlatform
    handle?: StringNullableFilter<"UserMessagingSetting"> | string | null
    isEnabled?: BoolFilter<"UserMessagingSetting"> | boolean
    verified?: BoolFilter<"UserMessagingSetting"> | boolean
    createdAt?: DateTimeFilter<"UserMessagingSetting"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserMessagingSettingOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    platform?: SortOrder
    handle?: SortOrderInput | SortOrder
    isEnabled?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserMessagingSettingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_platform?: UserMessagingSettingUserIdPlatformCompoundUniqueInput
    AND?: UserMessagingSettingWhereInput | UserMessagingSettingWhereInput[]
    OR?: UserMessagingSettingWhereInput[]
    NOT?: UserMessagingSettingWhereInput | UserMessagingSettingWhereInput[]
    userId?: StringFilter<"UserMessagingSetting"> | string
    platform?: EnumMessagingPlatformFilter<"UserMessagingSetting"> | $Enums.MessagingPlatform
    handle?: StringNullableFilter<"UserMessagingSetting"> | string | null
    isEnabled?: BoolFilter<"UserMessagingSetting"> | boolean
    verified?: BoolFilter<"UserMessagingSetting"> | boolean
    createdAt?: DateTimeFilter<"UserMessagingSetting"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_platform">

  export type UserMessagingSettingOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    platform?: SortOrder
    handle?: SortOrderInput | SortOrder
    isEnabled?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
    _count?: UserMessagingSettingCountOrderByAggregateInput
    _max?: UserMessagingSettingMaxOrderByAggregateInput
    _min?: UserMessagingSettingMinOrderByAggregateInput
  }

  export type UserMessagingSettingScalarWhereWithAggregatesInput = {
    AND?: UserMessagingSettingScalarWhereWithAggregatesInput | UserMessagingSettingScalarWhereWithAggregatesInput[]
    OR?: UserMessagingSettingScalarWhereWithAggregatesInput[]
    NOT?: UserMessagingSettingScalarWhereWithAggregatesInput | UserMessagingSettingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserMessagingSetting"> | string
    userId?: StringWithAggregatesFilter<"UserMessagingSetting"> | string
    platform?: EnumMessagingPlatformWithAggregatesFilter<"UserMessagingSetting"> | $Enums.MessagingPlatform
    handle?: StringNullableWithAggregatesFilter<"UserMessagingSetting"> | string | null
    isEnabled?: BoolWithAggregatesFilter<"UserMessagingSetting"> | boolean
    verified?: BoolWithAggregatesFilter<"UserMessagingSetting"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UserMessagingSetting"> | Date | string
  }

  export type ChannelCategoryWhereInput = {
    AND?: ChannelCategoryWhereInput | ChannelCategoryWhereInput[]
    OR?: ChannelCategoryWhereInput[]
    NOT?: ChannelCategoryWhereInput | ChannelCategoryWhereInput[]
    id?: StringFilter<"ChannelCategory"> | string
    name?: StringFilter<"ChannelCategory"> | string
    description?: StringNullableFilter<"ChannelCategory"> | string | null
    createdAt?: DateTimeFilter<"ChannelCategory"> | Date | string
    assignments?: ChannelCategoryAssignmentListRelationFilter
  }

  export type ChannelCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    assignments?: ChannelCategoryAssignmentOrderByRelationAggregateInput
  }

  export type ChannelCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: ChannelCategoryWhereInput | ChannelCategoryWhereInput[]
    OR?: ChannelCategoryWhereInput[]
    NOT?: ChannelCategoryWhereInput | ChannelCategoryWhereInput[]
    description?: StringNullableFilter<"ChannelCategory"> | string | null
    createdAt?: DateTimeFilter<"ChannelCategory"> | Date | string
    assignments?: ChannelCategoryAssignmentListRelationFilter
  }, "id" | "name">

  export type ChannelCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ChannelCategoryCountOrderByAggregateInput
    _max?: ChannelCategoryMaxOrderByAggregateInput
    _min?: ChannelCategoryMinOrderByAggregateInput
  }

  export type ChannelCategoryScalarWhereWithAggregatesInput = {
    AND?: ChannelCategoryScalarWhereWithAggregatesInput | ChannelCategoryScalarWhereWithAggregatesInput[]
    OR?: ChannelCategoryScalarWhereWithAggregatesInput[]
    NOT?: ChannelCategoryScalarWhereWithAggregatesInput | ChannelCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChannelCategory"> | string
    name?: StringWithAggregatesFilter<"ChannelCategory"> | string
    description?: StringNullableWithAggregatesFilter<"ChannelCategory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ChannelCategory"> | Date | string
  }

  export type ChannelCategoryAssignmentWhereInput = {
    AND?: ChannelCategoryAssignmentWhereInput | ChannelCategoryAssignmentWhereInput[]
    OR?: ChannelCategoryAssignmentWhereInput[]
    NOT?: ChannelCategoryAssignmentWhereInput | ChannelCategoryAssignmentWhereInput[]
    id?: StringFilter<"ChannelCategoryAssignment"> | string
    channelId?: StringFilter<"ChannelCategoryAssignment"> | string
    categoryId?: StringFilter<"ChannelCategoryAssignment"> | string
    channel?: XOR<ChannelRelationFilter, ChannelWhereInput>
    category?: XOR<ChannelCategoryRelationFilter, ChannelCategoryWhereInput>
  }

  export type ChannelCategoryAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    channelId?: SortOrder
    categoryId?: SortOrder
    channel?: ChannelOrderByWithRelationInput
    category?: ChannelCategoryOrderByWithRelationInput
  }

  export type ChannelCategoryAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    channelId_categoryId?: ChannelCategoryAssignmentChannelIdCategoryIdCompoundUniqueInput
    AND?: ChannelCategoryAssignmentWhereInput | ChannelCategoryAssignmentWhereInput[]
    OR?: ChannelCategoryAssignmentWhereInput[]
    NOT?: ChannelCategoryAssignmentWhereInput | ChannelCategoryAssignmentWhereInput[]
    channelId?: StringFilter<"ChannelCategoryAssignment"> | string
    categoryId?: StringFilter<"ChannelCategoryAssignment"> | string
    channel?: XOR<ChannelRelationFilter, ChannelWhereInput>
    category?: XOR<ChannelCategoryRelationFilter, ChannelCategoryWhereInput>
  }, "id" | "channelId_categoryId">

  export type ChannelCategoryAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    channelId?: SortOrder
    categoryId?: SortOrder
    _count?: ChannelCategoryAssignmentCountOrderByAggregateInput
    _max?: ChannelCategoryAssignmentMaxOrderByAggregateInput
    _min?: ChannelCategoryAssignmentMinOrderByAggregateInput
  }

  export type ChannelCategoryAssignmentScalarWhereWithAggregatesInput = {
    AND?: ChannelCategoryAssignmentScalarWhereWithAggregatesInput | ChannelCategoryAssignmentScalarWhereWithAggregatesInput[]
    OR?: ChannelCategoryAssignmentScalarWhereWithAggregatesInput[]
    NOT?: ChannelCategoryAssignmentScalarWhereWithAggregatesInput | ChannelCategoryAssignmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChannelCategoryAssignment"> | string
    channelId?: StringWithAggregatesFilter<"ChannelCategoryAssignment"> | string
    categoryId?: StringWithAggregatesFilter<"ChannelCategoryAssignment"> | string
  }

  export type MessageViewWhereInput = {
    AND?: MessageViewWhereInput | MessageViewWhereInput[]
    OR?: MessageViewWhereInput[]
    NOT?: MessageViewWhereInput | MessageViewWhereInput[]
    id?: StringFilter<"MessageView"> | string
    messageId?: StringFilter<"MessageView"> | string
    userId?: StringNullableFilter<"MessageView"> | string | null
    viewedAt?: DateTimeFilter<"MessageView"> | Date | string
    message?: XOR<MessageRelationFilter, MessageWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type MessageViewOrderByWithRelationInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrderInput | SortOrder
    viewedAt?: SortOrder
    message?: MessageOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type MessageViewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageViewWhereInput | MessageViewWhereInput[]
    OR?: MessageViewWhereInput[]
    NOT?: MessageViewWhereInput | MessageViewWhereInput[]
    messageId?: StringFilter<"MessageView"> | string
    userId?: StringNullableFilter<"MessageView"> | string | null
    viewedAt?: DateTimeFilter<"MessageView"> | Date | string
    message?: XOR<MessageRelationFilter, MessageWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type MessageViewOrderByWithAggregationInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrderInput | SortOrder
    viewedAt?: SortOrder
    _count?: MessageViewCountOrderByAggregateInput
    _max?: MessageViewMaxOrderByAggregateInput
    _min?: MessageViewMinOrderByAggregateInput
  }

  export type MessageViewScalarWhereWithAggregatesInput = {
    AND?: MessageViewScalarWhereWithAggregatesInput | MessageViewScalarWhereWithAggregatesInput[]
    OR?: MessageViewScalarWhereWithAggregatesInput[]
    NOT?: MessageViewScalarWhereWithAggregatesInput | MessageViewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MessageView"> | string
    messageId?: StringWithAggregatesFilter<"MessageView"> | string
    userId?: StringNullableWithAggregatesFilter<"MessageView"> | string | null
    viewedAt?: DateTimeWithAggregatesFilter<"MessageView"> | Date | string
  }

  export type ChannelVisitWhereInput = {
    AND?: ChannelVisitWhereInput | ChannelVisitWhereInput[]
    OR?: ChannelVisitWhereInput[]
    NOT?: ChannelVisitWhereInput | ChannelVisitWhereInput[]
    id?: StringFilter<"ChannelVisit"> | string
    channelId?: StringFilter<"ChannelVisit"> | string
    userId?: StringNullableFilter<"ChannelVisit"> | string | null
    visitedAt?: DateTimeFilter<"ChannelVisit"> | Date | string
    channel?: XOR<ChannelRelationFilter, ChannelWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type ChannelVisitOrderByWithRelationInput = {
    id?: SortOrder
    channelId?: SortOrder
    userId?: SortOrderInput | SortOrder
    visitedAt?: SortOrder
    channel?: ChannelOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ChannelVisitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChannelVisitWhereInput | ChannelVisitWhereInput[]
    OR?: ChannelVisitWhereInput[]
    NOT?: ChannelVisitWhereInput | ChannelVisitWhereInput[]
    channelId?: StringFilter<"ChannelVisit"> | string
    userId?: StringNullableFilter<"ChannelVisit"> | string | null
    visitedAt?: DateTimeFilter<"ChannelVisit"> | Date | string
    channel?: XOR<ChannelRelationFilter, ChannelWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type ChannelVisitOrderByWithAggregationInput = {
    id?: SortOrder
    channelId?: SortOrder
    userId?: SortOrderInput | SortOrder
    visitedAt?: SortOrder
    _count?: ChannelVisitCountOrderByAggregateInput
    _max?: ChannelVisitMaxOrderByAggregateInput
    _min?: ChannelVisitMinOrderByAggregateInput
  }

  export type ChannelVisitScalarWhereWithAggregatesInput = {
    AND?: ChannelVisitScalarWhereWithAggregatesInput | ChannelVisitScalarWhereWithAggregatesInput[]
    OR?: ChannelVisitScalarWhereWithAggregatesInput[]
    NOT?: ChannelVisitScalarWhereWithAggregatesInput | ChannelVisitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChannelVisit"> | string
    channelId?: StringWithAggregatesFilter<"ChannelVisit"> | string
    userId?: StringNullableWithAggregatesFilter<"ChannelVisit"> | string | null
    visitedAt?: DateTimeWithAggregatesFilter<"ChannelVisit"> | Date | string
  }

  export type FormWhereInput = {
    AND?: FormWhereInput | FormWhereInput[]
    OR?: FormWhereInput[]
    NOT?: FormWhereInput | FormWhereInput[]
    id?: StringFilter<"Form"> | string
    title?: StringFilter<"Form"> | string
    description?: StringNullableFilter<"Form"> | string | null
    slug?: StringFilter<"Form"> | string
    headerContent?: StringNullableFilter<"Form"> | string | null
    footerContent?: StringNullableFilter<"Form"> | string | null
    successMessage?: StringNullableFilter<"Form"> | string | null
    isActive?: BoolFilter<"Form"> | boolean
    isPublished?: BoolFilter<"Form"> | boolean
    wasPublished?: BoolFilter<"Form"> | boolean
    isDeleted?: BoolFilter<"Form"> | boolean
    collectUserInfo?: BoolFilter<"Form"> | boolean
    expiresAt?: DateTimeNullableFilter<"Form"> | Date | string | null
    userId?: StringFilter<"Form"> | string
    createdAt?: DateTimeFilter<"Form"> | Date | string
    updatedAt?: DateTimeFilter<"Form"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    fields?: FormFieldListRelationFilter
    submissions?: FormSubmissionListRelationFilter
  }

  export type FormOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    slug?: SortOrder
    headerContent?: SortOrderInput | SortOrder
    footerContent?: SortOrderInput | SortOrder
    successMessage?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isPublished?: SortOrder
    wasPublished?: SortOrder
    isDeleted?: SortOrder
    collectUserInfo?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    fields?: FormFieldOrderByRelationAggregateInput
    submissions?: FormSubmissionOrderByRelationAggregateInput
  }

  export type FormWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: FormWhereInput | FormWhereInput[]
    OR?: FormWhereInput[]
    NOT?: FormWhereInput | FormWhereInput[]
    title?: StringFilter<"Form"> | string
    description?: StringNullableFilter<"Form"> | string | null
    headerContent?: StringNullableFilter<"Form"> | string | null
    footerContent?: StringNullableFilter<"Form"> | string | null
    successMessage?: StringNullableFilter<"Form"> | string | null
    isActive?: BoolFilter<"Form"> | boolean
    isPublished?: BoolFilter<"Form"> | boolean
    wasPublished?: BoolFilter<"Form"> | boolean
    isDeleted?: BoolFilter<"Form"> | boolean
    collectUserInfo?: BoolFilter<"Form"> | boolean
    expiresAt?: DateTimeNullableFilter<"Form"> | Date | string | null
    userId?: StringFilter<"Form"> | string
    createdAt?: DateTimeFilter<"Form"> | Date | string
    updatedAt?: DateTimeFilter<"Form"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    fields?: FormFieldListRelationFilter
    submissions?: FormSubmissionListRelationFilter
  }, "id" | "slug">

  export type FormOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    slug?: SortOrder
    headerContent?: SortOrderInput | SortOrder
    footerContent?: SortOrderInput | SortOrder
    successMessage?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isPublished?: SortOrder
    wasPublished?: SortOrder
    isDeleted?: SortOrder
    collectUserInfo?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FormCountOrderByAggregateInput
    _max?: FormMaxOrderByAggregateInput
    _min?: FormMinOrderByAggregateInput
  }

  export type FormScalarWhereWithAggregatesInput = {
    AND?: FormScalarWhereWithAggregatesInput | FormScalarWhereWithAggregatesInput[]
    OR?: FormScalarWhereWithAggregatesInput[]
    NOT?: FormScalarWhereWithAggregatesInput | FormScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Form"> | string
    title?: StringWithAggregatesFilter<"Form"> | string
    description?: StringNullableWithAggregatesFilter<"Form"> | string | null
    slug?: StringWithAggregatesFilter<"Form"> | string
    headerContent?: StringNullableWithAggregatesFilter<"Form"> | string | null
    footerContent?: StringNullableWithAggregatesFilter<"Form"> | string | null
    successMessage?: StringNullableWithAggregatesFilter<"Form"> | string | null
    isActive?: BoolWithAggregatesFilter<"Form"> | boolean
    isPublished?: BoolWithAggregatesFilter<"Form"> | boolean
    wasPublished?: BoolWithAggregatesFilter<"Form"> | boolean
    isDeleted?: BoolWithAggregatesFilter<"Form"> | boolean
    collectUserInfo?: BoolWithAggregatesFilter<"Form"> | boolean
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Form"> | Date | string | null
    userId?: StringWithAggregatesFilter<"Form"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Form"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Form"> | Date | string
  }

  export type FormFieldWhereInput = {
    AND?: FormFieldWhereInput | FormFieldWhereInput[]
    OR?: FormFieldWhereInput[]
    NOT?: FormFieldWhereInput | FormFieldWhereInput[]
    id?: StringFilter<"FormField"> | string
    formId?: StringFilter<"FormField"> | string
    type?: StringFilter<"FormField"> | string
    label?: StringFilter<"FormField"> | string
    placeholder?: StringNullableFilter<"FormField"> | string | null
    required?: BoolFilter<"FormField"> | boolean
    isHidden?: BoolFilter<"FormField"> | boolean
    options?: JsonNullableFilter<"FormField">
    order?: IntFilter<"FormField"> | number
    createdAt?: DateTimeFilter<"FormField"> | Date | string
    form?: XOR<FormRelationFilter, FormWhereInput>
  }

  export type FormFieldOrderByWithRelationInput = {
    id?: SortOrder
    formId?: SortOrder
    type?: SortOrder
    label?: SortOrder
    placeholder?: SortOrderInput | SortOrder
    required?: SortOrder
    isHidden?: SortOrder
    options?: SortOrderInput | SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    form?: FormOrderByWithRelationInput
  }

  export type FormFieldWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FormFieldWhereInput | FormFieldWhereInput[]
    OR?: FormFieldWhereInput[]
    NOT?: FormFieldWhereInput | FormFieldWhereInput[]
    formId?: StringFilter<"FormField"> | string
    type?: StringFilter<"FormField"> | string
    label?: StringFilter<"FormField"> | string
    placeholder?: StringNullableFilter<"FormField"> | string | null
    required?: BoolFilter<"FormField"> | boolean
    isHidden?: BoolFilter<"FormField"> | boolean
    options?: JsonNullableFilter<"FormField">
    order?: IntFilter<"FormField"> | number
    createdAt?: DateTimeFilter<"FormField"> | Date | string
    form?: XOR<FormRelationFilter, FormWhereInput>
  }, "id">

  export type FormFieldOrderByWithAggregationInput = {
    id?: SortOrder
    formId?: SortOrder
    type?: SortOrder
    label?: SortOrder
    placeholder?: SortOrderInput | SortOrder
    required?: SortOrder
    isHidden?: SortOrder
    options?: SortOrderInput | SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    _count?: FormFieldCountOrderByAggregateInput
    _avg?: FormFieldAvgOrderByAggregateInput
    _max?: FormFieldMaxOrderByAggregateInput
    _min?: FormFieldMinOrderByAggregateInput
    _sum?: FormFieldSumOrderByAggregateInput
  }

  export type FormFieldScalarWhereWithAggregatesInput = {
    AND?: FormFieldScalarWhereWithAggregatesInput | FormFieldScalarWhereWithAggregatesInput[]
    OR?: FormFieldScalarWhereWithAggregatesInput[]
    NOT?: FormFieldScalarWhereWithAggregatesInput | FormFieldScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FormField"> | string
    formId?: StringWithAggregatesFilter<"FormField"> | string
    type?: StringWithAggregatesFilter<"FormField"> | string
    label?: StringWithAggregatesFilter<"FormField"> | string
    placeholder?: StringNullableWithAggregatesFilter<"FormField"> | string | null
    required?: BoolWithAggregatesFilter<"FormField"> | boolean
    isHidden?: BoolWithAggregatesFilter<"FormField"> | boolean
    options?: JsonNullableWithAggregatesFilter<"FormField">
    order?: IntWithAggregatesFilter<"FormField"> | number
    createdAt?: DateTimeWithAggregatesFilter<"FormField"> | Date | string
  }

  export type FormSubmissionWhereInput = {
    AND?: FormSubmissionWhereInput | FormSubmissionWhereInput[]
    OR?: FormSubmissionWhereInput[]
    NOT?: FormSubmissionWhereInput | FormSubmissionWhereInput[]
    id?: StringFilter<"FormSubmission"> | string
    formId?: StringFilter<"FormSubmission"> | string
    data?: JsonFilter<"FormSubmission">
    ipAddress?: StringNullableFilter<"FormSubmission"> | string | null
    country?: StringNullableFilter<"FormSubmission"> | string | null
    city?: StringNullableFilter<"FormSubmission"> | string | null
    userAgent?: StringNullableFilter<"FormSubmission"> | string | null
    deviceInfo?: JsonNullableFilter<"FormSubmission">
    createdAt?: DateTimeFilter<"FormSubmission"> | Date | string
    form?: XOR<FormRelationFilter, FormWhereInput>
  }

  export type FormSubmissionOrderByWithRelationInput = {
    id?: SortOrder
    formId?: SortOrder
    data?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    deviceInfo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    form?: FormOrderByWithRelationInput
  }

  export type FormSubmissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FormSubmissionWhereInput | FormSubmissionWhereInput[]
    OR?: FormSubmissionWhereInput[]
    NOT?: FormSubmissionWhereInput | FormSubmissionWhereInput[]
    formId?: StringFilter<"FormSubmission"> | string
    data?: JsonFilter<"FormSubmission">
    ipAddress?: StringNullableFilter<"FormSubmission"> | string | null
    country?: StringNullableFilter<"FormSubmission"> | string | null
    city?: StringNullableFilter<"FormSubmission"> | string | null
    userAgent?: StringNullableFilter<"FormSubmission"> | string | null
    deviceInfo?: JsonNullableFilter<"FormSubmission">
    createdAt?: DateTimeFilter<"FormSubmission"> | Date | string
    form?: XOR<FormRelationFilter, FormWhereInput>
  }, "id">

  export type FormSubmissionOrderByWithAggregationInput = {
    id?: SortOrder
    formId?: SortOrder
    data?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    deviceInfo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: FormSubmissionCountOrderByAggregateInput
    _max?: FormSubmissionMaxOrderByAggregateInput
    _min?: FormSubmissionMinOrderByAggregateInput
  }

  export type FormSubmissionScalarWhereWithAggregatesInput = {
    AND?: FormSubmissionScalarWhereWithAggregatesInput | FormSubmissionScalarWhereWithAggregatesInput[]
    OR?: FormSubmissionScalarWhereWithAggregatesInput[]
    NOT?: FormSubmissionScalarWhereWithAggregatesInput | FormSubmissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FormSubmission"> | string
    formId?: StringWithAggregatesFilter<"FormSubmission"> | string
    data?: JsonWithAggregatesFilter<"FormSubmission">
    ipAddress?: StringNullableWithAggregatesFilter<"FormSubmission"> | string | null
    country?: StringNullableWithAggregatesFilter<"FormSubmission"> | string | null
    city?: StringNullableWithAggregatesFilter<"FormSubmission"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"FormSubmission"> | string | null
    deviceInfo?: JsonNullableWithAggregatesFilter<"FormSubmission">
    createdAt?: DateTimeWithAggregatesFilter<"FormSubmission"> | Date | string
  }

  export type EventWhereInput = {
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    id?: StringFilter<"Event"> | string
    title?: StringFilter<"Event"> | string
    description?: StringNullableFilter<"Event"> | string | null
    startDate?: DateTimeFilter<"Event"> | Date | string
    endDate?: DateTimeFilter<"Event"> | Date | string
    location?: StringFilter<"Event"> | string
    imageUrl?: StringNullableFilter<"Event"> | string | null
    status?: EnumEventStatusFilter<"Event"> | $Enums.EventStatus
    categories?: JsonNullableFilter<"Event">
    paymentInfo?: StringNullableFilter<"Event"> | string | null
    organizerId?: StringFilter<"Event"> | string
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
    organizer?: XOR<UserRelationFilter, UserWhereInput>
    zones?: EventZoneListRelationFilter
    seats?: EventSeatListRelationFilter
    tickets?: TicketListRelationFilter
  }

  export type EventOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    location?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    categories?: SortOrderInput | SortOrder
    paymentInfo?: SortOrderInput | SortOrder
    organizerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organizer?: UserOrderByWithRelationInput
    zones?: EventZoneOrderByRelationAggregateInput
    seats?: EventSeatOrderByRelationAggregateInput
    tickets?: TicketOrderByRelationAggregateInput
  }

  export type EventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    title?: StringFilter<"Event"> | string
    description?: StringNullableFilter<"Event"> | string | null
    startDate?: DateTimeFilter<"Event"> | Date | string
    endDate?: DateTimeFilter<"Event"> | Date | string
    location?: StringFilter<"Event"> | string
    imageUrl?: StringNullableFilter<"Event"> | string | null
    status?: EnumEventStatusFilter<"Event"> | $Enums.EventStatus
    categories?: JsonNullableFilter<"Event">
    paymentInfo?: StringNullableFilter<"Event"> | string | null
    organizerId?: StringFilter<"Event"> | string
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
    organizer?: XOR<UserRelationFilter, UserWhereInput>
    zones?: EventZoneListRelationFilter
    seats?: EventSeatListRelationFilter
    tickets?: TicketListRelationFilter
  }, "id">

  export type EventOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    location?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    categories?: SortOrderInput | SortOrder
    paymentInfo?: SortOrderInput | SortOrder
    organizerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EventCountOrderByAggregateInput
    _max?: EventMaxOrderByAggregateInput
    _min?: EventMinOrderByAggregateInput
  }

  export type EventScalarWhereWithAggregatesInput = {
    AND?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    OR?: EventScalarWhereWithAggregatesInput[]
    NOT?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Event"> | string
    title?: StringWithAggregatesFilter<"Event"> | string
    description?: StringNullableWithAggregatesFilter<"Event"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    location?: StringWithAggregatesFilter<"Event"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"Event"> | string | null
    status?: EnumEventStatusWithAggregatesFilter<"Event"> | $Enums.EventStatus
    categories?: JsonNullableWithAggregatesFilter<"Event">
    paymentInfo?: StringNullableWithAggregatesFilter<"Event"> | string | null
    organizerId?: StringWithAggregatesFilter<"Event"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
  }

  export type EventZoneWhereInput = {
    AND?: EventZoneWhereInput | EventZoneWhereInput[]
    OR?: EventZoneWhereInput[]
    NOT?: EventZoneWhereInput | EventZoneWhereInput[]
    id?: StringFilter<"EventZone"> | string
    eventId?: StringFilter<"EventZone"> | string
    name?: StringFilter<"EventZone"> | string
    color?: StringFilter<"EventZone"> | string
    price?: FloatFilter<"EventZone"> | number
    rows?: IntFilter<"EventZone"> | number
    cols?: IntFilter<"EventZone"> | number
    capacity?: IntNullableFilter<"EventZone"> | number | null
    type?: EnumZoneTypeFilter<"EventZone"> | $Enums.ZoneType
    layout?: JsonNullableFilter<"EventZone">
    seatGap?: IntNullableFilter<"EventZone"> | number | null
    startNumber?: IntFilter<"EventZone"> | number
    numberingDirection?: StringFilter<"EventZone"> | string
    createdAt?: DateTimeFilter<"EventZone"> | Date | string
    updatedAt?: DateTimeFilter<"EventZone"> | Date | string
    event?: XOR<EventRelationFilter, EventWhereInput>
    seats?: EventSeatListRelationFilter
    tickets?: TicketListRelationFilter
  }

  export type EventZoneOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrder
    name?: SortOrder
    color?: SortOrder
    price?: SortOrder
    rows?: SortOrder
    cols?: SortOrder
    capacity?: SortOrderInput | SortOrder
    type?: SortOrder
    layout?: SortOrderInput | SortOrder
    seatGap?: SortOrderInput | SortOrder
    startNumber?: SortOrder
    numberingDirection?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    event?: EventOrderByWithRelationInput
    seats?: EventSeatOrderByRelationAggregateInput
    tickets?: TicketOrderByRelationAggregateInput
  }

  export type EventZoneWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EventZoneWhereInput | EventZoneWhereInput[]
    OR?: EventZoneWhereInput[]
    NOT?: EventZoneWhereInput | EventZoneWhereInput[]
    eventId?: StringFilter<"EventZone"> | string
    name?: StringFilter<"EventZone"> | string
    color?: StringFilter<"EventZone"> | string
    price?: FloatFilter<"EventZone"> | number
    rows?: IntFilter<"EventZone"> | number
    cols?: IntFilter<"EventZone"> | number
    capacity?: IntNullableFilter<"EventZone"> | number | null
    type?: EnumZoneTypeFilter<"EventZone"> | $Enums.ZoneType
    layout?: JsonNullableFilter<"EventZone">
    seatGap?: IntNullableFilter<"EventZone"> | number | null
    startNumber?: IntFilter<"EventZone"> | number
    numberingDirection?: StringFilter<"EventZone"> | string
    createdAt?: DateTimeFilter<"EventZone"> | Date | string
    updatedAt?: DateTimeFilter<"EventZone"> | Date | string
    event?: XOR<EventRelationFilter, EventWhereInput>
    seats?: EventSeatListRelationFilter
    tickets?: TicketListRelationFilter
  }, "id">

  export type EventZoneOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrder
    name?: SortOrder
    color?: SortOrder
    price?: SortOrder
    rows?: SortOrder
    cols?: SortOrder
    capacity?: SortOrderInput | SortOrder
    type?: SortOrder
    layout?: SortOrderInput | SortOrder
    seatGap?: SortOrderInput | SortOrder
    startNumber?: SortOrder
    numberingDirection?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EventZoneCountOrderByAggregateInput
    _avg?: EventZoneAvgOrderByAggregateInput
    _max?: EventZoneMaxOrderByAggregateInput
    _min?: EventZoneMinOrderByAggregateInput
    _sum?: EventZoneSumOrderByAggregateInput
  }

  export type EventZoneScalarWhereWithAggregatesInput = {
    AND?: EventZoneScalarWhereWithAggregatesInput | EventZoneScalarWhereWithAggregatesInput[]
    OR?: EventZoneScalarWhereWithAggregatesInput[]
    NOT?: EventZoneScalarWhereWithAggregatesInput | EventZoneScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EventZone"> | string
    eventId?: StringWithAggregatesFilter<"EventZone"> | string
    name?: StringWithAggregatesFilter<"EventZone"> | string
    color?: StringWithAggregatesFilter<"EventZone"> | string
    price?: FloatWithAggregatesFilter<"EventZone"> | number
    rows?: IntWithAggregatesFilter<"EventZone"> | number
    cols?: IntWithAggregatesFilter<"EventZone"> | number
    capacity?: IntNullableWithAggregatesFilter<"EventZone"> | number | null
    type?: EnumZoneTypeWithAggregatesFilter<"EventZone"> | $Enums.ZoneType
    layout?: JsonNullableWithAggregatesFilter<"EventZone">
    seatGap?: IntNullableWithAggregatesFilter<"EventZone"> | number | null
    startNumber?: IntWithAggregatesFilter<"EventZone"> | number
    numberingDirection?: StringWithAggregatesFilter<"EventZone"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EventZone"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EventZone"> | Date | string
  }

  export type EventSeatWhereInput = {
    AND?: EventSeatWhereInput | EventSeatWhereInput[]
    OR?: EventSeatWhereInput[]
    NOT?: EventSeatWhereInput | EventSeatWhereInput[]
    id?: StringFilter<"EventSeat"> | string
    eventId?: StringFilter<"EventSeat"> | string
    zoneId?: StringFilter<"EventSeat"> | string
    rowLabel?: StringFilter<"EventSeat"> | string
    colLabel?: StringFilter<"EventSeat"> | string
    status?: EnumSeatStatusFilter<"EventSeat"> | $Enums.SeatStatus
    type?: EnumSeatTypeFilter<"EventSeat"> | $Enums.SeatType
    price?: FloatNullableFilter<"EventSeat"> | number | null
    x?: IntNullableFilter<"EventSeat"> | number | null
    y?: IntNullableFilter<"EventSeat"> | number | null
    holderName?: StringNullableFilter<"EventSeat"> | string | null
    ticketCode?: StringNullableFilter<"EventSeat"> | string | null
    createdAt?: DateTimeFilter<"EventSeat"> | Date | string
    updatedAt?: DateTimeFilter<"EventSeat"> | Date | string
    event?: XOR<EventRelationFilter, EventWhereInput>
    zone?: XOR<EventZoneRelationFilter, EventZoneWhereInput>
    tickets?: TicketListRelationFilter
  }

  export type EventSeatOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrder
    zoneId?: SortOrder
    rowLabel?: SortOrder
    colLabel?: SortOrder
    status?: SortOrder
    type?: SortOrder
    price?: SortOrderInput | SortOrder
    x?: SortOrderInput | SortOrder
    y?: SortOrderInput | SortOrder
    holderName?: SortOrderInput | SortOrder
    ticketCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    event?: EventOrderByWithRelationInput
    zone?: EventZoneOrderByWithRelationInput
    tickets?: TicketOrderByRelationAggregateInput
  }

  export type EventSeatWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EventSeatWhereInput | EventSeatWhereInput[]
    OR?: EventSeatWhereInput[]
    NOT?: EventSeatWhereInput | EventSeatWhereInput[]
    eventId?: StringFilter<"EventSeat"> | string
    zoneId?: StringFilter<"EventSeat"> | string
    rowLabel?: StringFilter<"EventSeat"> | string
    colLabel?: StringFilter<"EventSeat"> | string
    status?: EnumSeatStatusFilter<"EventSeat"> | $Enums.SeatStatus
    type?: EnumSeatTypeFilter<"EventSeat"> | $Enums.SeatType
    price?: FloatNullableFilter<"EventSeat"> | number | null
    x?: IntNullableFilter<"EventSeat"> | number | null
    y?: IntNullableFilter<"EventSeat"> | number | null
    holderName?: StringNullableFilter<"EventSeat"> | string | null
    ticketCode?: StringNullableFilter<"EventSeat"> | string | null
    createdAt?: DateTimeFilter<"EventSeat"> | Date | string
    updatedAt?: DateTimeFilter<"EventSeat"> | Date | string
    event?: XOR<EventRelationFilter, EventWhereInput>
    zone?: XOR<EventZoneRelationFilter, EventZoneWhereInput>
    tickets?: TicketListRelationFilter
  }, "id">

  export type EventSeatOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrder
    zoneId?: SortOrder
    rowLabel?: SortOrder
    colLabel?: SortOrder
    status?: SortOrder
    type?: SortOrder
    price?: SortOrderInput | SortOrder
    x?: SortOrderInput | SortOrder
    y?: SortOrderInput | SortOrder
    holderName?: SortOrderInput | SortOrder
    ticketCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EventSeatCountOrderByAggregateInput
    _avg?: EventSeatAvgOrderByAggregateInput
    _max?: EventSeatMaxOrderByAggregateInput
    _min?: EventSeatMinOrderByAggregateInput
    _sum?: EventSeatSumOrderByAggregateInput
  }

  export type EventSeatScalarWhereWithAggregatesInput = {
    AND?: EventSeatScalarWhereWithAggregatesInput | EventSeatScalarWhereWithAggregatesInput[]
    OR?: EventSeatScalarWhereWithAggregatesInput[]
    NOT?: EventSeatScalarWhereWithAggregatesInput | EventSeatScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EventSeat"> | string
    eventId?: StringWithAggregatesFilter<"EventSeat"> | string
    zoneId?: StringWithAggregatesFilter<"EventSeat"> | string
    rowLabel?: StringWithAggregatesFilter<"EventSeat"> | string
    colLabel?: StringWithAggregatesFilter<"EventSeat"> | string
    status?: EnumSeatStatusWithAggregatesFilter<"EventSeat"> | $Enums.SeatStatus
    type?: EnumSeatTypeWithAggregatesFilter<"EventSeat"> | $Enums.SeatType
    price?: FloatNullableWithAggregatesFilter<"EventSeat"> | number | null
    x?: IntNullableWithAggregatesFilter<"EventSeat"> | number | null
    y?: IntNullableWithAggregatesFilter<"EventSeat"> | number | null
    holderName?: StringNullableWithAggregatesFilter<"EventSeat"> | string | null
    ticketCode?: StringNullableWithAggregatesFilter<"EventSeat"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EventSeat"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EventSeat"> | Date | string
  }

  export type TicketWhereInput = {
    AND?: TicketWhereInput | TicketWhereInput[]
    OR?: TicketWhereInput[]
    NOT?: TicketWhereInput | TicketWhereInput[]
    id?: StringFilter<"Ticket"> | string
    eventId?: StringFilter<"Ticket"> | string
    zoneId?: StringFilter<"Ticket"> | string
    seatId?: StringNullableFilter<"Ticket"> | string | null
    customerName?: StringFilter<"Ticket"> | string
    customerEmail?: StringFilter<"Ticket"> | string
    price?: FloatFilter<"Ticket"> | number
    status?: EnumTicketStatusFilter<"Ticket"> | $Enums.TicketStatus
    purchaseDate?: DateTimeFilter<"Ticket"> | Date | string
    qrCode?: StringNullableFilter<"Ticket"> | string | null
    event?: XOR<EventRelationFilter, EventWhereInput>
    zone?: XOR<EventZoneRelationFilter, EventZoneWhereInput>
    seat?: XOR<EventSeatNullableRelationFilter, EventSeatWhereInput> | null
  }

  export type TicketOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrder
    zoneId?: SortOrder
    seatId?: SortOrderInput | SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrder
    price?: SortOrder
    status?: SortOrder
    purchaseDate?: SortOrder
    qrCode?: SortOrderInput | SortOrder
    event?: EventOrderByWithRelationInput
    zone?: EventZoneOrderByWithRelationInput
    seat?: EventSeatOrderByWithRelationInput
  }

  export type TicketWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TicketWhereInput | TicketWhereInput[]
    OR?: TicketWhereInput[]
    NOT?: TicketWhereInput | TicketWhereInput[]
    eventId?: StringFilter<"Ticket"> | string
    zoneId?: StringFilter<"Ticket"> | string
    seatId?: StringNullableFilter<"Ticket"> | string | null
    customerName?: StringFilter<"Ticket"> | string
    customerEmail?: StringFilter<"Ticket"> | string
    price?: FloatFilter<"Ticket"> | number
    status?: EnumTicketStatusFilter<"Ticket"> | $Enums.TicketStatus
    purchaseDate?: DateTimeFilter<"Ticket"> | Date | string
    qrCode?: StringNullableFilter<"Ticket"> | string | null
    event?: XOR<EventRelationFilter, EventWhereInput>
    zone?: XOR<EventZoneRelationFilter, EventZoneWhereInput>
    seat?: XOR<EventSeatNullableRelationFilter, EventSeatWhereInput> | null
  }, "id">

  export type TicketOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrder
    zoneId?: SortOrder
    seatId?: SortOrderInput | SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrder
    price?: SortOrder
    status?: SortOrder
    purchaseDate?: SortOrder
    qrCode?: SortOrderInput | SortOrder
    _count?: TicketCountOrderByAggregateInput
    _avg?: TicketAvgOrderByAggregateInput
    _max?: TicketMaxOrderByAggregateInput
    _min?: TicketMinOrderByAggregateInput
    _sum?: TicketSumOrderByAggregateInput
  }

  export type TicketScalarWhereWithAggregatesInput = {
    AND?: TicketScalarWhereWithAggregatesInput | TicketScalarWhereWithAggregatesInput[]
    OR?: TicketScalarWhereWithAggregatesInput[]
    NOT?: TicketScalarWhereWithAggregatesInput | TicketScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Ticket"> | string
    eventId?: StringWithAggregatesFilter<"Ticket"> | string
    zoneId?: StringWithAggregatesFilter<"Ticket"> | string
    seatId?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    customerName?: StringWithAggregatesFilter<"Ticket"> | string
    customerEmail?: StringWithAggregatesFilter<"Ticket"> | string
    price?: FloatWithAggregatesFilter<"Ticket"> | number
    status?: EnumTicketStatusWithAggregatesFilter<"Ticket"> | $Enums.TicketStatus
    purchaseDate?: DateTimeWithAggregatesFilter<"Ticket"> | Date | string
    qrCode?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
  }

  export type UserCreateInput = {
    id?: string
    email: string
    username: string
    fullName?: string | null
    avatarUrl?: string | null
    passwordHash?: string | null
    deviceId?: string | null
    isGuest?: boolean
    phoneNumber?: string | null
    isPhoneVerified?: boolean
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    isAdmin?: boolean
    isCoordinator?: boolean
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedChannels?: ChannelCreateNestedManyWithoutOwnerInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesOverrideSet?: MessageCreateNestedManyWithoutOverrideSetterInput
    subscriptions?: ChannelSubscriptionCreateNestedManyWithoutUserInput
    invitationLinks?: InvitationLinkCreateNestedManyWithoutCreatorInput
    qrCodes?: QrCodeCreateNestedManyWithoutCreatorInput
    messageDeliveries?: MessageDeliveryCreateNestedManyWithoutUserInput
    messageApprovals?: MessageApprovalCreateNestedManyWithoutApproverInput
    messageRevisionsEdited?: MessageRevisionCreateNestedManyWithoutEditorInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    messagingSettings?: UserMessagingSettingCreateNestedManyWithoutUserInput
    approverAssignments?: ChannelApproverCreateNestedManyWithoutUserInput
    createdCategories?: MessageCategoryCreateNestedManyWithoutCreatorInput
    messageViews?: MessageViewCreateNestedManyWithoutUserInput
    channelVisits?: ChannelVisitCreateNestedManyWithoutUserInput
    createdForms?: FormCreateNestedManyWithoutUserInput
    organizedEvents?: EventCreateNestedManyWithoutOrganizerInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    username: string
    fullName?: string | null
    avatarUrl?: string | null
    passwordHash?: string | null
    deviceId?: string | null
    isGuest?: boolean
    phoneNumber?: string | null
    isPhoneVerified?: boolean
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    isAdmin?: boolean
    isCoordinator?: boolean
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedChannels?: ChannelUncheckedCreateNestedManyWithoutOwnerInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesOverrideSet?: MessageUncheckedCreateNestedManyWithoutOverrideSetterInput
    subscriptions?: ChannelSubscriptionUncheckedCreateNestedManyWithoutUserInput
    invitationLinks?: InvitationLinkUncheckedCreateNestedManyWithoutCreatorInput
    qrCodes?: QrCodeUncheckedCreateNestedManyWithoutCreatorInput
    messageDeliveries?: MessageDeliveryUncheckedCreateNestedManyWithoutUserInput
    messageApprovals?: MessageApprovalUncheckedCreateNestedManyWithoutApproverInput
    messageRevisionsEdited?: MessageRevisionUncheckedCreateNestedManyWithoutEditorInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    messagingSettings?: UserMessagingSettingUncheckedCreateNestedManyWithoutUserInput
    approverAssignments?: ChannelApproverUncheckedCreateNestedManyWithoutUserInput
    createdCategories?: MessageCategoryUncheckedCreateNestedManyWithoutCreatorInput
    messageViews?: MessageViewUncheckedCreateNestedManyWithoutUserInput
    channelVisits?: ChannelVisitUncheckedCreateNestedManyWithoutUserInput
    createdForms?: FormUncheckedCreateNestedManyWithoutUserInput
    organizedEvents?: EventUncheckedCreateNestedManyWithoutOrganizerInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isCoordinator?: BoolFieldUpdateOperationsInput | boolean
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedChannels?: ChannelUpdateManyWithoutOwnerNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesOverrideSet?: MessageUpdateManyWithoutOverrideSetterNestedInput
    subscriptions?: ChannelSubscriptionUpdateManyWithoutUserNestedInput
    invitationLinks?: InvitationLinkUpdateManyWithoutCreatorNestedInput
    qrCodes?: QrCodeUpdateManyWithoutCreatorNestedInput
    messageDeliveries?: MessageDeliveryUpdateManyWithoutUserNestedInput
    messageApprovals?: MessageApprovalUpdateManyWithoutApproverNestedInput
    messageRevisionsEdited?: MessageRevisionUpdateManyWithoutEditorNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    messagingSettings?: UserMessagingSettingUpdateManyWithoutUserNestedInput
    approverAssignments?: ChannelApproverUpdateManyWithoutUserNestedInput
    createdCategories?: MessageCategoryUpdateManyWithoutCreatorNestedInput
    messageViews?: MessageViewUpdateManyWithoutUserNestedInput
    channelVisits?: ChannelVisitUpdateManyWithoutUserNestedInput
    createdForms?: FormUpdateManyWithoutUserNestedInput
    organizedEvents?: EventUpdateManyWithoutOrganizerNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isCoordinator?: BoolFieldUpdateOperationsInput | boolean
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedChannels?: ChannelUncheckedUpdateManyWithoutOwnerNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesOverrideSet?: MessageUncheckedUpdateManyWithoutOverrideSetterNestedInput
    subscriptions?: ChannelSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invitationLinks?: InvitationLinkUncheckedUpdateManyWithoutCreatorNestedInput
    qrCodes?: QrCodeUncheckedUpdateManyWithoutCreatorNestedInput
    messageDeliveries?: MessageDeliveryUncheckedUpdateManyWithoutUserNestedInput
    messageApprovals?: MessageApprovalUncheckedUpdateManyWithoutApproverNestedInput
    messageRevisionsEdited?: MessageRevisionUncheckedUpdateManyWithoutEditorNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    messagingSettings?: UserMessagingSettingUncheckedUpdateManyWithoutUserNestedInput
    approverAssignments?: ChannelApproverUncheckedUpdateManyWithoutUserNestedInput
    createdCategories?: MessageCategoryUncheckedUpdateManyWithoutCreatorNestedInput
    messageViews?: MessageViewUncheckedUpdateManyWithoutUserNestedInput
    channelVisits?: ChannelVisitUncheckedUpdateManyWithoutUserNestedInput
    createdForms?: FormUncheckedUpdateManyWithoutUserNestedInput
    organizedEvents?: EventUncheckedUpdateManyWithoutOrganizerNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    username: string
    fullName?: string | null
    avatarUrl?: string | null
    passwordHash?: string | null
    deviceId?: string | null
    isGuest?: boolean
    phoneNumber?: string | null
    isPhoneVerified?: boolean
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    isAdmin?: boolean
    isCoordinator?: boolean
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isCoordinator?: BoolFieldUpdateOperationsInput | boolean
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isCoordinator?: BoolFieldUpdateOperationsInput | boolean
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelCreateInput = {
    id?: string
    title: string
    description?: string | null
    websiteUrl?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: string | null
    icon?: string
    isPublic?: boolean
    isHidden?: boolean
    searchExactOnly?: boolean
    passwordHash?: string | null
    referenceCode?: string | null
    verificationStatus?: $Enums.VerificationStatus
    approvalPolicy?: $Enums.ApprovalPolicy
    memberCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedChannelsInput
    organization: OrganizationCreateNestedOneWithoutChannelsInput
    parent?: ChannelCreateNestedOneWithoutSubchannelsInput
    subchannels?: ChannelCreateNestedManyWithoutParentInput
    messages?: MessageCreateNestedManyWithoutChannelInput
    subscriptions?: ChannelSubscriptionCreateNestedManyWithoutChannelInput
    invitationLinks?: InvitationLinkCreateNestedManyWithoutChannelInput
    qrCodes?: QrCodeCreateNestedManyWithoutChannelInput
    approvers?: ChannelApproverCreateNestedManyWithoutChannelInput
    verificationDocs?: ChannelVerificationDocumentCreateNestedManyWithoutChannelInput
    categories?: ChannelCategoryAssignmentCreateNestedManyWithoutChannelInput
    messageCategories?: MessageCategoryCreateNestedManyWithoutChannelInput
    visits?: ChannelVisitCreateNestedManyWithoutChannelInput
  }

  export type ChannelUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    websiteUrl?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: string | null
    icon?: string
    parentId?: string | null
    ownerId: string
    organizationId: string
    isPublic?: boolean
    isHidden?: boolean
    searchExactOnly?: boolean
    passwordHash?: string | null
    referenceCode?: string | null
    verificationStatus?: $Enums.VerificationStatus
    approvalPolicy?: $Enums.ApprovalPolicy
    memberCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    subchannels?: ChannelUncheckedCreateNestedManyWithoutParentInput
    messages?: MessageUncheckedCreateNestedManyWithoutChannelInput
    subscriptions?: ChannelSubscriptionUncheckedCreateNestedManyWithoutChannelInput
    invitationLinks?: InvitationLinkUncheckedCreateNestedManyWithoutChannelInput
    qrCodes?: QrCodeUncheckedCreateNestedManyWithoutChannelInput
    approvers?: ChannelApproverUncheckedCreateNestedManyWithoutChannelInput
    verificationDocs?: ChannelVerificationDocumentUncheckedCreateNestedManyWithoutChannelInput
    categories?: ChannelCategoryAssignmentUncheckedCreateNestedManyWithoutChannelInput
    messageCategories?: MessageCategoryUncheckedCreateNestedManyWithoutChannelInput
    visits?: ChannelVisitUncheckedCreateNestedManyWithoutChannelInput
  }

  export type ChannelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    searchExactOnly?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    approvalPolicy?: EnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy
    memberCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedChannelsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutChannelsNestedInput
    parent?: ChannelUpdateOneWithoutSubchannelsNestedInput
    subchannels?: ChannelUpdateManyWithoutParentNestedInput
    messages?: MessageUpdateManyWithoutChannelNestedInput
    subscriptions?: ChannelSubscriptionUpdateManyWithoutChannelNestedInput
    invitationLinks?: InvitationLinkUpdateManyWithoutChannelNestedInput
    qrCodes?: QrCodeUpdateManyWithoutChannelNestedInput
    approvers?: ChannelApproverUpdateManyWithoutChannelNestedInput
    verificationDocs?: ChannelVerificationDocumentUpdateManyWithoutChannelNestedInput
    categories?: ChannelCategoryAssignmentUpdateManyWithoutChannelNestedInput
    messageCategories?: MessageCategoryUpdateManyWithoutChannelNestedInput
    visits?: ChannelVisitUpdateManyWithoutChannelNestedInput
  }

  export type ChannelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    searchExactOnly?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    approvalPolicy?: EnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy
    memberCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subchannels?: ChannelUncheckedUpdateManyWithoutParentNestedInput
    messages?: MessageUncheckedUpdateManyWithoutChannelNestedInput
    subscriptions?: ChannelSubscriptionUncheckedUpdateManyWithoutChannelNestedInput
    invitationLinks?: InvitationLinkUncheckedUpdateManyWithoutChannelNestedInput
    qrCodes?: QrCodeUncheckedUpdateManyWithoutChannelNestedInput
    approvers?: ChannelApproverUncheckedUpdateManyWithoutChannelNestedInput
    verificationDocs?: ChannelVerificationDocumentUncheckedUpdateManyWithoutChannelNestedInput
    categories?: ChannelCategoryAssignmentUncheckedUpdateManyWithoutChannelNestedInput
    messageCategories?: MessageCategoryUncheckedUpdateManyWithoutChannelNestedInput
    visits?: ChannelVisitUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type ChannelCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    websiteUrl?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: string | null
    icon?: string
    parentId?: string | null
    ownerId: string
    organizationId: string
    isPublic?: boolean
    isHidden?: boolean
    searchExactOnly?: boolean
    passwordHash?: string | null
    referenceCode?: string | null
    verificationStatus?: $Enums.VerificationStatus
    approvalPolicy?: $Enums.ApprovalPolicy
    memberCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChannelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    searchExactOnly?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    approvalPolicy?: EnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy
    memberCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    searchExactOnly?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    approvalPolicy?: EnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy
    memberCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    content: string
    durationSeconds?: number
    expiresAt?: Date | string | null
    isEmergency?: boolean
    isImmediate?: boolean
    priority?: $Enums.MessagePriority
    approvalOverride?: $Enums.ApprovalPolicy | null
    approvalOverrideSetAt?: Date | string | null
    deliveryMethod?: $Enums.DeliveryMethod
    eventAt?: Date | string | null
    publishedAt?: Date | string | null
    state?: $Enums.MessageState
    createdAt?: Date | string
    updatedAt?: Date | string
    channel: ChannelCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutMessagesSentInput
    category: MessageCategoryCreateNestedOneWithoutMessagesInput
    overrideSetter?: UserCreateNestedOneWithoutMessagesOverrideSetInput
    deliveries?: MessageDeliveryCreateNestedManyWithoutMessageInput
    approvals?: MessageApprovalCreateNestedManyWithoutMessageInput
    attachments?: MessageAttachmentCreateNestedManyWithoutMessageInput
    revisions?: MessageRevisionCreateNestedManyWithoutMessageInput
    views?: MessageViewCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    channelId: string
    senderId: string
    categoryId: string
    content: string
    durationSeconds?: number
    expiresAt?: Date | string | null
    isEmergency?: boolean
    isImmediate?: boolean
    priority?: $Enums.MessagePriority
    approvalOverride?: $Enums.ApprovalPolicy | null
    approvalOverrideSetBy?: string | null
    approvalOverrideSetAt?: Date | string | null
    deliveryMethod?: $Enums.DeliveryMethod
    eventAt?: Date | string | null
    publishedAt?: Date | string | null
    state?: $Enums.MessageState
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveries?: MessageDeliveryUncheckedCreateNestedManyWithoutMessageInput
    approvals?: MessageApprovalUncheckedCreateNestedManyWithoutMessageInput
    attachments?: MessageAttachmentUncheckedCreateNestedManyWithoutMessageInput
    revisions?: MessageRevisionUncheckedCreateNestedManyWithoutMessageInput
    views?: MessageViewUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    durationSeconds?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    isImmediate?: BoolFieldUpdateOperationsInput | boolean
    priority?: EnumMessagePriorityFieldUpdateOperationsInput | $Enums.MessagePriority
    approvalOverride?: NullableEnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy | null
    approvalOverrideSetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    eventAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    state?: EnumMessageStateFieldUpdateOperationsInput | $Enums.MessageState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: ChannelUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutMessagesSentNestedInput
    category?: MessageCategoryUpdateOneRequiredWithoutMessagesNestedInput
    overrideSetter?: UserUpdateOneWithoutMessagesOverrideSetNestedInput
    deliveries?: MessageDeliveryUpdateManyWithoutMessageNestedInput
    approvals?: MessageApprovalUpdateManyWithoutMessageNestedInput
    attachments?: MessageAttachmentUpdateManyWithoutMessageNestedInput
    revisions?: MessageRevisionUpdateManyWithoutMessageNestedInput
    views?: MessageViewUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    durationSeconds?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    isImmediate?: BoolFieldUpdateOperationsInput | boolean
    priority?: EnumMessagePriorityFieldUpdateOperationsInput | $Enums.MessagePriority
    approvalOverride?: NullableEnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy | null
    approvalOverrideSetBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvalOverrideSetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    eventAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    state?: EnumMessageStateFieldUpdateOperationsInput | $Enums.MessageState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: MessageDeliveryUncheckedUpdateManyWithoutMessageNestedInput
    approvals?: MessageApprovalUncheckedUpdateManyWithoutMessageNestedInput
    attachments?: MessageAttachmentUncheckedUpdateManyWithoutMessageNestedInput
    revisions?: MessageRevisionUncheckedUpdateManyWithoutMessageNestedInput
    views?: MessageViewUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageCreateManyInput = {
    id?: string
    channelId: string
    senderId: string
    categoryId: string
    content: string
    durationSeconds?: number
    expiresAt?: Date | string | null
    isEmergency?: boolean
    isImmediate?: boolean
    priority?: $Enums.MessagePriority
    approvalOverride?: $Enums.ApprovalPolicy | null
    approvalOverrideSetBy?: string | null
    approvalOverrideSetAt?: Date | string | null
    deliveryMethod?: $Enums.DeliveryMethod
    eventAt?: Date | string | null
    publishedAt?: Date | string | null
    state?: $Enums.MessageState
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    durationSeconds?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    isImmediate?: BoolFieldUpdateOperationsInput | boolean
    priority?: EnumMessagePriorityFieldUpdateOperationsInput | $Enums.MessagePriority
    approvalOverride?: NullableEnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy | null
    approvalOverrideSetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    eventAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    state?: EnumMessageStateFieldUpdateOperationsInput | $Enums.MessageState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    durationSeconds?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    isImmediate?: BoolFieldUpdateOperationsInput | boolean
    priority?: EnumMessagePriorityFieldUpdateOperationsInput | $Enums.MessagePriority
    approvalOverride?: NullableEnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy | null
    approvalOverrideSetBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvalOverrideSetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    eventAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    state?: EnumMessageStateFieldUpdateOperationsInput | $Enums.MessageState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelSubscriptionCreateInput = {
    id?: string
    subscribedAt?: Date | string
    isActive?: boolean
    isFavorite?: boolean
    receiveMessages?: boolean
    user: UserCreateNestedOneWithoutSubscriptionsInput
    channel: ChannelCreateNestedOneWithoutSubscriptionsInput
  }

  export type ChannelSubscriptionUncheckedCreateInput = {
    id?: string
    userId: string
    channelId: string
    subscribedAt?: Date | string
    isActive?: boolean
    isFavorite?: boolean
    receiveMessages?: boolean
  }

  export type ChannelSubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscribedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    receiveMessages?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutSubscriptionsNestedInput
    channel?: ChannelUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type ChannelSubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    subscribedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    receiveMessages?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ChannelSubscriptionCreateManyInput = {
    id?: string
    userId: string
    channelId: string
    subscribedAt?: Date | string
    isActive?: boolean
    isFavorite?: boolean
    receiveMessages?: boolean
  }

  export type ChannelSubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscribedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    receiveMessages?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ChannelSubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    subscribedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    receiveMessages?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AuditLogCreateInput = {
    id?: string
    actorId: string
    action: string
    targetUserId?: string | null
    targetChannelId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    actorId: string
    action: string
    targetUserId?: string | null
    targetChannelId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetUserId?: NullableStringFieldUpdateOperationsInput | string | null
    targetChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetUserId?: NullableStringFieldUpdateOperationsInput | string | null
    targetChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    actorId: string
    action: string
    targetUserId?: string | null
    targetChannelId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetUserId?: NullableStringFieldUpdateOperationsInput | string | null
    targetChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetUserId?: NullableStringFieldUpdateOperationsInput | string | null
    targetChannelId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageDeliveryCreateInput = {
    id?: string
    deliveryStatus?: $Enums.DeliveryStatus
    deliveryMethod?: $Enums.DeliveryMethod | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
    message: MessageCreateNestedOneWithoutDeliveriesInput
    user: UserCreateNestedOneWithoutMessageDeliveriesInput
  }

  export type MessageDeliveryUncheckedCreateInput = {
    id?: string
    messageId: string
    userId: string
    deliveryStatus?: $Enums.DeliveryStatus
    deliveryMethod?: $Enums.DeliveryMethod | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MessageDeliveryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deliveryStatus?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    deliveryMethod?: NullableEnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneRequiredWithoutDeliveriesNestedInput
    user?: UserUpdateOneRequiredWithoutMessageDeliveriesNestedInput
  }

  export type MessageDeliveryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    deliveryStatus?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    deliveryMethod?: NullableEnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageDeliveryCreateManyInput = {
    id?: string
    messageId: string
    userId: string
    deliveryStatus?: $Enums.DeliveryStatus
    deliveryMethod?: $Enums.DeliveryMethod | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MessageDeliveryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    deliveryStatus?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    deliveryMethod?: NullableEnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageDeliveryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    deliveryStatus?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    deliveryMethod?: NullableEnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationLinkCreateInput = {
    id?: string
    linkCode: string
    expiresAt?: Date | string | null
    maxUses?: number | null
    currentUses?: number
    isActive?: boolean
    createdAt?: Date | string
    channel: ChannelCreateNestedOneWithoutInvitationLinksInput
    creator: UserCreateNestedOneWithoutInvitationLinksInput
  }

  export type InvitationLinkUncheckedCreateInput = {
    id?: string
    channelId: string
    createdBy: string
    linkCode: string
    expiresAt?: Date | string | null
    maxUses?: number | null
    currentUses?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type InvitationLinkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    linkCode?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    currentUses?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: ChannelUpdateOneRequiredWithoutInvitationLinksNestedInput
    creator?: UserUpdateOneRequiredWithoutInvitationLinksNestedInput
  }

  export type InvitationLinkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    linkCode?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    currentUses?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationLinkCreateManyInput = {
    id?: string
    channelId: string
    createdBy: string
    linkCode: string
    expiresAt?: Date | string | null
    maxUses?: number | null
    currentUses?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type InvitationLinkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    linkCode?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    currentUses?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationLinkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    linkCode?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    currentUses?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QrCodeCreateInput = {
    id?: string
    qrData: string
    expiresAt?: Date | string | null
    scanCount?: number
    isActive?: boolean
    createdAt?: Date | string
    channel: ChannelCreateNestedOneWithoutQrCodesInput
    creator: UserCreateNestedOneWithoutQrCodesInput
  }

  export type QrCodeUncheckedCreateInput = {
    id?: string
    channelId: string
    createdBy: string
    qrData: string
    expiresAt?: Date | string | null
    scanCount?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type QrCodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrData?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scanCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: ChannelUpdateOneRequiredWithoutQrCodesNestedInput
    creator?: UserUpdateOneRequiredWithoutQrCodesNestedInput
  }

  export type QrCodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    qrData?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scanCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QrCodeCreateManyInput = {
    id?: string
    channelId: string
    createdBy: string
    qrData: string
    expiresAt?: Date | string | null
    scanCount?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type QrCodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrData?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scanCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QrCodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    qrData?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scanCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationCreateInput = {
    id?: string
    name: string
    nit: string
    createdAt?: Date | string
    updatedAt?: Date | string
    channels?: ChannelCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateInput = {
    id?: string
    name: string
    nit: string
    createdAt?: Date | string
    updatedAt?: Date | string
    channels?: ChannelUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channels?: ChannelUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channels?: ChannelUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateManyInput = {
    id?: string
    name: string
    nit: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelApproverCreateInput = {
    id?: string
    isActive?: boolean
    removedAt?: Date | string | null
    removedBy?: string | null
    createdAt?: Date | string
    channel: ChannelCreateNestedOneWithoutApproversInput
    user: UserCreateNestedOneWithoutApproverAssignmentsInput
  }

  export type ChannelApproverUncheckedCreateInput = {
    id?: string
    channelId: string
    userId: string
    isActive?: boolean
    removedAt?: Date | string | null
    removedBy?: string | null
    createdAt?: Date | string
  }

  export type ChannelApproverUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: ChannelUpdateOneRequiredWithoutApproversNestedInput
    user?: UserUpdateOneRequiredWithoutApproverAssignmentsNestedInput
  }

  export type ChannelApproverUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelApproverCreateManyInput = {
    id?: string
    channelId: string
    userId: string
    isActive?: boolean
    removedAt?: Date | string | null
    removedBy?: string | null
    createdAt?: Date | string
  }

  export type ChannelApproverUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelApproverUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageApprovalCreateInput = {
    id?: string
    status?: $Enums.ApprovalStatus
    decidedAt?: Date | string | null
    message: MessageCreateNestedOneWithoutApprovalsInput
    approver: UserCreateNestedOneWithoutMessageApprovalsInput
  }

  export type MessageApprovalUncheckedCreateInput = {
    id?: string
    messageId: string
    approverId: string
    status?: $Enums.ApprovalStatus
    decidedAt?: Date | string | null
  }

  export type MessageApprovalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: MessageUpdateOneRequiredWithoutApprovalsNestedInput
    approver?: UserUpdateOneRequiredWithoutMessageApprovalsNestedInput
  }

  export type MessageApprovalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    approverId?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageApprovalCreateManyInput = {
    id?: string
    messageId: string
    approverId: string
    status?: $Enums.ApprovalStatus
    decidedAt?: Date | string | null
  }

  export type MessageApprovalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageApprovalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    approverId?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageCategoryCreateInput = {
    id?: string
    name: string
    scope?: $Enums.CategoryScope
    createdAt?: Date | string
    channel?: ChannelCreateNestedOneWithoutMessageCategoriesInput
    creator?: UserCreateNestedOneWithoutCreatedCategoriesInput
    messages?: MessageCreateNestedManyWithoutCategoryInput
  }

  export type MessageCategoryUncheckedCreateInput = {
    id?: string
    name: string
    scope?: $Enums.CategoryScope
    channelId?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type MessageCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    scope?: EnumCategoryScopeFieldUpdateOperationsInput | $Enums.CategoryScope
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: ChannelUpdateOneWithoutMessageCategoriesNestedInput
    creator?: UserUpdateOneWithoutCreatedCategoriesNestedInput
    messages?: MessageUpdateManyWithoutCategoryNestedInput
  }

  export type MessageCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    scope?: EnumCategoryScopeFieldUpdateOperationsInput | $Enums.CategoryScope
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type MessageCategoryCreateManyInput = {
    id?: string
    name: string
    scope?: $Enums.CategoryScope
    channelId?: string | null
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type MessageCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    scope?: EnumCategoryScopeFieldUpdateOperationsInput | $Enums.CategoryScope
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    scope?: EnumCategoryScopeFieldUpdateOperationsInput | $Enums.CategoryScope
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageAttachmentCreateInput = {
    id?: string
    type: $Enums.AttachmentType
    url: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    message: MessageCreateNestedOneWithoutAttachmentsInput
  }

  export type MessageAttachmentUncheckedCreateInput = {
    id?: string
    messageId: string
    type: $Enums.AttachmentType
    url: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MessageAttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAttachmentTypeFieldUpdateOperationsInput | $Enums.AttachmentType
    url?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type MessageAttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    type?: EnumAttachmentTypeFieldUpdateOperationsInput | $Enums.AttachmentType
    url?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageAttachmentCreateManyInput = {
    id?: string
    messageId: string
    type: $Enums.AttachmentType
    url: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MessageAttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAttachmentTypeFieldUpdateOperationsInput | $Enums.AttachmentType
    url?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageAttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    type?: EnumAttachmentTypeFieldUpdateOperationsInput | $Enums.AttachmentType
    url?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageRevisionCreateInput = {
    id?: string
    previousContent: string
    previousCategoryId?: string | null
    previousPriority: $Enums.MessagePriority
    previousIsImmediate: boolean
    previousDeliveryMethod: $Enums.DeliveryMethod
    changedAt?: Date | string
    message: MessageCreateNestedOneWithoutRevisionsInput
    editor: UserCreateNestedOneWithoutMessageRevisionsEditedInput
  }

  export type MessageRevisionUncheckedCreateInput = {
    id?: string
    messageId: string
    editorId: string
    previousContent: string
    previousCategoryId?: string | null
    previousPriority: $Enums.MessagePriority
    previousIsImmediate: boolean
    previousDeliveryMethod: $Enums.DeliveryMethod
    changedAt?: Date | string
  }

  export type MessageRevisionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    previousContent?: StringFieldUpdateOperationsInput | string
    previousCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    previousPriority?: EnumMessagePriorityFieldUpdateOperationsInput | $Enums.MessagePriority
    previousIsImmediate?: BoolFieldUpdateOperationsInput | boolean
    previousDeliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneRequiredWithoutRevisionsNestedInput
    editor?: UserUpdateOneRequiredWithoutMessageRevisionsEditedNestedInput
  }

  export type MessageRevisionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    previousContent?: StringFieldUpdateOperationsInput | string
    previousCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    previousPriority?: EnumMessagePriorityFieldUpdateOperationsInput | $Enums.MessagePriority
    previousIsImmediate?: BoolFieldUpdateOperationsInput | boolean
    previousDeliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageRevisionCreateManyInput = {
    id?: string
    messageId: string
    editorId: string
    previousContent: string
    previousCategoryId?: string | null
    previousPriority: $Enums.MessagePriority
    previousIsImmediate: boolean
    previousDeliveryMethod: $Enums.DeliveryMethod
    changedAt?: Date | string
  }

  export type MessageRevisionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    previousContent?: StringFieldUpdateOperationsInput | string
    previousCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    previousPriority?: EnumMessagePriorityFieldUpdateOperationsInput | $Enums.MessagePriority
    previousIsImmediate?: BoolFieldUpdateOperationsInput | boolean
    previousDeliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageRevisionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    previousContent?: StringFieldUpdateOperationsInput | string
    previousCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    previousPriority?: EnumMessagePriorityFieldUpdateOperationsInput | $Enums.MessagePriority
    previousIsImmediate?: BoolFieldUpdateOperationsInput | boolean
    previousDeliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelVerificationDocumentCreateInput = {
    id?: string
    title: string
    docUrl: string
    issuer?: string | null
    issuedAt?: Date | string | null
    createdAt?: Date | string
    channel: ChannelCreateNestedOneWithoutVerificationDocsInput
  }

  export type ChannelVerificationDocumentUncheckedCreateInput = {
    id?: string
    channelId: string
    title: string
    docUrl: string
    issuer?: string | null
    issuedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ChannelVerificationDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    docUrl?: StringFieldUpdateOperationsInput | string
    issuer?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: ChannelUpdateOneRequiredWithoutVerificationDocsNestedInput
  }

  export type ChannelVerificationDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    docUrl?: StringFieldUpdateOperationsInput | string
    issuer?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelVerificationDocumentCreateManyInput = {
    id?: string
    channelId: string
    title: string
    docUrl: string
    issuer?: string | null
    issuedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ChannelVerificationDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    docUrl?: StringFieldUpdateOperationsInput | string
    issuer?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelVerificationDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    docUrl?: StringFieldUpdateOperationsInput | string
    issuer?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileCreateInput = {
    id?: string
    country?: string | null
    department?: string | null
    city?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutProfileInput
  }

  export type UserProfileUncheckedCreateInput = {
    id?: string
    userId: string
    country?: string | null
    department?: string | null
    city?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
  }

  export type UserProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserProfileCreateManyInput = {
    id?: string
    userId: string
    country?: string | null
    department?: string | null
    city?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserMessagingSettingCreateInput = {
    id?: string
    platform: $Enums.MessagingPlatform
    handle?: string | null
    isEnabled?: boolean
    verified?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutMessagingSettingsInput
  }

  export type UserMessagingSettingUncheckedCreateInput = {
    id?: string
    userId: string
    platform: $Enums.MessagingPlatform
    handle?: string | null
    isEnabled?: boolean
    verified?: boolean
    createdAt?: Date | string
  }

  export type UserMessagingSettingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: EnumMessagingPlatformFieldUpdateOperationsInput | $Enums.MessagingPlatform
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMessagingSettingsNestedInput
  }

  export type UserMessagingSettingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    platform?: EnumMessagingPlatformFieldUpdateOperationsInput | $Enums.MessagingPlatform
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserMessagingSettingCreateManyInput = {
    id?: string
    userId: string
    platform: $Enums.MessagingPlatform
    handle?: string | null
    isEnabled?: boolean
    verified?: boolean
    createdAt?: Date | string
  }

  export type UserMessagingSettingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: EnumMessagingPlatformFieldUpdateOperationsInput | $Enums.MessagingPlatform
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserMessagingSettingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    platform?: EnumMessagingPlatformFieldUpdateOperationsInput | $Enums.MessagingPlatform
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelCategoryCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    assignments?: ChannelCategoryAssignmentCreateNestedManyWithoutCategoryInput
  }

  export type ChannelCategoryUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    assignments?: ChannelCategoryAssignmentUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ChannelCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: ChannelCategoryAssignmentUpdateManyWithoutCategoryNestedInput
  }

  export type ChannelCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: ChannelCategoryAssignmentUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ChannelCategoryCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
  }

  export type ChannelCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelCategoryAssignmentCreateInput = {
    id?: string
    channel: ChannelCreateNestedOneWithoutCategoriesInput
    category: ChannelCategoryCreateNestedOneWithoutAssignmentsInput
  }

  export type ChannelCategoryAssignmentUncheckedCreateInput = {
    id?: string
    channelId: string
    categoryId: string
  }

  export type ChannelCategoryAssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: ChannelUpdateOneRequiredWithoutCategoriesNestedInput
    category?: ChannelCategoryUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type ChannelCategoryAssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type ChannelCategoryAssignmentCreateManyInput = {
    id?: string
    channelId: string
    categoryId: string
  }

  export type ChannelCategoryAssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type ChannelCategoryAssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageViewCreateInput = {
    id?: string
    viewedAt?: Date | string
    message: MessageCreateNestedOneWithoutViewsInput
    user?: UserCreateNestedOneWithoutMessageViewsInput
  }

  export type MessageViewUncheckedCreateInput = {
    id?: string
    messageId: string
    userId?: string | null
    viewedAt?: Date | string
  }

  export type MessageViewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneRequiredWithoutViewsNestedInput
    user?: UserUpdateOneWithoutMessageViewsNestedInput
  }

  export type MessageViewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageViewCreateManyInput = {
    id?: string
    messageId: string
    userId?: string | null
    viewedAt?: Date | string
  }

  export type MessageViewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageViewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelVisitCreateInput = {
    id?: string
    visitedAt?: Date | string
    channel: ChannelCreateNestedOneWithoutVisitsInput
    user?: UserCreateNestedOneWithoutChannelVisitsInput
  }

  export type ChannelVisitUncheckedCreateInput = {
    id?: string
    channelId: string
    userId?: string | null
    visitedAt?: Date | string
  }

  export type ChannelVisitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: ChannelUpdateOneRequiredWithoutVisitsNestedInput
    user?: UserUpdateOneWithoutChannelVisitsNestedInput
  }

  export type ChannelVisitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    visitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelVisitCreateManyInput = {
    id?: string
    channelId: string
    userId?: string | null
    visitedAt?: Date | string
  }

  export type ChannelVisitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelVisitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    visitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormCreateInput = {
    id?: string
    title: string
    description?: string | null
    slug: string
    headerContent?: string | null
    footerContent?: string | null
    successMessage?: string | null
    isActive?: boolean
    isPublished?: boolean
    wasPublished?: boolean
    isDeleted?: boolean
    collectUserInfo?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCreatedFormsInput
    fields?: FormFieldCreateNestedManyWithoutFormInput
    submissions?: FormSubmissionCreateNestedManyWithoutFormInput
  }

  export type FormUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    slug: string
    headerContent?: string | null
    footerContent?: string | null
    successMessage?: string | null
    isActive?: boolean
    isPublished?: boolean
    wasPublished?: boolean
    isDeleted?: boolean
    collectUserInfo?: boolean
    expiresAt?: Date | string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fields?: FormFieldUncheckedCreateNestedManyWithoutFormInput
    submissions?: FormSubmissionUncheckedCreateNestedManyWithoutFormInput
  }

  export type FormUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    headerContent?: NullableStringFieldUpdateOperationsInput | string | null
    footerContent?: NullableStringFieldUpdateOperationsInput | string | null
    successMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    wasPublished?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    collectUserInfo?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCreatedFormsNestedInput
    fields?: FormFieldUpdateManyWithoutFormNestedInput
    submissions?: FormSubmissionUpdateManyWithoutFormNestedInput
  }

  export type FormUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    headerContent?: NullableStringFieldUpdateOperationsInput | string | null
    footerContent?: NullableStringFieldUpdateOperationsInput | string | null
    successMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    wasPublished?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    collectUserInfo?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fields?: FormFieldUncheckedUpdateManyWithoutFormNestedInput
    submissions?: FormSubmissionUncheckedUpdateManyWithoutFormNestedInput
  }

  export type FormCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    slug: string
    headerContent?: string | null
    footerContent?: string | null
    successMessage?: string | null
    isActive?: boolean
    isPublished?: boolean
    wasPublished?: boolean
    isDeleted?: boolean
    collectUserInfo?: boolean
    expiresAt?: Date | string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    headerContent?: NullableStringFieldUpdateOperationsInput | string | null
    footerContent?: NullableStringFieldUpdateOperationsInput | string | null
    successMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    wasPublished?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    collectUserInfo?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    headerContent?: NullableStringFieldUpdateOperationsInput | string | null
    footerContent?: NullableStringFieldUpdateOperationsInput | string | null
    successMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    wasPublished?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    collectUserInfo?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormFieldCreateInput = {
    id?: string
    type: string
    label: string
    placeholder?: string | null
    required?: boolean
    isHidden?: boolean
    options?: NullableJsonNullValueInput | InputJsonValue
    order?: number
    createdAt?: Date | string
    form: FormCreateNestedOneWithoutFieldsInput
  }

  export type FormFieldUncheckedCreateInput = {
    id?: string
    formId: string
    type: string
    label: string
    placeholder?: string | null
    required?: boolean
    isHidden?: boolean
    options?: NullableJsonNullValueInput | InputJsonValue
    order?: number
    createdAt?: Date | string
  }

  export type FormFieldUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    required?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    options?: NullableJsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    form?: FormUpdateOneRequiredWithoutFieldsNestedInput
  }

  export type FormFieldUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    required?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    options?: NullableJsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormFieldCreateManyInput = {
    id?: string
    formId: string
    type: string
    label: string
    placeholder?: string | null
    required?: boolean
    isHidden?: boolean
    options?: NullableJsonNullValueInput | InputJsonValue
    order?: number
    createdAt?: Date | string
  }

  export type FormFieldUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    required?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    options?: NullableJsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormFieldUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    required?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    options?: NullableJsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormSubmissionCreateInput = {
    id?: string
    data: JsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    country?: string | null
    city?: string | null
    userAgent?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    form: FormCreateNestedOneWithoutSubmissionsInput
  }

  export type FormSubmissionUncheckedCreateInput = {
    id?: string
    formId: string
    data: JsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    country?: string | null
    city?: string | null
    userAgent?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type FormSubmissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    form?: FormUpdateOneRequiredWithoutSubmissionsNestedInput
  }

  export type FormSubmissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormSubmissionCreateManyInput = {
    id?: string
    formId: string
    data: JsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    country?: string | null
    city?: string | null
    userAgent?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type FormSubmissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormSubmissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCreateInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    location: string
    imageUrl?: string | null
    status?: $Enums.EventStatus
    categories?: NullableJsonNullValueInput | InputJsonValue
    paymentInfo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organizer: UserCreateNestedOneWithoutOrganizedEventsInput
    zones?: EventZoneCreateNestedManyWithoutEventInput
    seats?: EventSeatCreateNestedManyWithoutEventInput
    tickets?: TicketCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    location: string
    imageUrl?: string | null
    status?: $Enums.EventStatus
    categories?: NullableJsonNullValueInput | InputJsonValue
    paymentInfo?: string | null
    organizerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    zones?: EventZoneUncheckedCreateNestedManyWithoutEventInput
    seats?: EventSeatUncheckedCreateNestedManyWithoutEventInput
    tickets?: TicketUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    categories?: NullableJsonNullValueInput | InputJsonValue
    paymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizer?: UserUpdateOneRequiredWithoutOrganizedEventsNestedInput
    zones?: EventZoneUpdateManyWithoutEventNestedInput
    seats?: EventSeatUpdateManyWithoutEventNestedInput
    tickets?: TicketUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    categories?: NullableJsonNullValueInput | InputJsonValue
    paymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    organizerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zones?: EventZoneUncheckedUpdateManyWithoutEventNestedInput
    seats?: EventSeatUncheckedUpdateManyWithoutEventNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    location: string
    imageUrl?: string | null
    status?: $Enums.EventStatus
    categories?: NullableJsonNullValueInput | InputJsonValue
    paymentInfo?: string | null
    organizerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    categories?: NullableJsonNullValueInput | InputJsonValue
    paymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    categories?: NullableJsonNullValueInput | InputJsonValue
    paymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    organizerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventZoneCreateInput = {
    id?: string
    name: string
    color: string
    price: number
    rows: number
    cols: number
    capacity?: number | null
    type?: $Enums.ZoneType
    layout?: NullableJsonNullValueInput | InputJsonValue
    seatGap?: number | null
    startNumber?: number
    numberingDirection?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    event: EventCreateNestedOneWithoutZonesInput
    seats?: EventSeatCreateNestedManyWithoutZoneInput
    tickets?: TicketCreateNestedManyWithoutZoneInput
  }

  export type EventZoneUncheckedCreateInput = {
    id?: string
    eventId: string
    name: string
    color: string
    price: number
    rows: number
    cols: number
    capacity?: number | null
    type?: $Enums.ZoneType
    layout?: NullableJsonNullValueInput | InputJsonValue
    seatGap?: number | null
    startNumber?: number
    numberingDirection?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    seats?: EventSeatUncheckedCreateNestedManyWithoutZoneInput
    tickets?: TicketUncheckedCreateNestedManyWithoutZoneInput
  }

  export type EventZoneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    rows?: IntFieldUpdateOperationsInput | number
    cols?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumZoneTypeFieldUpdateOperationsInput | $Enums.ZoneType
    layout?: NullableJsonNullValueInput | InputJsonValue
    seatGap?: NullableIntFieldUpdateOperationsInput | number | null
    startNumber?: IntFieldUpdateOperationsInput | number
    numberingDirection?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutZonesNestedInput
    seats?: EventSeatUpdateManyWithoutZoneNestedInput
    tickets?: TicketUpdateManyWithoutZoneNestedInput
  }

  export type EventZoneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    rows?: IntFieldUpdateOperationsInput | number
    cols?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumZoneTypeFieldUpdateOperationsInput | $Enums.ZoneType
    layout?: NullableJsonNullValueInput | InputJsonValue
    seatGap?: NullableIntFieldUpdateOperationsInput | number | null
    startNumber?: IntFieldUpdateOperationsInput | number
    numberingDirection?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seats?: EventSeatUncheckedUpdateManyWithoutZoneNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type EventZoneCreateManyInput = {
    id?: string
    eventId: string
    name: string
    color: string
    price: number
    rows: number
    cols: number
    capacity?: number | null
    type?: $Enums.ZoneType
    layout?: NullableJsonNullValueInput | InputJsonValue
    seatGap?: number | null
    startNumber?: number
    numberingDirection?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventZoneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    rows?: IntFieldUpdateOperationsInput | number
    cols?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumZoneTypeFieldUpdateOperationsInput | $Enums.ZoneType
    layout?: NullableJsonNullValueInput | InputJsonValue
    seatGap?: NullableIntFieldUpdateOperationsInput | number | null
    startNumber?: IntFieldUpdateOperationsInput | number
    numberingDirection?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventZoneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    rows?: IntFieldUpdateOperationsInput | number
    cols?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumZoneTypeFieldUpdateOperationsInput | $Enums.ZoneType
    layout?: NullableJsonNullValueInput | InputJsonValue
    seatGap?: NullableIntFieldUpdateOperationsInput | number | null
    startNumber?: IntFieldUpdateOperationsInput | number
    numberingDirection?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventSeatCreateInput = {
    id?: string
    rowLabel: string
    colLabel: string
    status?: $Enums.SeatStatus
    type?: $Enums.SeatType
    price?: number | null
    x?: number | null
    y?: number | null
    holderName?: string | null
    ticketCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    event: EventCreateNestedOneWithoutSeatsInput
    zone: EventZoneCreateNestedOneWithoutSeatsInput
    tickets?: TicketCreateNestedManyWithoutSeatInput
  }

  export type EventSeatUncheckedCreateInput = {
    id?: string
    eventId: string
    zoneId: string
    rowLabel: string
    colLabel: string
    status?: $Enums.SeatStatus
    type?: $Enums.SeatType
    price?: number | null
    x?: number | null
    y?: number | null
    holderName?: string | null
    ticketCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: TicketUncheckedCreateNestedManyWithoutSeatInput
  }

  export type EventSeatUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rowLabel?: StringFieldUpdateOperationsInput | string
    colLabel?: StringFieldUpdateOperationsInput | string
    status?: EnumSeatStatusFieldUpdateOperationsInput | $Enums.SeatStatus
    type?: EnumSeatTypeFieldUpdateOperationsInput | $Enums.SeatType
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    x?: NullableIntFieldUpdateOperationsInput | number | null
    y?: NullableIntFieldUpdateOperationsInput | number | null
    holderName?: NullableStringFieldUpdateOperationsInput | string | null
    ticketCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutSeatsNestedInput
    zone?: EventZoneUpdateOneRequiredWithoutSeatsNestedInput
    tickets?: TicketUpdateManyWithoutSeatNestedInput
  }

  export type EventSeatUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    rowLabel?: StringFieldUpdateOperationsInput | string
    colLabel?: StringFieldUpdateOperationsInput | string
    status?: EnumSeatStatusFieldUpdateOperationsInput | $Enums.SeatStatus
    type?: EnumSeatTypeFieldUpdateOperationsInput | $Enums.SeatType
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    x?: NullableIntFieldUpdateOperationsInput | number | null
    y?: NullableIntFieldUpdateOperationsInput | number | null
    holderName?: NullableStringFieldUpdateOperationsInput | string | null
    ticketCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUncheckedUpdateManyWithoutSeatNestedInput
  }

  export type EventSeatCreateManyInput = {
    id?: string
    eventId: string
    zoneId: string
    rowLabel: string
    colLabel: string
    status?: $Enums.SeatStatus
    type?: $Enums.SeatType
    price?: number | null
    x?: number | null
    y?: number | null
    holderName?: string | null
    ticketCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventSeatUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rowLabel?: StringFieldUpdateOperationsInput | string
    colLabel?: StringFieldUpdateOperationsInput | string
    status?: EnumSeatStatusFieldUpdateOperationsInput | $Enums.SeatStatus
    type?: EnumSeatTypeFieldUpdateOperationsInput | $Enums.SeatType
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    x?: NullableIntFieldUpdateOperationsInput | number | null
    y?: NullableIntFieldUpdateOperationsInput | number | null
    holderName?: NullableStringFieldUpdateOperationsInput | string | null
    ticketCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventSeatUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    rowLabel?: StringFieldUpdateOperationsInput | string
    colLabel?: StringFieldUpdateOperationsInput | string
    status?: EnumSeatStatusFieldUpdateOperationsInput | $Enums.SeatStatus
    type?: EnumSeatTypeFieldUpdateOperationsInput | $Enums.SeatType
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    x?: NullableIntFieldUpdateOperationsInput | number | null
    y?: NullableIntFieldUpdateOperationsInput | number | null
    holderName?: NullableStringFieldUpdateOperationsInput | string | null
    ticketCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCreateInput = {
    id?: string
    customerName: string
    customerEmail: string
    price: number
    status?: $Enums.TicketStatus
    purchaseDate?: Date | string
    qrCode?: string | null
    event: EventCreateNestedOneWithoutTicketsInput
    zone: EventZoneCreateNestedOneWithoutTicketsInput
    seat?: EventSeatCreateNestedOneWithoutTicketsInput
  }

  export type TicketUncheckedCreateInput = {
    id?: string
    eventId: string
    zoneId: string
    seatId?: string | null
    customerName: string
    customerEmail: string
    price: number
    status?: $Enums.TicketStatus
    purchaseDate?: Date | string
    qrCode?: string | null
  }

  export type TicketUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    event?: EventUpdateOneRequiredWithoutTicketsNestedInput
    zone?: EventZoneUpdateOneRequiredWithoutTicketsNestedInput
    seat?: EventSeatUpdateOneWithoutTicketsNestedInput
  }

  export type TicketUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    seatId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TicketCreateManyInput = {
    id?: string
    eventId: string
    zoneId: string
    seatId?: string | null
    customerName: string
    customerEmail: string
    price: number
    status?: $Enums.TicketStatus
    purchaseDate?: Date | string
    qrCode?: string | null
  }

  export type TicketUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TicketUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    seatId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ChannelListRelationFilter = {
    every?: ChannelWhereInput
    some?: ChannelWhereInput
    none?: ChannelWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type ChannelSubscriptionListRelationFilter = {
    every?: ChannelSubscriptionWhereInput
    some?: ChannelSubscriptionWhereInput
    none?: ChannelSubscriptionWhereInput
  }

  export type InvitationLinkListRelationFilter = {
    every?: InvitationLinkWhereInput
    some?: InvitationLinkWhereInput
    none?: InvitationLinkWhereInput
  }

  export type QrCodeListRelationFilter = {
    every?: QrCodeWhereInput
    some?: QrCodeWhereInput
    none?: QrCodeWhereInput
  }

  export type MessageDeliveryListRelationFilter = {
    every?: MessageDeliveryWhereInput
    some?: MessageDeliveryWhereInput
    none?: MessageDeliveryWhereInput
  }

  export type MessageApprovalListRelationFilter = {
    every?: MessageApprovalWhereInput
    some?: MessageApprovalWhereInput
    none?: MessageApprovalWhereInput
  }

  export type MessageRevisionListRelationFilter = {
    every?: MessageRevisionWhereInput
    some?: MessageRevisionWhereInput
    none?: MessageRevisionWhereInput
  }

  export type UserProfileNullableRelationFilter = {
    is?: UserProfileWhereInput | null
    isNot?: UserProfileWhereInput | null
  }

  export type UserMessagingSettingListRelationFilter = {
    every?: UserMessagingSettingWhereInput
    some?: UserMessagingSettingWhereInput
    none?: UserMessagingSettingWhereInput
  }

  export type ChannelApproverListRelationFilter = {
    every?: ChannelApproverWhereInput
    some?: ChannelApproverWhereInput
    none?: ChannelApproverWhereInput
  }

  export type MessageCategoryListRelationFilter = {
    every?: MessageCategoryWhereInput
    some?: MessageCategoryWhereInput
    none?: MessageCategoryWhereInput
  }

  export type MessageViewListRelationFilter = {
    every?: MessageViewWhereInput
    some?: MessageViewWhereInput
    none?: MessageViewWhereInput
  }

  export type ChannelVisitListRelationFilter = {
    every?: ChannelVisitWhereInput
    some?: ChannelVisitWhereInput
    none?: ChannelVisitWhereInput
  }

  export type FormListRelationFilter = {
    every?: FormWhereInput
    some?: FormWhereInput
    none?: FormWhereInput
  }

  export type EventListRelationFilter = {
    every?: EventWhereInput
    some?: EventWhereInput
    none?: EventWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ChannelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChannelSubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvitationLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QrCodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageDeliveryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageApprovalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageRevisionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserMessagingSettingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChannelApproverOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageViewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChannelVisitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FormOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    fullName?: SortOrder
    avatarUrl?: SortOrder
    passwordHash?: SortOrder
    deviceId?: SortOrder
    isGuest?: SortOrder
    phoneNumber?: SortOrder
    isPhoneVerified?: SortOrder
    verificationCode?: SortOrder
    verificationCodeExpiresAt?: SortOrder
    isAdmin?: SortOrder
    isCoordinator?: SortOrder
    isDisabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    fullName?: SortOrder
    avatarUrl?: SortOrder
    passwordHash?: SortOrder
    deviceId?: SortOrder
    isGuest?: SortOrder
    phoneNumber?: SortOrder
    isPhoneVerified?: SortOrder
    verificationCode?: SortOrder
    verificationCodeExpiresAt?: SortOrder
    isAdmin?: SortOrder
    isCoordinator?: SortOrder
    isDisabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    fullName?: SortOrder
    avatarUrl?: SortOrder
    passwordHash?: SortOrder
    deviceId?: SortOrder
    isGuest?: SortOrder
    phoneNumber?: SortOrder
    isPhoneVerified?: SortOrder
    verificationCode?: SortOrder
    verificationCodeExpiresAt?: SortOrder
    isAdmin?: SortOrder
    isCoordinator?: SortOrder
    isDisabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumVerificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[]
    notIn?: $Enums.VerificationStatus[]
    not?: NestedEnumVerificationStatusFilter<$PrismaModel> | $Enums.VerificationStatus
  }

  export type EnumApprovalPolicyFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalPolicy | EnumApprovalPolicyFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalPolicy[]
    notIn?: $Enums.ApprovalPolicy[]
    not?: NestedEnumApprovalPolicyFilter<$PrismaModel> | $Enums.ApprovalPolicy
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type OrganizationRelationFilter = {
    is?: OrganizationWhereInput
    isNot?: OrganizationWhereInput
  }

  export type ChannelNullableRelationFilter = {
    is?: ChannelWhereInput | null
    isNot?: ChannelWhereInput | null
  }

  export type ChannelVerificationDocumentListRelationFilter = {
    every?: ChannelVerificationDocumentWhereInput
    some?: ChannelVerificationDocumentWhereInput
    none?: ChannelVerificationDocumentWhereInput
  }

  export type ChannelCategoryAssignmentListRelationFilter = {
    every?: ChannelCategoryAssignmentWhereInput
    some?: ChannelCategoryAssignmentWhereInput
    none?: ChannelCategoryAssignmentWhereInput
  }

  export type ChannelVerificationDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChannelCategoryAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChannelCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    websiteUrl?: SortOrder
    socialLinks?: SortOrder
    logoUrl?: SortOrder
    icon?: SortOrder
    parentId?: SortOrder
    ownerId?: SortOrder
    organizationId?: SortOrder
    isPublic?: SortOrder
    isHidden?: SortOrder
    searchExactOnly?: SortOrder
    passwordHash?: SortOrder
    referenceCode?: SortOrder
    verificationStatus?: SortOrder
    approvalPolicy?: SortOrder
    memberCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChannelAvgOrderByAggregateInput = {
    memberCount?: SortOrder
  }

  export type ChannelMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    websiteUrl?: SortOrder
    logoUrl?: SortOrder
    icon?: SortOrder
    parentId?: SortOrder
    ownerId?: SortOrder
    organizationId?: SortOrder
    isPublic?: SortOrder
    isHidden?: SortOrder
    searchExactOnly?: SortOrder
    passwordHash?: SortOrder
    referenceCode?: SortOrder
    verificationStatus?: SortOrder
    approvalPolicy?: SortOrder
    memberCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChannelMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    websiteUrl?: SortOrder
    logoUrl?: SortOrder
    icon?: SortOrder
    parentId?: SortOrder
    ownerId?: SortOrder
    organizationId?: SortOrder
    isPublic?: SortOrder
    isHidden?: SortOrder
    searchExactOnly?: SortOrder
    passwordHash?: SortOrder
    referenceCode?: SortOrder
    verificationStatus?: SortOrder
    approvalPolicy?: SortOrder
    memberCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChannelSumOrderByAggregateInput = {
    memberCount?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumVerificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[]
    notIn?: $Enums.VerificationStatus[]
    not?: NestedEnumVerificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.VerificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVerificationStatusFilter<$PrismaModel>
    _max?: NestedEnumVerificationStatusFilter<$PrismaModel>
  }

  export type EnumApprovalPolicyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalPolicy | EnumApprovalPolicyFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalPolicy[]
    notIn?: $Enums.ApprovalPolicy[]
    not?: NestedEnumApprovalPolicyWithAggregatesFilter<$PrismaModel> | $Enums.ApprovalPolicy
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApprovalPolicyFilter<$PrismaModel>
    _max?: NestedEnumApprovalPolicyFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumMessagePriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.MessagePriority | EnumMessagePriorityFieldRefInput<$PrismaModel>
    in?: $Enums.MessagePriority[]
    notIn?: $Enums.MessagePriority[]
    not?: NestedEnumMessagePriorityFilter<$PrismaModel> | $Enums.MessagePriority
  }

  export type EnumApprovalPolicyNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalPolicy | EnumApprovalPolicyFieldRefInput<$PrismaModel> | null
    in?: $Enums.ApprovalPolicy[] | null
    notIn?: $Enums.ApprovalPolicy[] | null
    not?: NestedEnumApprovalPolicyNullableFilter<$PrismaModel> | $Enums.ApprovalPolicy | null
  }

  export type EnumDeliveryMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryMethod | EnumDeliveryMethodFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryMethod[]
    notIn?: $Enums.DeliveryMethod[]
    not?: NestedEnumDeliveryMethodFilter<$PrismaModel> | $Enums.DeliveryMethod
  }

  export type EnumMessageStateFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageState | EnumMessageStateFieldRefInput<$PrismaModel>
    in?: $Enums.MessageState[]
    notIn?: $Enums.MessageState[]
    not?: NestedEnumMessageStateFilter<$PrismaModel> | $Enums.MessageState
  }

  export type ChannelRelationFilter = {
    is?: ChannelWhereInput
    isNot?: ChannelWhereInput
  }

  export type MessageCategoryRelationFilter = {
    is?: MessageCategoryWhereInput
    isNot?: MessageCategoryWhereInput
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type MessageAttachmentListRelationFilter = {
    every?: MessageAttachmentWhereInput
    some?: MessageAttachmentWhereInput
    none?: MessageAttachmentWhereInput
  }

  export type MessageAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
    senderId?: SortOrder
    categoryId?: SortOrder
    content?: SortOrder
    durationSeconds?: SortOrder
    expiresAt?: SortOrder
    isEmergency?: SortOrder
    isImmediate?: SortOrder
    priority?: SortOrder
    approvalOverride?: SortOrder
    approvalOverrideSetBy?: SortOrder
    approvalOverrideSetAt?: SortOrder
    deliveryMethod?: SortOrder
    eventAt?: SortOrder
    publishedAt?: SortOrder
    state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageAvgOrderByAggregateInput = {
    durationSeconds?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
    senderId?: SortOrder
    categoryId?: SortOrder
    content?: SortOrder
    durationSeconds?: SortOrder
    expiresAt?: SortOrder
    isEmergency?: SortOrder
    isImmediate?: SortOrder
    priority?: SortOrder
    approvalOverride?: SortOrder
    approvalOverrideSetBy?: SortOrder
    approvalOverrideSetAt?: SortOrder
    deliveryMethod?: SortOrder
    eventAt?: SortOrder
    publishedAt?: SortOrder
    state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
    senderId?: SortOrder
    categoryId?: SortOrder
    content?: SortOrder
    durationSeconds?: SortOrder
    expiresAt?: SortOrder
    isEmergency?: SortOrder
    isImmediate?: SortOrder
    priority?: SortOrder
    approvalOverride?: SortOrder
    approvalOverrideSetBy?: SortOrder
    approvalOverrideSetAt?: SortOrder
    deliveryMethod?: SortOrder
    eventAt?: SortOrder
    publishedAt?: SortOrder
    state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageSumOrderByAggregateInput = {
    durationSeconds?: SortOrder
  }

  export type EnumMessagePriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessagePriority | EnumMessagePriorityFieldRefInput<$PrismaModel>
    in?: $Enums.MessagePriority[]
    notIn?: $Enums.MessagePriority[]
    not?: NestedEnumMessagePriorityWithAggregatesFilter<$PrismaModel> | $Enums.MessagePriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessagePriorityFilter<$PrismaModel>
    _max?: NestedEnumMessagePriorityFilter<$PrismaModel>
  }

  export type EnumApprovalPolicyNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalPolicy | EnumApprovalPolicyFieldRefInput<$PrismaModel> | null
    in?: $Enums.ApprovalPolicy[] | null
    notIn?: $Enums.ApprovalPolicy[] | null
    not?: NestedEnumApprovalPolicyNullableWithAggregatesFilter<$PrismaModel> | $Enums.ApprovalPolicy | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumApprovalPolicyNullableFilter<$PrismaModel>
    _max?: NestedEnumApprovalPolicyNullableFilter<$PrismaModel>
  }

  export type EnumDeliveryMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryMethod | EnumDeliveryMethodFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryMethod[]
    notIn?: $Enums.DeliveryMethod[]
    not?: NestedEnumDeliveryMethodWithAggregatesFilter<$PrismaModel> | $Enums.DeliveryMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeliveryMethodFilter<$PrismaModel>
    _max?: NestedEnumDeliveryMethodFilter<$PrismaModel>
  }

  export type EnumMessageStateWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageState | EnumMessageStateFieldRefInput<$PrismaModel>
    in?: $Enums.MessageState[]
    notIn?: $Enums.MessageState[]
    not?: NestedEnumMessageStateWithAggregatesFilter<$PrismaModel> | $Enums.MessageState
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageStateFilter<$PrismaModel>
    _max?: NestedEnumMessageStateFilter<$PrismaModel>
  }

  export type ChannelSubscriptionUserIdChannelIdCompoundUniqueInput = {
    userId: string
    channelId: string
  }

  export type ChannelSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    channelId?: SortOrder
    subscribedAt?: SortOrder
    isActive?: SortOrder
    isFavorite?: SortOrder
    receiveMessages?: SortOrder
  }

  export type ChannelSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    channelId?: SortOrder
    subscribedAt?: SortOrder
    isActive?: SortOrder
    isFavorite?: SortOrder
    receiveMessages?: SortOrder
  }

  export type ChannelSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    channelId?: SortOrder
    subscribedAt?: SortOrder
    isActive?: SortOrder
    isFavorite?: SortOrder
    receiveMessages?: SortOrder
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    actorId?: SortOrder
    action?: SortOrder
    targetUserId?: SortOrder
    targetChannelId?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    actorId?: SortOrder
    action?: SortOrder
    targetUserId?: SortOrder
    targetChannelId?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    actorId?: SortOrder
    action?: SortOrder
    targetUserId?: SortOrder
    targetChannelId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumDeliveryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryStatus | EnumDeliveryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryStatus[]
    notIn?: $Enums.DeliveryStatus[]
    not?: NestedEnumDeliveryStatusFilter<$PrismaModel> | $Enums.DeliveryStatus
  }

  export type EnumDeliveryMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryMethod | EnumDeliveryMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.DeliveryMethod[] | null
    notIn?: $Enums.DeliveryMethod[] | null
    not?: NestedEnumDeliveryMethodNullableFilter<$PrismaModel> | $Enums.DeliveryMethod | null
  }

  export type MessageRelationFilter = {
    is?: MessageWhereInput
    isNot?: MessageWhereInput
  }

  export type MessageDeliveryCountOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    deliveryStatus?: SortOrder
    deliveryMethod?: SortOrder
    deliveredAt?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageDeliveryMaxOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    deliveryStatus?: SortOrder
    deliveryMethod?: SortOrder
    deliveredAt?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageDeliveryMinOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    deliveryStatus?: SortOrder
    deliveryMethod?: SortOrder
    deliveredAt?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumDeliveryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryStatus | EnumDeliveryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryStatus[]
    notIn?: $Enums.DeliveryStatus[]
    not?: NestedEnumDeliveryStatusWithAggregatesFilter<$PrismaModel> | $Enums.DeliveryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeliveryStatusFilter<$PrismaModel>
    _max?: NestedEnumDeliveryStatusFilter<$PrismaModel>
  }

  export type EnumDeliveryMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryMethod | EnumDeliveryMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.DeliveryMethod[] | null
    notIn?: $Enums.DeliveryMethod[] | null
    not?: NestedEnumDeliveryMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.DeliveryMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDeliveryMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumDeliveryMethodNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type InvitationLinkCountOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
    createdBy?: SortOrder
    linkCode?: SortOrder
    expiresAt?: SortOrder
    maxUses?: SortOrder
    currentUses?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type InvitationLinkAvgOrderByAggregateInput = {
    maxUses?: SortOrder
    currentUses?: SortOrder
  }

  export type InvitationLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
    createdBy?: SortOrder
    linkCode?: SortOrder
    expiresAt?: SortOrder
    maxUses?: SortOrder
    currentUses?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type InvitationLinkMinOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
    createdBy?: SortOrder
    linkCode?: SortOrder
    expiresAt?: SortOrder
    maxUses?: SortOrder
    currentUses?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type InvitationLinkSumOrderByAggregateInput = {
    maxUses?: SortOrder
    currentUses?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type QrCodeCountOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
    createdBy?: SortOrder
    qrData?: SortOrder
    expiresAt?: SortOrder
    scanCount?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type QrCodeAvgOrderByAggregateInput = {
    scanCount?: SortOrder
  }

  export type QrCodeMaxOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
    createdBy?: SortOrder
    qrData?: SortOrder
    expiresAt?: SortOrder
    scanCount?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type QrCodeMinOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
    createdBy?: SortOrder
    qrData?: SortOrder
    expiresAt?: SortOrder
    scanCount?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type QrCodeSumOrderByAggregateInput = {
    scanCount?: SortOrder
  }

  export type OrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChannelApproverChannelIdUserIdCompoundUniqueInput = {
    channelId: string
    userId: string
  }

  export type ChannelApproverCountOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
    userId?: SortOrder
    isActive?: SortOrder
    removedAt?: SortOrder
    removedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type ChannelApproverMaxOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
    userId?: SortOrder
    isActive?: SortOrder
    removedAt?: SortOrder
    removedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type ChannelApproverMinOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
    userId?: SortOrder
    isActive?: SortOrder
    removedAt?: SortOrder
    removedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumApprovalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[]
    notIn?: $Enums.ApprovalStatus[]
    not?: NestedEnumApprovalStatusFilter<$PrismaModel> | $Enums.ApprovalStatus
  }

  export type MessageApprovalMessageIdApproverIdCompoundUniqueInput = {
    messageId: string
    approverId: string
  }

  export type MessageApprovalCountOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    approverId?: SortOrder
    status?: SortOrder
    decidedAt?: SortOrder
  }

  export type MessageApprovalMaxOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    approverId?: SortOrder
    status?: SortOrder
    decidedAt?: SortOrder
  }

  export type MessageApprovalMinOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    approverId?: SortOrder
    status?: SortOrder
    decidedAt?: SortOrder
  }

  export type EnumApprovalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[]
    notIn?: $Enums.ApprovalStatus[]
    not?: NestedEnumApprovalStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApprovalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApprovalStatusFilter<$PrismaModel>
    _max?: NestedEnumApprovalStatusFilter<$PrismaModel>
  }

  export type EnumCategoryScopeFilter<$PrismaModel = never> = {
    equals?: $Enums.CategoryScope | EnumCategoryScopeFieldRefInput<$PrismaModel>
    in?: $Enums.CategoryScope[]
    notIn?: $Enums.CategoryScope[]
    not?: NestedEnumCategoryScopeFilter<$PrismaModel> | $Enums.CategoryScope
  }

  export type MessageCategoryChannelIdNameCompoundUniqueInput = {
    channelId: string
    name: string
  }

  export type MessageCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    scope?: SortOrder
    channelId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    scope?: SortOrder
    channelId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    scope?: SortOrder
    channelId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumCategoryScopeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CategoryScope | EnumCategoryScopeFieldRefInput<$PrismaModel>
    in?: $Enums.CategoryScope[]
    notIn?: $Enums.CategoryScope[]
    not?: NestedEnumCategoryScopeWithAggregatesFilter<$PrismaModel> | $Enums.CategoryScope
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCategoryScopeFilter<$PrismaModel>
    _max?: NestedEnumCategoryScopeFilter<$PrismaModel>
  }

  export type EnumAttachmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AttachmentType | EnumAttachmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AttachmentType[]
    notIn?: $Enums.AttachmentType[]
    not?: NestedEnumAttachmentTypeFilter<$PrismaModel> | $Enums.AttachmentType
  }

  export type MessageAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumAttachmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttachmentType | EnumAttachmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AttachmentType[]
    notIn?: $Enums.AttachmentType[]
    not?: NestedEnumAttachmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.AttachmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttachmentTypeFilter<$PrismaModel>
    _max?: NestedEnumAttachmentTypeFilter<$PrismaModel>
  }

  export type MessageRevisionCountOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    editorId?: SortOrder
    previousContent?: SortOrder
    previousCategoryId?: SortOrder
    previousPriority?: SortOrder
    previousIsImmediate?: SortOrder
    previousDeliveryMethod?: SortOrder
    changedAt?: SortOrder
  }

  export type MessageRevisionMaxOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    editorId?: SortOrder
    previousContent?: SortOrder
    previousCategoryId?: SortOrder
    previousPriority?: SortOrder
    previousIsImmediate?: SortOrder
    previousDeliveryMethod?: SortOrder
    changedAt?: SortOrder
  }

  export type MessageRevisionMinOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    editorId?: SortOrder
    previousContent?: SortOrder
    previousCategoryId?: SortOrder
    previousPriority?: SortOrder
    previousIsImmediate?: SortOrder
    previousDeliveryMethod?: SortOrder
    changedAt?: SortOrder
  }

  export type ChannelVerificationDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
    title?: SortOrder
    docUrl?: SortOrder
    issuer?: SortOrder
    issuedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ChannelVerificationDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
    title?: SortOrder
    docUrl?: SortOrder
    issuer?: SortOrder
    issuedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ChannelVerificationDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
    title?: SortOrder
    docUrl?: SortOrder
    issuer?: SortOrder
    issuedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type UserProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    country?: SortOrder
    department?: SortOrder
    city?: SortOrder
    extra?: SortOrder
  }

  export type UserProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    country?: SortOrder
    department?: SortOrder
    city?: SortOrder
  }

  export type UserProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    country?: SortOrder
    department?: SortOrder
    city?: SortOrder
  }

  export type EnumMessagingPlatformFilter<$PrismaModel = never> = {
    equals?: $Enums.MessagingPlatform | EnumMessagingPlatformFieldRefInput<$PrismaModel>
    in?: $Enums.MessagingPlatform[]
    notIn?: $Enums.MessagingPlatform[]
    not?: NestedEnumMessagingPlatformFilter<$PrismaModel> | $Enums.MessagingPlatform
  }

  export type UserMessagingSettingUserIdPlatformCompoundUniqueInput = {
    userId: string
    platform: $Enums.MessagingPlatform
  }

  export type UserMessagingSettingCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    platform?: SortOrder
    handle?: SortOrder
    isEnabled?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMessagingSettingMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    platform?: SortOrder
    handle?: SortOrder
    isEnabled?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMessagingSettingMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    platform?: SortOrder
    handle?: SortOrder
    isEnabled?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumMessagingPlatformWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessagingPlatform | EnumMessagingPlatformFieldRefInput<$PrismaModel>
    in?: $Enums.MessagingPlatform[]
    notIn?: $Enums.MessagingPlatform[]
    not?: NestedEnumMessagingPlatformWithAggregatesFilter<$PrismaModel> | $Enums.MessagingPlatform
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessagingPlatformFilter<$PrismaModel>
    _max?: NestedEnumMessagingPlatformFilter<$PrismaModel>
  }

  export type ChannelCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type ChannelCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type ChannelCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type ChannelCategoryRelationFilter = {
    is?: ChannelCategoryWhereInput
    isNot?: ChannelCategoryWhereInput
  }

  export type ChannelCategoryAssignmentChannelIdCategoryIdCompoundUniqueInput = {
    channelId: string
    categoryId: string
  }

  export type ChannelCategoryAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
    categoryId?: SortOrder
  }

  export type ChannelCategoryAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
    categoryId?: SortOrder
  }

  export type ChannelCategoryAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
    categoryId?: SortOrder
  }

  export type MessageViewCountOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    viewedAt?: SortOrder
  }

  export type MessageViewMaxOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    viewedAt?: SortOrder
  }

  export type MessageViewMinOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    viewedAt?: SortOrder
  }

  export type ChannelVisitCountOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
    userId?: SortOrder
    visitedAt?: SortOrder
  }

  export type ChannelVisitMaxOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
    userId?: SortOrder
    visitedAt?: SortOrder
  }

  export type ChannelVisitMinOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
    userId?: SortOrder
    visitedAt?: SortOrder
  }

  export type FormFieldListRelationFilter = {
    every?: FormFieldWhereInput
    some?: FormFieldWhereInput
    none?: FormFieldWhereInput
  }

  export type FormSubmissionListRelationFilter = {
    every?: FormSubmissionWhereInput
    some?: FormSubmissionWhereInput
    none?: FormSubmissionWhereInput
  }

  export type FormFieldOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FormSubmissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FormCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    headerContent?: SortOrder
    footerContent?: SortOrder
    successMessage?: SortOrder
    isActive?: SortOrder
    isPublished?: SortOrder
    wasPublished?: SortOrder
    isDeleted?: SortOrder
    collectUserInfo?: SortOrder
    expiresAt?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    headerContent?: SortOrder
    footerContent?: SortOrder
    successMessage?: SortOrder
    isActive?: SortOrder
    isPublished?: SortOrder
    wasPublished?: SortOrder
    isDeleted?: SortOrder
    collectUserInfo?: SortOrder
    expiresAt?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    headerContent?: SortOrder
    footerContent?: SortOrder
    successMessage?: SortOrder
    isActive?: SortOrder
    isPublished?: SortOrder
    wasPublished?: SortOrder
    isDeleted?: SortOrder
    collectUserInfo?: SortOrder
    expiresAt?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormRelationFilter = {
    is?: FormWhereInput
    isNot?: FormWhereInput
  }

  export type FormFieldCountOrderByAggregateInput = {
    id?: SortOrder
    formId?: SortOrder
    type?: SortOrder
    label?: SortOrder
    placeholder?: SortOrder
    required?: SortOrder
    isHidden?: SortOrder
    options?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type FormFieldAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type FormFieldMaxOrderByAggregateInput = {
    id?: SortOrder
    formId?: SortOrder
    type?: SortOrder
    label?: SortOrder
    placeholder?: SortOrder
    required?: SortOrder
    isHidden?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type FormFieldMinOrderByAggregateInput = {
    id?: SortOrder
    formId?: SortOrder
    type?: SortOrder
    label?: SortOrder
    placeholder?: SortOrder
    required?: SortOrder
    isHidden?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type FormFieldSumOrderByAggregateInput = {
    order?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type FormSubmissionCountOrderByAggregateInput = {
    id?: SortOrder
    formId?: SortOrder
    data?: SortOrder
    ipAddress?: SortOrder
    country?: SortOrder
    city?: SortOrder
    userAgent?: SortOrder
    deviceInfo?: SortOrder
    createdAt?: SortOrder
  }

  export type FormSubmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    formId?: SortOrder
    ipAddress?: SortOrder
    country?: SortOrder
    city?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type FormSubmissionMinOrderByAggregateInput = {
    id?: SortOrder
    formId?: SortOrder
    ipAddress?: SortOrder
    country?: SortOrder
    city?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumEventStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EventStatus | EnumEventStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EventStatus[]
    notIn?: $Enums.EventStatus[]
    not?: NestedEnumEventStatusFilter<$PrismaModel> | $Enums.EventStatus
  }

  export type EventZoneListRelationFilter = {
    every?: EventZoneWhereInput
    some?: EventZoneWhereInput
    none?: EventZoneWhereInput
  }

  export type EventSeatListRelationFilter = {
    every?: EventSeatWhereInput
    some?: EventSeatWhereInput
    none?: EventSeatWhereInput
  }

  export type TicketListRelationFilter = {
    every?: TicketWhereInput
    some?: TicketWhereInput
    none?: TicketWhereInput
  }

  export type EventZoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventSeatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    location?: SortOrder
    imageUrl?: SortOrder
    status?: SortOrder
    categories?: SortOrder
    paymentInfo?: SortOrder
    organizerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    location?: SortOrder
    imageUrl?: SortOrder
    status?: SortOrder
    paymentInfo?: SortOrder
    organizerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    location?: SortOrder
    imageUrl?: SortOrder
    status?: SortOrder
    paymentInfo?: SortOrder
    organizerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEventStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventStatus | EnumEventStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EventStatus[]
    notIn?: $Enums.EventStatus[]
    not?: NestedEnumEventStatusWithAggregatesFilter<$PrismaModel> | $Enums.EventStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventStatusFilter<$PrismaModel>
    _max?: NestedEnumEventStatusFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumZoneTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ZoneType | EnumZoneTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ZoneType[]
    notIn?: $Enums.ZoneType[]
    not?: NestedEnumZoneTypeFilter<$PrismaModel> | $Enums.ZoneType
  }

  export type EventRelationFilter = {
    is?: EventWhereInput
    isNot?: EventWhereInput
  }

  export type EventZoneCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    name?: SortOrder
    color?: SortOrder
    price?: SortOrder
    rows?: SortOrder
    cols?: SortOrder
    capacity?: SortOrder
    type?: SortOrder
    layout?: SortOrder
    seatGap?: SortOrder
    startNumber?: SortOrder
    numberingDirection?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventZoneAvgOrderByAggregateInput = {
    price?: SortOrder
    rows?: SortOrder
    cols?: SortOrder
    capacity?: SortOrder
    seatGap?: SortOrder
    startNumber?: SortOrder
  }

  export type EventZoneMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    name?: SortOrder
    color?: SortOrder
    price?: SortOrder
    rows?: SortOrder
    cols?: SortOrder
    capacity?: SortOrder
    type?: SortOrder
    seatGap?: SortOrder
    startNumber?: SortOrder
    numberingDirection?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventZoneMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    name?: SortOrder
    color?: SortOrder
    price?: SortOrder
    rows?: SortOrder
    cols?: SortOrder
    capacity?: SortOrder
    type?: SortOrder
    seatGap?: SortOrder
    startNumber?: SortOrder
    numberingDirection?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventZoneSumOrderByAggregateInput = {
    price?: SortOrder
    rows?: SortOrder
    cols?: SortOrder
    capacity?: SortOrder
    seatGap?: SortOrder
    startNumber?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumZoneTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ZoneType | EnumZoneTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ZoneType[]
    notIn?: $Enums.ZoneType[]
    not?: NestedEnumZoneTypeWithAggregatesFilter<$PrismaModel> | $Enums.ZoneType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumZoneTypeFilter<$PrismaModel>
    _max?: NestedEnumZoneTypeFilter<$PrismaModel>
  }

  export type EnumSeatStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SeatStatus | EnumSeatStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SeatStatus[]
    notIn?: $Enums.SeatStatus[]
    not?: NestedEnumSeatStatusFilter<$PrismaModel> | $Enums.SeatStatus
  }

  export type EnumSeatTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SeatType | EnumSeatTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SeatType[]
    notIn?: $Enums.SeatType[]
    not?: NestedEnumSeatTypeFilter<$PrismaModel> | $Enums.SeatType
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EventZoneRelationFilter = {
    is?: EventZoneWhereInput
    isNot?: EventZoneWhereInput
  }

  export type EventSeatCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    zoneId?: SortOrder
    rowLabel?: SortOrder
    colLabel?: SortOrder
    status?: SortOrder
    type?: SortOrder
    price?: SortOrder
    x?: SortOrder
    y?: SortOrder
    holderName?: SortOrder
    ticketCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventSeatAvgOrderByAggregateInput = {
    price?: SortOrder
    x?: SortOrder
    y?: SortOrder
  }

  export type EventSeatMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    zoneId?: SortOrder
    rowLabel?: SortOrder
    colLabel?: SortOrder
    status?: SortOrder
    type?: SortOrder
    price?: SortOrder
    x?: SortOrder
    y?: SortOrder
    holderName?: SortOrder
    ticketCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventSeatMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    zoneId?: SortOrder
    rowLabel?: SortOrder
    colLabel?: SortOrder
    status?: SortOrder
    type?: SortOrder
    price?: SortOrder
    x?: SortOrder
    y?: SortOrder
    holderName?: SortOrder
    ticketCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventSeatSumOrderByAggregateInput = {
    price?: SortOrder
    x?: SortOrder
    y?: SortOrder
  }

  export type EnumSeatStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SeatStatus | EnumSeatStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SeatStatus[]
    notIn?: $Enums.SeatStatus[]
    not?: NestedEnumSeatStatusWithAggregatesFilter<$PrismaModel> | $Enums.SeatStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSeatStatusFilter<$PrismaModel>
    _max?: NestedEnumSeatStatusFilter<$PrismaModel>
  }

  export type EnumSeatTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SeatType | EnumSeatTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SeatType[]
    notIn?: $Enums.SeatType[]
    not?: NestedEnumSeatTypeWithAggregatesFilter<$PrismaModel> | $Enums.SeatType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSeatTypeFilter<$PrismaModel>
    _max?: NestedEnumSeatTypeFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumTicketStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[]
    notIn?: $Enums.TicketStatus[]
    not?: NestedEnumTicketStatusFilter<$PrismaModel> | $Enums.TicketStatus
  }

  export type EventSeatNullableRelationFilter = {
    is?: EventSeatWhereInput | null
    isNot?: EventSeatWhereInput | null
  }

  export type TicketCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    zoneId?: SortOrder
    seatId?: SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrder
    price?: SortOrder
    status?: SortOrder
    purchaseDate?: SortOrder
    qrCode?: SortOrder
  }

  export type TicketAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type TicketMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    zoneId?: SortOrder
    seatId?: SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrder
    price?: SortOrder
    status?: SortOrder
    purchaseDate?: SortOrder
    qrCode?: SortOrder
  }

  export type TicketMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    zoneId?: SortOrder
    seatId?: SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrder
    price?: SortOrder
    status?: SortOrder
    purchaseDate?: SortOrder
    qrCode?: SortOrder
  }

  export type TicketSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type EnumTicketStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[]
    notIn?: $Enums.TicketStatus[]
    not?: NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel> | $Enums.TicketStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketStatusFilter<$PrismaModel>
    _max?: NestedEnumTicketStatusFilter<$PrismaModel>
  }

  export type ChannelCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ChannelCreateWithoutOwnerInput, ChannelUncheckedCreateWithoutOwnerInput> | ChannelCreateWithoutOwnerInput[] | ChannelUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutOwnerInput | ChannelCreateOrConnectWithoutOwnerInput[]
    createMany?: ChannelCreateManyOwnerInputEnvelope
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutOverrideSetterInput = {
    create?: XOR<MessageCreateWithoutOverrideSetterInput, MessageUncheckedCreateWithoutOverrideSetterInput> | MessageCreateWithoutOverrideSetterInput[] | MessageUncheckedCreateWithoutOverrideSetterInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutOverrideSetterInput | MessageCreateOrConnectWithoutOverrideSetterInput[]
    createMany?: MessageCreateManyOverrideSetterInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ChannelSubscriptionCreateNestedManyWithoutUserInput = {
    create?: XOR<ChannelSubscriptionCreateWithoutUserInput, ChannelSubscriptionUncheckedCreateWithoutUserInput> | ChannelSubscriptionCreateWithoutUserInput[] | ChannelSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChannelSubscriptionCreateOrConnectWithoutUserInput | ChannelSubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: ChannelSubscriptionCreateManyUserInputEnvelope
    connect?: ChannelSubscriptionWhereUniqueInput | ChannelSubscriptionWhereUniqueInput[]
  }

  export type InvitationLinkCreateNestedManyWithoutCreatorInput = {
    create?: XOR<InvitationLinkCreateWithoutCreatorInput, InvitationLinkUncheckedCreateWithoutCreatorInput> | InvitationLinkCreateWithoutCreatorInput[] | InvitationLinkUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: InvitationLinkCreateOrConnectWithoutCreatorInput | InvitationLinkCreateOrConnectWithoutCreatorInput[]
    createMany?: InvitationLinkCreateManyCreatorInputEnvelope
    connect?: InvitationLinkWhereUniqueInput | InvitationLinkWhereUniqueInput[]
  }

  export type QrCodeCreateNestedManyWithoutCreatorInput = {
    create?: XOR<QrCodeCreateWithoutCreatorInput, QrCodeUncheckedCreateWithoutCreatorInput> | QrCodeCreateWithoutCreatorInput[] | QrCodeUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: QrCodeCreateOrConnectWithoutCreatorInput | QrCodeCreateOrConnectWithoutCreatorInput[]
    createMany?: QrCodeCreateManyCreatorInputEnvelope
    connect?: QrCodeWhereUniqueInput | QrCodeWhereUniqueInput[]
  }

  export type MessageDeliveryCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageDeliveryCreateWithoutUserInput, MessageDeliveryUncheckedCreateWithoutUserInput> | MessageDeliveryCreateWithoutUserInput[] | MessageDeliveryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageDeliveryCreateOrConnectWithoutUserInput | MessageDeliveryCreateOrConnectWithoutUserInput[]
    createMany?: MessageDeliveryCreateManyUserInputEnvelope
    connect?: MessageDeliveryWhereUniqueInput | MessageDeliveryWhereUniqueInput[]
  }

  export type MessageApprovalCreateNestedManyWithoutApproverInput = {
    create?: XOR<MessageApprovalCreateWithoutApproverInput, MessageApprovalUncheckedCreateWithoutApproverInput> | MessageApprovalCreateWithoutApproverInput[] | MessageApprovalUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: MessageApprovalCreateOrConnectWithoutApproverInput | MessageApprovalCreateOrConnectWithoutApproverInput[]
    createMany?: MessageApprovalCreateManyApproverInputEnvelope
    connect?: MessageApprovalWhereUniqueInput | MessageApprovalWhereUniqueInput[]
  }

  export type MessageRevisionCreateNestedManyWithoutEditorInput = {
    create?: XOR<MessageRevisionCreateWithoutEditorInput, MessageRevisionUncheckedCreateWithoutEditorInput> | MessageRevisionCreateWithoutEditorInput[] | MessageRevisionUncheckedCreateWithoutEditorInput[]
    connectOrCreate?: MessageRevisionCreateOrConnectWithoutEditorInput | MessageRevisionCreateOrConnectWithoutEditorInput[]
    createMany?: MessageRevisionCreateManyEditorInputEnvelope
    connect?: MessageRevisionWhereUniqueInput | MessageRevisionWhereUniqueInput[]
  }

  export type UserProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    connect?: UserProfileWhereUniqueInput
  }

  export type UserMessagingSettingCreateNestedManyWithoutUserInput = {
    create?: XOR<UserMessagingSettingCreateWithoutUserInput, UserMessagingSettingUncheckedCreateWithoutUserInput> | UserMessagingSettingCreateWithoutUserInput[] | UserMessagingSettingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserMessagingSettingCreateOrConnectWithoutUserInput | UserMessagingSettingCreateOrConnectWithoutUserInput[]
    createMany?: UserMessagingSettingCreateManyUserInputEnvelope
    connect?: UserMessagingSettingWhereUniqueInput | UserMessagingSettingWhereUniqueInput[]
  }

  export type ChannelApproverCreateNestedManyWithoutUserInput = {
    create?: XOR<ChannelApproverCreateWithoutUserInput, ChannelApproverUncheckedCreateWithoutUserInput> | ChannelApproverCreateWithoutUserInput[] | ChannelApproverUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChannelApproverCreateOrConnectWithoutUserInput | ChannelApproverCreateOrConnectWithoutUserInput[]
    createMany?: ChannelApproverCreateManyUserInputEnvelope
    connect?: ChannelApproverWhereUniqueInput | ChannelApproverWhereUniqueInput[]
  }

  export type MessageCategoryCreateNestedManyWithoutCreatorInput = {
    create?: XOR<MessageCategoryCreateWithoutCreatorInput, MessageCategoryUncheckedCreateWithoutCreatorInput> | MessageCategoryCreateWithoutCreatorInput[] | MessageCategoryUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: MessageCategoryCreateOrConnectWithoutCreatorInput | MessageCategoryCreateOrConnectWithoutCreatorInput[]
    createMany?: MessageCategoryCreateManyCreatorInputEnvelope
    connect?: MessageCategoryWhereUniqueInput | MessageCategoryWhereUniqueInput[]
  }

  export type MessageViewCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageViewCreateWithoutUserInput, MessageViewUncheckedCreateWithoutUserInput> | MessageViewCreateWithoutUserInput[] | MessageViewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageViewCreateOrConnectWithoutUserInput | MessageViewCreateOrConnectWithoutUserInput[]
    createMany?: MessageViewCreateManyUserInputEnvelope
    connect?: MessageViewWhereUniqueInput | MessageViewWhereUniqueInput[]
  }

  export type ChannelVisitCreateNestedManyWithoutUserInput = {
    create?: XOR<ChannelVisitCreateWithoutUserInput, ChannelVisitUncheckedCreateWithoutUserInput> | ChannelVisitCreateWithoutUserInput[] | ChannelVisitUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChannelVisitCreateOrConnectWithoutUserInput | ChannelVisitCreateOrConnectWithoutUserInput[]
    createMany?: ChannelVisitCreateManyUserInputEnvelope
    connect?: ChannelVisitWhereUniqueInput | ChannelVisitWhereUniqueInput[]
  }

  export type FormCreateNestedManyWithoutUserInput = {
    create?: XOR<FormCreateWithoutUserInput, FormUncheckedCreateWithoutUserInput> | FormCreateWithoutUserInput[] | FormUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FormCreateOrConnectWithoutUserInput | FormCreateOrConnectWithoutUserInput[]
    createMany?: FormCreateManyUserInputEnvelope
    connect?: FormWhereUniqueInput | FormWhereUniqueInput[]
  }

  export type EventCreateNestedManyWithoutOrganizerInput = {
    create?: XOR<EventCreateWithoutOrganizerInput, EventUncheckedCreateWithoutOrganizerInput> | EventCreateWithoutOrganizerInput[] | EventUncheckedCreateWithoutOrganizerInput[]
    connectOrCreate?: EventCreateOrConnectWithoutOrganizerInput | EventCreateOrConnectWithoutOrganizerInput[]
    createMany?: EventCreateManyOrganizerInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type ChannelUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ChannelCreateWithoutOwnerInput, ChannelUncheckedCreateWithoutOwnerInput> | ChannelCreateWithoutOwnerInput[] | ChannelUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutOwnerInput | ChannelCreateOrConnectWithoutOwnerInput[]
    createMany?: ChannelCreateManyOwnerInputEnvelope
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutOverrideSetterInput = {
    create?: XOR<MessageCreateWithoutOverrideSetterInput, MessageUncheckedCreateWithoutOverrideSetterInput> | MessageCreateWithoutOverrideSetterInput[] | MessageUncheckedCreateWithoutOverrideSetterInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutOverrideSetterInput | MessageCreateOrConnectWithoutOverrideSetterInput[]
    createMany?: MessageCreateManyOverrideSetterInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ChannelSubscriptionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ChannelSubscriptionCreateWithoutUserInput, ChannelSubscriptionUncheckedCreateWithoutUserInput> | ChannelSubscriptionCreateWithoutUserInput[] | ChannelSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChannelSubscriptionCreateOrConnectWithoutUserInput | ChannelSubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: ChannelSubscriptionCreateManyUserInputEnvelope
    connect?: ChannelSubscriptionWhereUniqueInput | ChannelSubscriptionWhereUniqueInput[]
  }

  export type InvitationLinkUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<InvitationLinkCreateWithoutCreatorInput, InvitationLinkUncheckedCreateWithoutCreatorInput> | InvitationLinkCreateWithoutCreatorInput[] | InvitationLinkUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: InvitationLinkCreateOrConnectWithoutCreatorInput | InvitationLinkCreateOrConnectWithoutCreatorInput[]
    createMany?: InvitationLinkCreateManyCreatorInputEnvelope
    connect?: InvitationLinkWhereUniqueInput | InvitationLinkWhereUniqueInput[]
  }

  export type QrCodeUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<QrCodeCreateWithoutCreatorInput, QrCodeUncheckedCreateWithoutCreatorInput> | QrCodeCreateWithoutCreatorInput[] | QrCodeUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: QrCodeCreateOrConnectWithoutCreatorInput | QrCodeCreateOrConnectWithoutCreatorInput[]
    createMany?: QrCodeCreateManyCreatorInputEnvelope
    connect?: QrCodeWhereUniqueInput | QrCodeWhereUniqueInput[]
  }

  export type MessageDeliveryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageDeliveryCreateWithoutUserInput, MessageDeliveryUncheckedCreateWithoutUserInput> | MessageDeliveryCreateWithoutUserInput[] | MessageDeliveryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageDeliveryCreateOrConnectWithoutUserInput | MessageDeliveryCreateOrConnectWithoutUserInput[]
    createMany?: MessageDeliveryCreateManyUserInputEnvelope
    connect?: MessageDeliveryWhereUniqueInput | MessageDeliveryWhereUniqueInput[]
  }

  export type MessageApprovalUncheckedCreateNestedManyWithoutApproverInput = {
    create?: XOR<MessageApprovalCreateWithoutApproverInput, MessageApprovalUncheckedCreateWithoutApproverInput> | MessageApprovalCreateWithoutApproverInput[] | MessageApprovalUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: MessageApprovalCreateOrConnectWithoutApproverInput | MessageApprovalCreateOrConnectWithoutApproverInput[]
    createMany?: MessageApprovalCreateManyApproverInputEnvelope
    connect?: MessageApprovalWhereUniqueInput | MessageApprovalWhereUniqueInput[]
  }

  export type MessageRevisionUncheckedCreateNestedManyWithoutEditorInput = {
    create?: XOR<MessageRevisionCreateWithoutEditorInput, MessageRevisionUncheckedCreateWithoutEditorInput> | MessageRevisionCreateWithoutEditorInput[] | MessageRevisionUncheckedCreateWithoutEditorInput[]
    connectOrCreate?: MessageRevisionCreateOrConnectWithoutEditorInput | MessageRevisionCreateOrConnectWithoutEditorInput[]
    createMany?: MessageRevisionCreateManyEditorInputEnvelope
    connect?: MessageRevisionWhereUniqueInput | MessageRevisionWhereUniqueInput[]
  }

  export type UserProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    connect?: UserProfileWhereUniqueInput
  }

  export type UserMessagingSettingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserMessagingSettingCreateWithoutUserInput, UserMessagingSettingUncheckedCreateWithoutUserInput> | UserMessagingSettingCreateWithoutUserInput[] | UserMessagingSettingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserMessagingSettingCreateOrConnectWithoutUserInput | UserMessagingSettingCreateOrConnectWithoutUserInput[]
    createMany?: UserMessagingSettingCreateManyUserInputEnvelope
    connect?: UserMessagingSettingWhereUniqueInput | UserMessagingSettingWhereUniqueInput[]
  }

  export type ChannelApproverUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ChannelApproverCreateWithoutUserInput, ChannelApproverUncheckedCreateWithoutUserInput> | ChannelApproverCreateWithoutUserInput[] | ChannelApproverUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChannelApproverCreateOrConnectWithoutUserInput | ChannelApproverCreateOrConnectWithoutUserInput[]
    createMany?: ChannelApproverCreateManyUserInputEnvelope
    connect?: ChannelApproverWhereUniqueInput | ChannelApproverWhereUniqueInput[]
  }

  export type MessageCategoryUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<MessageCategoryCreateWithoutCreatorInput, MessageCategoryUncheckedCreateWithoutCreatorInput> | MessageCategoryCreateWithoutCreatorInput[] | MessageCategoryUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: MessageCategoryCreateOrConnectWithoutCreatorInput | MessageCategoryCreateOrConnectWithoutCreatorInput[]
    createMany?: MessageCategoryCreateManyCreatorInputEnvelope
    connect?: MessageCategoryWhereUniqueInput | MessageCategoryWhereUniqueInput[]
  }

  export type MessageViewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageViewCreateWithoutUserInput, MessageViewUncheckedCreateWithoutUserInput> | MessageViewCreateWithoutUserInput[] | MessageViewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageViewCreateOrConnectWithoutUserInput | MessageViewCreateOrConnectWithoutUserInput[]
    createMany?: MessageViewCreateManyUserInputEnvelope
    connect?: MessageViewWhereUniqueInput | MessageViewWhereUniqueInput[]
  }

  export type ChannelVisitUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ChannelVisitCreateWithoutUserInput, ChannelVisitUncheckedCreateWithoutUserInput> | ChannelVisitCreateWithoutUserInput[] | ChannelVisitUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChannelVisitCreateOrConnectWithoutUserInput | ChannelVisitCreateOrConnectWithoutUserInput[]
    createMany?: ChannelVisitCreateManyUserInputEnvelope
    connect?: ChannelVisitWhereUniqueInput | ChannelVisitWhereUniqueInput[]
  }

  export type FormUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FormCreateWithoutUserInput, FormUncheckedCreateWithoutUserInput> | FormCreateWithoutUserInput[] | FormUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FormCreateOrConnectWithoutUserInput | FormCreateOrConnectWithoutUserInput[]
    createMany?: FormCreateManyUserInputEnvelope
    connect?: FormWhereUniqueInput | FormWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutOrganizerInput = {
    create?: XOR<EventCreateWithoutOrganizerInput, EventUncheckedCreateWithoutOrganizerInput> | EventCreateWithoutOrganizerInput[] | EventUncheckedCreateWithoutOrganizerInput[]
    connectOrCreate?: EventCreateOrConnectWithoutOrganizerInput | EventCreateOrConnectWithoutOrganizerInput[]
    createMany?: EventCreateManyOrganizerInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ChannelUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ChannelCreateWithoutOwnerInput, ChannelUncheckedCreateWithoutOwnerInput> | ChannelCreateWithoutOwnerInput[] | ChannelUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutOwnerInput | ChannelCreateOrConnectWithoutOwnerInput[]
    upsert?: ChannelUpsertWithWhereUniqueWithoutOwnerInput | ChannelUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ChannelCreateManyOwnerInputEnvelope
    set?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    disconnect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    delete?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    update?: ChannelUpdateWithWhereUniqueWithoutOwnerInput | ChannelUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ChannelUpdateManyWithWhereWithoutOwnerInput | ChannelUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ChannelScalarWhereInput | ChannelScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutOverrideSetterNestedInput = {
    create?: XOR<MessageCreateWithoutOverrideSetterInput, MessageUncheckedCreateWithoutOverrideSetterInput> | MessageCreateWithoutOverrideSetterInput[] | MessageUncheckedCreateWithoutOverrideSetterInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutOverrideSetterInput | MessageCreateOrConnectWithoutOverrideSetterInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutOverrideSetterInput | MessageUpsertWithWhereUniqueWithoutOverrideSetterInput[]
    createMany?: MessageCreateManyOverrideSetterInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutOverrideSetterInput | MessageUpdateWithWhereUniqueWithoutOverrideSetterInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutOverrideSetterInput | MessageUpdateManyWithWhereWithoutOverrideSetterInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ChannelSubscriptionUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChannelSubscriptionCreateWithoutUserInput, ChannelSubscriptionUncheckedCreateWithoutUserInput> | ChannelSubscriptionCreateWithoutUserInput[] | ChannelSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChannelSubscriptionCreateOrConnectWithoutUserInput | ChannelSubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: ChannelSubscriptionUpsertWithWhereUniqueWithoutUserInput | ChannelSubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChannelSubscriptionCreateManyUserInputEnvelope
    set?: ChannelSubscriptionWhereUniqueInput | ChannelSubscriptionWhereUniqueInput[]
    disconnect?: ChannelSubscriptionWhereUniqueInput | ChannelSubscriptionWhereUniqueInput[]
    delete?: ChannelSubscriptionWhereUniqueInput | ChannelSubscriptionWhereUniqueInput[]
    connect?: ChannelSubscriptionWhereUniqueInput | ChannelSubscriptionWhereUniqueInput[]
    update?: ChannelSubscriptionUpdateWithWhereUniqueWithoutUserInput | ChannelSubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChannelSubscriptionUpdateManyWithWhereWithoutUserInput | ChannelSubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChannelSubscriptionScalarWhereInput | ChannelSubscriptionScalarWhereInput[]
  }

  export type InvitationLinkUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<InvitationLinkCreateWithoutCreatorInput, InvitationLinkUncheckedCreateWithoutCreatorInput> | InvitationLinkCreateWithoutCreatorInput[] | InvitationLinkUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: InvitationLinkCreateOrConnectWithoutCreatorInput | InvitationLinkCreateOrConnectWithoutCreatorInput[]
    upsert?: InvitationLinkUpsertWithWhereUniqueWithoutCreatorInput | InvitationLinkUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: InvitationLinkCreateManyCreatorInputEnvelope
    set?: InvitationLinkWhereUniqueInput | InvitationLinkWhereUniqueInput[]
    disconnect?: InvitationLinkWhereUniqueInput | InvitationLinkWhereUniqueInput[]
    delete?: InvitationLinkWhereUniqueInput | InvitationLinkWhereUniqueInput[]
    connect?: InvitationLinkWhereUniqueInput | InvitationLinkWhereUniqueInput[]
    update?: InvitationLinkUpdateWithWhereUniqueWithoutCreatorInput | InvitationLinkUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: InvitationLinkUpdateManyWithWhereWithoutCreatorInput | InvitationLinkUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: InvitationLinkScalarWhereInput | InvitationLinkScalarWhereInput[]
  }

  export type QrCodeUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<QrCodeCreateWithoutCreatorInput, QrCodeUncheckedCreateWithoutCreatorInput> | QrCodeCreateWithoutCreatorInput[] | QrCodeUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: QrCodeCreateOrConnectWithoutCreatorInput | QrCodeCreateOrConnectWithoutCreatorInput[]
    upsert?: QrCodeUpsertWithWhereUniqueWithoutCreatorInput | QrCodeUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: QrCodeCreateManyCreatorInputEnvelope
    set?: QrCodeWhereUniqueInput | QrCodeWhereUniqueInput[]
    disconnect?: QrCodeWhereUniqueInput | QrCodeWhereUniqueInput[]
    delete?: QrCodeWhereUniqueInput | QrCodeWhereUniqueInput[]
    connect?: QrCodeWhereUniqueInput | QrCodeWhereUniqueInput[]
    update?: QrCodeUpdateWithWhereUniqueWithoutCreatorInput | QrCodeUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: QrCodeUpdateManyWithWhereWithoutCreatorInput | QrCodeUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: QrCodeScalarWhereInput | QrCodeScalarWhereInput[]
  }

  export type MessageDeliveryUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageDeliveryCreateWithoutUserInput, MessageDeliveryUncheckedCreateWithoutUserInput> | MessageDeliveryCreateWithoutUserInput[] | MessageDeliveryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageDeliveryCreateOrConnectWithoutUserInput | MessageDeliveryCreateOrConnectWithoutUserInput[]
    upsert?: MessageDeliveryUpsertWithWhereUniqueWithoutUserInput | MessageDeliveryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageDeliveryCreateManyUserInputEnvelope
    set?: MessageDeliveryWhereUniqueInput | MessageDeliveryWhereUniqueInput[]
    disconnect?: MessageDeliveryWhereUniqueInput | MessageDeliveryWhereUniqueInput[]
    delete?: MessageDeliveryWhereUniqueInput | MessageDeliveryWhereUniqueInput[]
    connect?: MessageDeliveryWhereUniqueInput | MessageDeliveryWhereUniqueInput[]
    update?: MessageDeliveryUpdateWithWhereUniqueWithoutUserInput | MessageDeliveryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageDeliveryUpdateManyWithWhereWithoutUserInput | MessageDeliveryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageDeliveryScalarWhereInput | MessageDeliveryScalarWhereInput[]
  }

  export type MessageApprovalUpdateManyWithoutApproverNestedInput = {
    create?: XOR<MessageApprovalCreateWithoutApproverInput, MessageApprovalUncheckedCreateWithoutApproverInput> | MessageApprovalCreateWithoutApproverInput[] | MessageApprovalUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: MessageApprovalCreateOrConnectWithoutApproverInput | MessageApprovalCreateOrConnectWithoutApproverInput[]
    upsert?: MessageApprovalUpsertWithWhereUniqueWithoutApproverInput | MessageApprovalUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: MessageApprovalCreateManyApproverInputEnvelope
    set?: MessageApprovalWhereUniqueInput | MessageApprovalWhereUniqueInput[]
    disconnect?: MessageApprovalWhereUniqueInput | MessageApprovalWhereUniqueInput[]
    delete?: MessageApprovalWhereUniqueInput | MessageApprovalWhereUniqueInput[]
    connect?: MessageApprovalWhereUniqueInput | MessageApprovalWhereUniqueInput[]
    update?: MessageApprovalUpdateWithWhereUniqueWithoutApproverInput | MessageApprovalUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: MessageApprovalUpdateManyWithWhereWithoutApproverInput | MessageApprovalUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: MessageApprovalScalarWhereInput | MessageApprovalScalarWhereInput[]
  }

  export type MessageRevisionUpdateManyWithoutEditorNestedInput = {
    create?: XOR<MessageRevisionCreateWithoutEditorInput, MessageRevisionUncheckedCreateWithoutEditorInput> | MessageRevisionCreateWithoutEditorInput[] | MessageRevisionUncheckedCreateWithoutEditorInput[]
    connectOrCreate?: MessageRevisionCreateOrConnectWithoutEditorInput | MessageRevisionCreateOrConnectWithoutEditorInput[]
    upsert?: MessageRevisionUpsertWithWhereUniqueWithoutEditorInput | MessageRevisionUpsertWithWhereUniqueWithoutEditorInput[]
    createMany?: MessageRevisionCreateManyEditorInputEnvelope
    set?: MessageRevisionWhereUniqueInput | MessageRevisionWhereUniqueInput[]
    disconnect?: MessageRevisionWhereUniqueInput | MessageRevisionWhereUniqueInput[]
    delete?: MessageRevisionWhereUniqueInput | MessageRevisionWhereUniqueInput[]
    connect?: MessageRevisionWhereUniqueInput | MessageRevisionWhereUniqueInput[]
    update?: MessageRevisionUpdateWithWhereUniqueWithoutEditorInput | MessageRevisionUpdateWithWhereUniqueWithoutEditorInput[]
    updateMany?: MessageRevisionUpdateManyWithWhereWithoutEditorInput | MessageRevisionUpdateManyWithWhereWithoutEditorInput[]
    deleteMany?: MessageRevisionScalarWhereInput | MessageRevisionScalarWhereInput[]
  }

  export type UserProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    upsert?: UserProfileUpsertWithoutUserInput
    disconnect?: UserProfileWhereInput | boolean
    delete?: UserProfileWhereInput | boolean
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutUserInput, UserProfileUpdateWithoutUserInput>, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserMessagingSettingUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserMessagingSettingCreateWithoutUserInput, UserMessagingSettingUncheckedCreateWithoutUserInput> | UserMessagingSettingCreateWithoutUserInput[] | UserMessagingSettingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserMessagingSettingCreateOrConnectWithoutUserInput | UserMessagingSettingCreateOrConnectWithoutUserInput[]
    upsert?: UserMessagingSettingUpsertWithWhereUniqueWithoutUserInput | UserMessagingSettingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserMessagingSettingCreateManyUserInputEnvelope
    set?: UserMessagingSettingWhereUniqueInput | UserMessagingSettingWhereUniqueInput[]
    disconnect?: UserMessagingSettingWhereUniqueInput | UserMessagingSettingWhereUniqueInput[]
    delete?: UserMessagingSettingWhereUniqueInput | UserMessagingSettingWhereUniqueInput[]
    connect?: UserMessagingSettingWhereUniqueInput | UserMessagingSettingWhereUniqueInput[]
    update?: UserMessagingSettingUpdateWithWhereUniqueWithoutUserInput | UserMessagingSettingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserMessagingSettingUpdateManyWithWhereWithoutUserInput | UserMessagingSettingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserMessagingSettingScalarWhereInput | UserMessagingSettingScalarWhereInput[]
  }

  export type ChannelApproverUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChannelApproverCreateWithoutUserInput, ChannelApproverUncheckedCreateWithoutUserInput> | ChannelApproverCreateWithoutUserInput[] | ChannelApproverUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChannelApproverCreateOrConnectWithoutUserInput | ChannelApproverCreateOrConnectWithoutUserInput[]
    upsert?: ChannelApproverUpsertWithWhereUniqueWithoutUserInput | ChannelApproverUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChannelApproverCreateManyUserInputEnvelope
    set?: ChannelApproverWhereUniqueInput | ChannelApproverWhereUniqueInput[]
    disconnect?: ChannelApproverWhereUniqueInput | ChannelApproverWhereUniqueInput[]
    delete?: ChannelApproverWhereUniqueInput | ChannelApproverWhereUniqueInput[]
    connect?: ChannelApproverWhereUniqueInput | ChannelApproverWhereUniqueInput[]
    update?: ChannelApproverUpdateWithWhereUniqueWithoutUserInput | ChannelApproverUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChannelApproverUpdateManyWithWhereWithoutUserInput | ChannelApproverUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChannelApproverScalarWhereInput | ChannelApproverScalarWhereInput[]
  }

  export type MessageCategoryUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<MessageCategoryCreateWithoutCreatorInput, MessageCategoryUncheckedCreateWithoutCreatorInput> | MessageCategoryCreateWithoutCreatorInput[] | MessageCategoryUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: MessageCategoryCreateOrConnectWithoutCreatorInput | MessageCategoryCreateOrConnectWithoutCreatorInput[]
    upsert?: MessageCategoryUpsertWithWhereUniqueWithoutCreatorInput | MessageCategoryUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: MessageCategoryCreateManyCreatorInputEnvelope
    set?: MessageCategoryWhereUniqueInput | MessageCategoryWhereUniqueInput[]
    disconnect?: MessageCategoryWhereUniqueInput | MessageCategoryWhereUniqueInput[]
    delete?: MessageCategoryWhereUniqueInput | MessageCategoryWhereUniqueInput[]
    connect?: MessageCategoryWhereUniqueInput | MessageCategoryWhereUniqueInput[]
    update?: MessageCategoryUpdateWithWhereUniqueWithoutCreatorInput | MessageCategoryUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: MessageCategoryUpdateManyWithWhereWithoutCreatorInput | MessageCategoryUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: MessageCategoryScalarWhereInput | MessageCategoryScalarWhereInput[]
  }

  export type MessageViewUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageViewCreateWithoutUserInput, MessageViewUncheckedCreateWithoutUserInput> | MessageViewCreateWithoutUserInput[] | MessageViewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageViewCreateOrConnectWithoutUserInput | MessageViewCreateOrConnectWithoutUserInput[]
    upsert?: MessageViewUpsertWithWhereUniqueWithoutUserInput | MessageViewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageViewCreateManyUserInputEnvelope
    set?: MessageViewWhereUniqueInput | MessageViewWhereUniqueInput[]
    disconnect?: MessageViewWhereUniqueInput | MessageViewWhereUniqueInput[]
    delete?: MessageViewWhereUniqueInput | MessageViewWhereUniqueInput[]
    connect?: MessageViewWhereUniqueInput | MessageViewWhereUniqueInput[]
    update?: MessageViewUpdateWithWhereUniqueWithoutUserInput | MessageViewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageViewUpdateManyWithWhereWithoutUserInput | MessageViewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageViewScalarWhereInput | MessageViewScalarWhereInput[]
  }

  export type ChannelVisitUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChannelVisitCreateWithoutUserInput, ChannelVisitUncheckedCreateWithoutUserInput> | ChannelVisitCreateWithoutUserInput[] | ChannelVisitUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChannelVisitCreateOrConnectWithoutUserInput | ChannelVisitCreateOrConnectWithoutUserInput[]
    upsert?: ChannelVisitUpsertWithWhereUniqueWithoutUserInput | ChannelVisitUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChannelVisitCreateManyUserInputEnvelope
    set?: ChannelVisitWhereUniqueInput | ChannelVisitWhereUniqueInput[]
    disconnect?: ChannelVisitWhereUniqueInput | ChannelVisitWhereUniqueInput[]
    delete?: ChannelVisitWhereUniqueInput | ChannelVisitWhereUniqueInput[]
    connect?: ChannelVisitWhereUniqueInput | ChannelVisitWhereUniqueInput[]
    update?: ChannelVisitUpdateWithWhereUniqueWithoutUserInput | ChannelVisitUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChannelVisitUpdateManyWithWhereWithoutUserInput | ChannelVisitUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChannelVisitScalarWhereInput | ChannelVisitScalarWhereInput[]
  }

  export type FormUpdateManyWithoutUserNestedInput = {
    create?: XOR<FormCreateWithoutUserInput, FormUncheckedCreateWithoutUserInput> | FormCreateWithoutUserInput[] | FormUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FormCreateOrConnectWithoutUserInput | FormCreateOrConnectWithoutUserInput[]
    upsert?: FormUpsertWithWhereUniqueWithoutUserInput | FormUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FormCreateManyUserInputEnvelope
    set?: FormWhereUniqueInput | FormWhereUniqueInput[]
    disconnect?: FormWhereUniqueInput | FormWhereUniqueInput[]
    delete?: FormWhereUniqueInput | FormWhereUniqueInput[]
    connect?: FormWhereUniqueInput | FormWhereUniqueInput[]
    update?: FormUpdateWithWhereUniqueWithoutUserInput | FormUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FormUpdateManyWithWhereWithoutUserInput | FormUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FormScalarWhereInput | FormScalarWhereInput[]
  }

  export type EventUpdateManyWithoutOrganizerNestedInput = {
    create?: XOR<EventCreateWithoutOrganizerInput, EventUncheckedCreateWithoutOrganizerInput> | EventCreateWithoutOrganizerInput[] | EventUncheckedCreateWithoutOrganizerInput[]
    connectOrCreate?: EventCreateOrConnectWithoutOrganizerInput | EventCreateOrConnectWithoutOrganizerInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutOrganizerInput | EventUpsertWithWhereUniqueWithoutOrganizerInput[]
    createMany?: EventCreateManyOrganizerInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutOrganizerInput | EventUpdateWithWhereUniqueWithoutOrganizerInput[]
    updateMany?: EventUpdateManyWithWhereWithoutOrganizerInput | EventUpdateManyWithWhereWithoutOrganizerInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type ChannelUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ChannelCreateWithoutOwnerInput, ChannelUncheckedCreateWithoutOwnerInput> | ChannelCreateWithoutOwnerInput[] | ChannelUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutOwnerInput | ChannelCreateOrConnectWithoutOwnerInput[]
    upsert?: ChannelUpsertWithWhereUniqueWithoutOwnerInput | ChannelUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ChannelCreateManyOwnerInputEnvelope
    set?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    disconnect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    delete?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    update?: ChannelUpdateWithWhereUniqueWithoutOwnerInput | ChannelUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ChannelUpdateManyWithWhereWithoutOwnerInput | ChannelUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ChannelScalarWhereInput | ChannelScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutOverrideSetterNestedInput = {
    create?: XOR<MessageCreateWithoutOverrideSetterInput, MessageUncheckedCreateWithoutOverrideSetterInput> | MessageCreateWithoutOverrideSetterInput[] | MessageUncheckedCreateWithoutOverrideSetterInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutOverrideSetterInput | MessageCreateOrConnectWithoutOverrideSetterInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutOverrideSetterInput | MessageUpsertWithWhereUniqueWithoutOverrideSetterInput[]
    createMany?: MessageCreateManyOverrideSetterInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutOverrideSetterInput | MessageUpdateWithWhereUniqueWithoutOverrideSetterInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutOverrideSetterInput | MessageUpdateManyWithWhereWithoutOverrideSetterInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ChannelSubscriptionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChannelSubscriptionCreateWithoutUserInput, ChannelSubscriptionUncheckedCreateWithoutUserInput> | ChannelSubscriptionCreateWithoutUserInput[] | ChannelSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChannelSubscriptionCreateOrConnectWithoutUserInput | ChannelSubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: ChannelSubscriptionUpsertWithWhereUniqueWithoutUserInput | ChannelSubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChannelSubscriptionCreateManyUserInputEnvelope
    set?: ChannelSubscriptionWhereUniqueInput | ChannelSubscriptionWhereUniqueInput[]
    disconnect?: ChannelSubscriptionWhereUniqueInput | ChannelSubscriptionWhereUniqueInput[]
    delete?: ChannelSubscriptionWhereUniqueInput | ChannelSubscriptionWhereUniqueInput[]
    connect?: ChannelSubscriptionWhereUniqueInput | ChannelSubscriptionWhereUniqueInput[]
    update?: ChannelSubscriptionUpdateWithWhereUniqueWithoutUserInput | ChannelSubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChannelSubscriptionUpdateManyWithWhereWithoutUserInput | ChannelSubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChannelSubscriptionScalarWhereInput | ChannelSubscriptionScalarWhereInput[]
  }

  export type InvitationLinkUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<InvitationLinkCreateWithoutCreatorInput, InvitationLinkUncheckedCreateWithoutCreatorInput> | InvitationLinkCreateWithoutCreatorInput[] | InvitationLinkUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: InvitationLinkCreateOrConnectWithoutCreatorInput | InvitationLinkCreateOrConnectWithoutCreatorInput[]
    upsert?: InvitationLinkUpsertWithWhereUniqueWithoutCreatorInput | InvitationLinkUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: InvitationLinkCreateManyCreatorInputEnvelope
    set?: InvitationLinkWhereUniqueInput | InvitationLinkWhereUniqueInput[]
    disconnect?: InvitationLinkWhereUniqueInput | InvitationLinkWhereUniqueInput[]
    delete?: InvitationLinkWhereUniqueInput | InvitationLinkWhereUniqueInput[]
    connect?: InvitationLinkWhereUniqueInput | InvitationLinkWhereUniqueInput[]
    update?: InvitationLinkUpdateWithWhereUniqueWithoutCreatorInput | InvitationLinkUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: InvitationLinkUpdateManyWithWhereWithoutCreatorInput | InvitationLinkUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: InvitationLinkScalarWhereInput | InvitationLinkScalarWhereInput[]
  }

  export type QrCodeUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<QrCodeCreateWithoutCreatorInput, QrCodeUncheckedCreateWithoutCreatorInput> | QrCodeCreateWithoutCreatorInput[] | QrCodeUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: QrCodeCreateOrConnectWithoutCreatorInput | QrCodeCreateOrConnectWithoutCreatorInput[]
    upsert?: QrCodeUpsertWithWhereUniqueWithoutCreatorInput | QrCodeUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: QrCodeCreateManyCreatorInputEnvelope
    set?: QrCodeWhereUniqueInput | QrCodeWhereUniqueInput[]
    disconnect?: QrCodeWhereUniqueInput | QrCodeWhereUniqueInput[]
    delete?: QrCodeWhereUniqueInput | QrCodeWhereUniqueInput[]
    connect?: QrCodeWhereUniqueInput | QrCodeWhereUniqueInput[]
    update?: QrCodeUpdateWithWhereUniqueWithoutCreatorInput | QrCodeUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: QrCodeUpdateManyWithWhereWithoutCreatorInput | QrCodeUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: QrCodeScalarWhereInput | QrCodeScalarWhereInput[]
  }

  export type MessageDeliveryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageDeliveryCreateWithoutUserInput, MessageDeliveryUncheckedCreateWithoutUserInput> | MessageDeliveryCreateWithoutUserInput[] | MessageDeliveryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageDeliveryCreateOrConnectWithoutUserInput | MessageDeliveryCreateOrConnectWithoutUserInput[]
    upsert?: MessageDeliveryUpsertWithWhereUniqueWithoutUserInput | MessageDeliveryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageDeliveryCreateManyUserInputEnvelope
    set?: MessageDeliveryWhereUniqueInput | MessageDeliveryWhereUniqueInput[]
    disconnect?: MessageDeliveryWhereUniqueInput | MessageDeliveryWhereUniqueInput[]
    delete?: MessageDeliveryWhereUniqueInput | MessageDeliveryWhereUniqueInput[]
    connect?: MessageDeliveryWhereUniqueInput | MessageDeliveryWhereUniqueInput[]
    update?: MessageDeliveryUpdateWithWhereUniqueWithoutUserInput | MessageDeliveryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageDeliveryUpdateManyWithWhereWithoutUserInput | MessageDeliveryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageDeliveryScalarWhereInput | MessageDeliveryScalarWhereInput[]
  }

  export type MessageApprovalUncheckedUpdateManyWithoutApproverNestedInput = {
    create?: XOR<MessageApprovalCreateWithoutApproverInput, MessageApprovalUncheckedCreateWithoutApproverInput> | MessageApprovalCreateWithoutApproverInput[] | MessageApprovalUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: MessageApprovalCreateOrConnectWithoutApproverInput | MessageApprovalCreateOrConnectWithoutApproverInput[]
    upsert?: MessageApprovalUpsertWithWhereUniqueWithoutApproverInput | MessageApprovalUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: MessageApprovalCreateManyApproverInputEnvelope
    set?: MessageApprovalWhereUniqueInput | MessageApprovalWhereUniqueInput[]
    disconnect?: MessageApprovalWhereUniqueInput | MessageApprovalWhereUniqueInput[]
    delete?: MessageApprovalWhereUniqueInput | MessageApprovalWhereUniqueInput[]
    connect?: MessageApprovalWhereUniqueInput | MessageApprovalWhereUniqueInput[]
    update?: MessageApprovalUpdateWithWhereUniqueWithoutApproverInput | MessageApprovalUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: MessageApprovalUpdateManyWithWhereWithoutApproverInput | MessageApprovalUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: MessageApprovalScalarWhereInput | MessageApprovalScalarWhereInput[]
  }

  export type MessageRevisionUncheckedUpdateManyWithoutEditorNestedInput = {
    create?: XOR<MessageRevisionCreateWithoutEditorInput, MessageRevisionUncheckedCreateWithoutEditorInput> | MessageRevisionCreateWithoutEditorInput[] | MessageRevisionUncheckedCreateWithoutEditorInput[]
    connectOrCreate?: MessageRevisionCreateOrConnectWithoutEditorInput | MessageRevisionCreateOrConnectWithoutEditorInput[]
    upsert?: MessageRevisionUpsertWithWhereUniqueWithoutEditorInput | MessageRevisionUpsertWithWhereUniqueWithoutEditorInput[]
    createMany?: MessageRevisionCreateManyEditorInputEnvelope
    set?: MessageRevisionWhereUniqueInput | MessageRevisionWhereUniqueInput[]
    disconnect?: MessageRevisionWhereUniqueInput | MessageRevisionWhereUniqueInput[]
    delete?: MessageRevisionWhereUniqueInput | MessageRevisionWhereUniqueInput[]
    connect?: MessageRevisionWhereUniqueInput | MessageRevisionWhereUniqueInput[]
    update?: MessageRevisionUpdateWithWhereUniqueWithoutEditorInput | MessageRevisionUpdateWithWhereUniqueWithoutEditorInput[]
    updateMany?: MessageRevisionUpdateManyWithWhereWithoutEditorInput | MessageRevisionUpdateManyWithWhereWithoutEditorInput[]
    deleteMany?: MessageRevisionScalarWhereInput | MessageRevisionScalarWhereInput[]
  }

  export type UserProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    upsert?: UserProfileUpsertWithoutUserInput
    disconnect?: UserProfileWhereInput | boolean
    delete?: UserProfileWhereInput | boolean
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutUserInput, UserProfileUpdateWithoutUserInput>, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserMessagingSettingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserMessagingSettingCreateWithoutUserInput, UserMessagingSettingUncheckedCreateWithoutUserInput> | UserMessagingSettingCreateWithoutUserInput[] | UserMessagingSettingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserMessagingSettingCreateOrConnectWithoutUserInput | UserMessagingSettingCreateOrConnectWithoutUserInput[]
    upsert?: UserMessagingSettingUpsertWithWhereUniqueWithoutUserInput | UserMessagingSettingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserMessagingSettingCreateManyUserInputEnvelope
    set?: UserMessagingSettingWhereUniqueInput | UserMessagingSettingWhereUniqueInput[]
    disconnect?: UserMessagingSettingWhereUniqueInput | UserMessagingSettingWhereUniqueInput[]
    delete?: UserMessagingSettingWhereUniqueInput | UserMessagingSettingWhereUniqueInput[]
    connect?: UserMessagingSettingWhereUniqueInput | UserMessagingSettingWhereUniqueInput[]
    update?: UserMessagingSettingUpdateWithWhereUniqueWithoutUserInput | UserMessagingSettingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserMessagingSettingUpdateManyWithWhereWithoutUserInput | UserMessagingSettingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserMessagingSettingScalarWhereInput | UserMessagingSettingScalarWhereInput[]
  }

  export type ChannelApproverUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChannelApproverCreateWithoutUserInput, ChannelApproverUncheckedCreateWithoutUserInput> | ChannelApproverCreateWithoutUserInput[] | ChannelApproverUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChannelApproverCreateOrConnectWithoutUserInput | ChannelApproverCreateOrConnectWithoutUserInput[]
    upsert?: ChannelApproverUpsertWithWhereUniqueWithoutUserInput | ChannelApproverUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChannelApproverCreateManyUserInputEnvelope
    set?: ChannelApproverWhereUniqueInput | ChannelApproverWhereUniqueInput[]
    disconnect?: ChannelApproverWhereUniqueInput | ChannelApproverWhereUniqueInput[]
    delete?: ChannelApproverWhereUniqueInput | ChannelApproverWhereUniqueInput[]
    connect?: ChannelApproverWhereUniqueInput | ChannelApproverWhereUniqueInput[]
    update?: ChannelApproverUpdateWithWhereUniqueWithoutUserInput | ChannelApproverUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChannelApproverUpdateManyWithWhereWithoutUserInput | ChannelApproverUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChannelApproverScalarWhereInput | ChannelApproverScalarWhereInput[]
  }

  export type MessageCategoryUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<MessageCategoryCreateWithoutCreatorInput, MessageCategoryUncheckedCreateWithoutCreatorInput> | MessageCategoryCreateWithoutCreatorInput[] | MessageCategoryUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: MessageCategoryCreateOrConnectWithoutCreatorInput | MessageCategoryCreateOrConnectWithoutCreatorInput[]
    upsert?: MessageCategoryUpsertWithWhereUniqueWithoutCreatorInput | MessageCategoryUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: MessageCategoryCreateManyCreatorInputEnvelope
    set?: MessageCategoryWhereUniqueInput | MessageCategoryWhereUniqueInput[]
    disconnect?: MessageCategoryWhereUniqueInput | MessageCategoryWhereUniqueInput[]
    delete?: MessageCategoryWhereUniqueInput | MessageCategoryWhereUniqueInput[]
    connect?: MessageCategoryWhereUniqueInput | MessageCategoryWhereUniqueInput[]
    update?: MessageCategoryUpdateWithWhereUniqueWithoutCreatorInput | MessageCategoryUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: MessageCategoryUpdateManyWithWhereWithoutCreatorInput | MessageCategoryUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: MessageCategoryScalarWhereInput | MessageCategoryScalarWhereInput[]
  }

  export type MessageViewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageViewCreateWithoutUserInput, MessageViewUncheckedCreateWithoutUserInput> | MessageViewCreateWithoutUserInput[] | MessageViewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageViewCreateOrConnectWithoutUserInput | MessageViewCreateOrConnectWithoutUserInput[]
    upsert?: MessageViewUpsertWithWhereUniqueWithoutUserInput | MessageViewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageViewCreateManyUserInputEnvelope
    set?: MessageViewWhereUniqueInput | MessageViewWhereUniqueInput[]
    disconnect?: MessageViewWhereUniqueInput | MessageViewWhereUniqueInput[]
    delete?: MessageViewWhereUniqueInput | MessageViewWhereUniqueInput[]
    connect?: MessageViewWhereUniqueInput | MessageViewWhereUniqueInput[]
    update?: MessageViewUpdateWithWhereUniqueWithoutUserInput | MessageViewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageViewUpdateManyWithWhereWithoutUserInput | MessageViewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageViewScalarWhereInput | MessageViewScalarWhereInput[]
  }

  export type ChannelVisitUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChannelVisitCreateWithoutUserInput, ChannelVisitUncheckedCreateWithoutUserInput> | ChannelVisitCreateWithoutUserInput[] | ChannelVisitUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChannelVisitCreateOrConnectWithoutUserInput | ChannelVisitCreateOrConnectWithoutUserInput[]
    upsert?: ChannelVisitUpsertWithWhereUniqueWithoutUserInput | ChannelVisitUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChannelVisitCreateManyUserInputEnvelope
    set?: ChannelVisitWhereUniqueInput | ChannelVisitWhereUniqueInput[]
    disconnect?: ChannelVisitWhereUniqueInput | ChannelVisitWhereUniqueInput[]
    delete?: ChannelVisitWhereUniqueInput | ChannelVisitWhereUniqueInput[]
    connect?: ChannelVisitWhereUniqueInput | ChannelVisitWhereUniqueInput[]
    update?: ChannelVisitUpdateWithWhereUniqueWithoutUserInput | ChannelVisitUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChannelVisitUpdateManyWithWhereWithoutUserInput | ChannelVisitUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChannelVisitScalarWhereInput | ChannelVisitScalarWhereInput[]
  }

  export type FormUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FormCreateWithoutUserInput, FormUncheckedCreateWithoutUserInput> | FormCreateWithoutUserInput[] | FormUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FormCreateOrConnectWithoutUserInput | FormCreateOrConnectWithoutUserInput[]
    upsert?: FormUpsertWithWhereUniqueWithoutUserInput | FormUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FormCreateManyUserInputEnvelope
    set?: FormWhereUniqueInput | FormWhereUniqueInput[]
    disconnect?: FormWhereUniqueInput | FormWhereUniqueInput[]
    delete?: FormWhereUniqueInput | FormWhereUniqueInput[]
    connect?: FormWhereUniqueInput | FormWhereUniqueInput[]
    update?: FormUpdateWithWhereUniqueWithoutUserInput | FormUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FormUpdateManyWithWhereWithoutUserInput | FormUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FormScalarWhereInput | FormScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutOrganizerNestedInput = {
    create?: XOR<EventCreateWithoutOrganizerInput, EventUncheckedCreateWithoutOrganizerInput> | EventCreateWithoutOrganizerInput[] | EventUncheckedCreateWithoutOrganizerInput[]
    connectOrCreate?: EventCreateOrConnectWithoutOrganizerInput | EventCreateOrConnectWithoutOrganizerInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutOrganizerInput | EventUpsertWithWhereUniqueWithoutOrganizerInput[]
    createMany?: EventCreateManyOrganizerInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutOrganizerInput | EventUpdateWithWhereUniqueWithoutOrganizerInput[]
    updateMany?: EventUpdateManyWithWhereWithoutOrganizerInput | EventUpdateManyWithWhereWithoutOrganizerInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutOwnedChannelsInput = {
    create?: XOR<UserCreateWithoutOwnedChannelsInput, UserUncheckedCreateWithoutOwnedChannelsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedChannelsInput
    connect?: UserWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutChannelsInput = {
    create?: XOR<OrganizationCreateWithoutChannelsInput, OrganizationUncheckedCreateWithoutChannelsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutChannelsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type ChannelCreateNestedOneWithoutSubchannelsInput = {
    create?: XOR<ChannelCreateWithoutSubchannelsInput, ChannelUncheckedCreateWithoutSubchannelsInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutSubchannelsInput
    connect?: ChannelWhereUniqueInput
  }

  export type ChannelCreateNestedManyWithoutParentInput = {
    create?: XOR<ChannelCreateWithoutParentInput, ChannelUncheckedCreateWithoutParentInput> | ChannelCreateWithoutParentInput[] | ChannelUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutParentInput | ChannelCreateOrConnectWithoutParentInput[]
    createMany?: ChannelCreateManyParentInputEnvelope
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutChannelInput = {
    create?: XOR<MessageCreateWithoutChannelInput, MessageUncheckedCreateWithoutChannelInput> | MessageCreateWithoutChannelInput[] | MessageUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChannelInput | MessageCreateOrConnectWithoutChannelInput[]
    createMany?: MessageCreateManyChannelInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ChannelSubscriptionCreateNestedManyWithoutChannelInput = {
    create?: XOR<ChannelSubscriptionCreateWithoutChannelInput, ChannelSubscriptionUncheckedCreateWithoutChannelInput> | ChannelSubscriptionCreateWithoutChannelInput[] | ChannelSubscriptionUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: ChannelSubscriptionCreateOrConnectWithoutChannelInput | ChannelSubscriptionCreateOrConnectWithoutChannelInput[]
    createMany?: ChannelSubscriptionCreateManyChannelInputEnvelope
    connect?: ChannelSubscriptionWhereUniqueInput | ChannelSubscriptionWhereUniqueInput[]
  }

  export type InvitationLinkCreateNestedManyWithoutChannelInput = {
    create?: XOR<InvitationLinkCreateWithoutChannelInput, InvitationLinkUncheckedCreateWithoutChannelInput> | InvitationLinkCreateWithoutChannelInput[] | InvitationLinkUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: InvitationLinkCreateOrConnectWithoutChannelInput | InvitationLinkCreateOrConnectWithoutChannelInput[]
    createMany?: InvitationLinkCreateManyChannelInputEnvelope
    connect?: InvitationLinkWhereUniqueInput | InvitationLinkWhereUniqueInput[]
  }

  export type QrCodeCreateNestedManyWithoutChannelInput = {
    create?: XOR<QrCodeCreateWithoutChannelInput, QrCodeUncheckedCreateWithoutChannelInput> | QrCodeCreateWithoutChannelInput[] | QrCodeUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: QrCodeCreateOrConnectWithoutChannelInput | QrCodeCreateOrConnectWithoutChannelInput[]
    createMany?: QrCodeCreateManyChannelInputEnvelope
    connect?: QrCodeWhereUniqueInput | QrCodeWhereUniqueInput[]
  }

  export type ChannelApproverCreateNestedManyWithoutChannelInput = {
    create?: XOR<ChannelApproverCreateWithoutChannelInput, ChannelApproverUncheckedCreateWithoutChannelInput> | ChannelApproverCreateWithoutChannelInput[] | ChannelApproverUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: ChannelApproverCreateOrConnectWithoutChannelInput | ChannelApproverCreateOrConnectWithoutChannelInput[]
    createMany?: ChannelApproverCreateManyChannelInputEnvelope
    connect?: ChannelApproverWhereUniqueInput | ChannelApproverWhereUniqueInput[]
  }

  export type ChannelVerificationDocumentCreateNestedManyWithoutChannelInput = {
    create?: XOR<ChannelVerificationDocumentCreateWithoutChannelInput, ChannelVerificationDocumentUncheckedCreateWithoutChannelInput> | ChannelVerificationDocumentCreateWithoutChannelInput[] | ChannelVerificationDocumentUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: ChannelVerificationDocumentCreateOrConnectWithoutChannelInput | ChannelVerificationDocumentCreateOrConnectWithoutChannelInput[]
    createMany?: ChannelVerificationDocumentCreateManyChannelInputEnvelope
    connect?: ChannelVerificationDocumentWhereUniqueInput | ChannelVerificationDocumentWhereUniqueInput[]
  }

  export type ChannelCategoryAssignmentCreateNestedManyWithoutChannelInput = {
    create?: XOR<ChannelCategoryAssignmentCreateWithoutChannelInput, ChannelCategoryAssignmentUncheckedCreateWithoutChannelInput> | ChannelCategoryAssignmentCreateWithoutChannelInput[] | ChannelCategoryAssignmentUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: ChannelCategoryAssignmentCreateOrConnectWithoutChannelInput | ChannelCategoryAssignmentCreateOrConnectWithoutChannelInput[]
    createMany?: ChannelCategoryAssignmentCreateManyChannelInputEnvelope
    connect?: ChannelCategoryAssignmentWhereUniqueInput | ChannelCategoryAssignmentWhereUniqueInput[]
  }

  export type MessageCategoryCreateNestedManyWithoutChannelInput = {
    create?: XOR<MessageCategoryCreateWithoutChannelInput, MessageCategoryUncheckedCreateWithoutChannelInput> | MessageCategoryCreateWithoutChannelInput[] | MessageCategoryUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: MessageCategoryCreateOrConnectWithoutChannelInput | MessageCategoryCreateOrConnectWithoutChannelInput[]
    createMany?: MessageCategoryCreateManyChannelInputEnvelope
    connect?: MessageCategoryWhereUniqueInput | MessageCategoryWhereUniqueInput[]
  }

  export type ChannelVisitCreateNestedManyWithoutChannelInput = {
    create?: XOR<ChannelVisitCreateWithoutChannelInput, ChannelVisitUncheckedCreateWithoutChannelInput> | ChannelVisitCreateWithoutChannelInput[] | ChannelVisitUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: ChannelVisitCreateOrConnectWithoutChannelInput | ChannelVisitCreateOrConnectWithoutChannelInput[]
    createMany?: ChannelVisitCreateManyChannelInputEnvelope
    connect?: ChannelVisitWhereUniqueInput | ChannelVisitWhereUniqueInput[]
  }

  export type ChannelUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<ChannelCreateWithoutParentInput, ChannelUncheckedCreateWithoutParentInput> | ChannelCreateWithoutParentInput[] | ChannelUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutParentInput | ChannelCreateOrConnectWithoutParentInput[]
    createMany?: ChannelCreateManyParentInputEnvelope
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutChannelInput = {
    create?: XOR<MessageCreateWithoutChannelInput, MessageUncheckedCreateWithoutChannelInput> | MessageCreateWithoutChannelInput[] | MessageUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChannelInput | MessageCreateOrConnectWithoutChannelInput[]
    createMany?: MessageCreateManyChannelInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ChannelSubscriptionUncheckedCreateNestedManyWithoutChannelInput = {
    create?: XOR<ChannelSubscriptionCreateWithoutChannelInput, ChannelSubscriptionUncheckedCreateWithoutChannelInput> | ChannelSubscriptionCreateWithoutChannelInput[] | ChannelSubscriptionUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: ChannelSubscriptionCreateOrConnectWithoutChannelInput | ChannelSubscriptionCreateOrConnectWithoutChannelInput[]
    createMany?: ChannelSubscriptionCreateManyChannelInputEnvelope
    connect?: ChannelSubscriptionWhereUniqueInput | ChannelSubscriptionWhereUniqueInput[]
  }

  export type InvitationLinkUncheckedCreateNestedManyWithoutChannelInput = {
    create?: XOR<InvitationLinkCreateWithoutChannelInput, InvitationLinkUncheckedCreateWithoutChannelInput> | InvitationLinkCreateWithoutChannelInput[] | InvitationLinkUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: InvitationLinkCreateOrConnectWithoutChannelInput | InvitationLinkCreateOrConnectWithoutChannelInput[]
    createMany?: InvitationLinkCreateManyChannelInputEnvelope
    connect?: InvitationLinkWhereUniqueInput | InvitationLinkWhereUniqueInput[]
  }

  export type QrCodeUncheckedCreateNestedManyWithoutChannelInput = {
    create?: XOR<QrCodeCreateWithoutChannelInput, QrCodeUncheckedCreateWithoutChannelInput> | QrCodeCreateWithoutChannelInput[] | QrCodeUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: QrCodeCreateOrConnectWithoutChannelInput | QrCodeCreateOrConnectWithoutChannelInput[]
    createMany?: QrCodeCreateManyChannelInputEnvelope
    connect?: QrCodeWhereUniqueInput | QrCodeWhereUniqueInput[]
  }

  export type ChannelApproverUncheckedCreateNestedManyWithoutChannelInput = {
    create?: XOR<ChannelApproverCreateWithoutChannelInput, ChannelApproverUncheckedCreateWithoutChannelInput> | ChannelApproverCreateWithoutChannelInput[] | ChannelApproverUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: ChannelApproverCreateOrConnectWithoutChannelInput | ChannelApproverCreateOrConnectWithoutChannelInput[]
    createMany?: ChannelApproverCreateManyChannelInputEnvelope
    connect?: ChannelApproverWhereUniqueInput | ChannelApproverWhereUniqueInput[]
  }

  export type ChannelVerificationDocumentUncheckedCreateNestedManyWithoutChannelInput = {
    create?: XOR<ChannelVerificationDocumentCreateWithoutChannelInput, ChannelVerificationDocumentUncheckedCreateWithoutChannelInput> | ChannelVerificationDocumentCreateWithoutChannelInput[] | ChannelVerificationDocumentUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: ChannelVerificationDocumentCreateOrConnectWithoutChannelInput | ChannelVerificationDocumentCreateOrConnectWithoutChannelInput[]
    createMany?: ChannelVerificationDocumentCreateManyChannelInputEnvelope
    connect?: ChannelVerificationDocumentWhereUniqueInput | ChannelVerificationDocumentWhereUniqueInput[]
  }

  export type ChannelCategoryAssignmentUncheckedCreateNestedManyWithoutChannelInput = {
    create?: XOR<ChannelCategoryAssignmentCreateWithoutChannelInput, ChannelCategoryAssignmentUncheckedCreateWithoutChannelInput> | ChannelCategoryAssignmentCreateWithoutChannelInput[] | ChannelCategoryAssignmentUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: ChannelCategoryAssignmentCreateOrConnectWithoutChannelInput | ChannelCategoryAssignmentCreateOrConnectWithoutChannelInput[]
    createMany?: ChannelCategoryAssignmentCreateManyChannelInputEnvelope
    connect?: ChannelCategoryAssignmentWhereUniqueInput | ChannelCategoryAssignmentWhereUniqueInput[]
  }

  export type MessageCategoryUncheckedCreateNestedManyWithoutChannelInput = {
    create?: XOR<MessageCategoryCreateWithoutChannelInput, MessageCategoryUncheckedCreateWithoutChannelInput> | MessageCategoryCreateWithoutChannelInput[] | MessageCategoryUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: MessageCategoryCreateOrConnectWithoutChannelInput | MessageCategoryCreateOrConnectWithoutChannelInput[]
    createMany?: MessageCategoryCreateManyChannelInputEnvelope
    connect?: MessageCategoryWhereUniqueInput | MessageCategoryWhereUniqueInput[]
  }

  export type ChannelVisitUncheckedCreateNestedManyWithoutChannelInput = {
    create?: XOR<ChannelVisitCreateWithoutChannelInput, ChannelVisitUncheckedCreateWithoutChannelInput> | ChannelVisitCreateWithoutChannelInput[] | ChannelVisitUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: ChannelVisitCreateOrConnectWithoutChannelInput | ChannelVisitCreateOrConnectWithoutChannelInput[]
    createMany?: ChannelVisitCreateManyChannelInputEnvelope
    connect?: ChannelVisitWhereUniqueInput | ChannelVisitWhereUniqueInput[]
  }

  export type EnumVerificationStatusFieldUpdateOperationsInput = {
    set?: $Enums.VerificationStatus
  }

  export type EnumApprovalPolicyFieldUpdateOperationsInput = {
    set?: $Enums.ApprovalPolicy
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutOwnedChannelsNestedInput = {
    create?: XOR<UserCreateWithoutOwnedChannelsInput, UserUncheckedCreateWithoutOwnedChannelsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedChannelsInput
    upsert?: UserUpsertWithoutOwnedChannelsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedChannelsInput, UserUpdateWithoutOwnedChannelsInput>, UserUncheckedUpdateWithoutOwnedChannelsInput>
  }

  export type OrganizationUpdateOneRequiredWithoutChannelsNestedInput = {
    create?: XOR<OrganizationCreateWithoutChannelsInput, OrganizationUncheckedCreateWithoutChannelsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutChannelsInput
    upsert?: OrganizationUpsertWithoutChannelsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutChannelsInput, OrganizationUpdateWithoutChannelsInput>, OrganizationUncheckedUpdateWithoutChannelsInput>
  }

  export type ChannelUpdateOneWithoutSubchannelsNestedInput = {
    create?: XOR<ChannelCreateWithoutSubchannelsInput, ChannelUncheckedCreateWithoutSubchannelsInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutSubchannelsInput
    upsert?: ChannelUpsertWithoutSubchannelsInput
    disconnect?: ChannelWhereInput | boolean
    delete?: ChannelWhereInput | boolean
    connect?: ChannelWhereUniqueInput
    update?: XOR<XOR<ChannelUpdateToOneWithWhereWithoutSubchannelsInput, ChannelUpdateWithoutSubchannelsInput>, ChannelUncheckedUpdateWithoutSubchannelsInput>
  }

  export type ChannelUpdateManyWithoutParentNestedInput = {
    create?: XOR<ChannelCreateWithoutParentInput, ChannelUncheckedCreateWithoutParentInput> | ChannelCreateWithoutParentInput[] | ChannelUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutParentInput | ChannelCreateOrConnectWithoutParentInput[]
    upsert?: ChannelUpsertWithWhereUniqueWithoutParentInput | ChannelUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: ChannelCreateManyParentInputEnvelope
    set?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    disconnect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    delete?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    update?: ChannelUpdateWithWhereUniqueWithoutParentInput | ChannelUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: ChannelUpdateManyWithWhereWithoutParentInput | ChannelUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: ChannelScalarWhereInput | ChannelScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutChannelNestedInput = {
    create?: XOR<MessageCreateWithoutChannelInput, MessageUncheckedCreateWithoutChannelInput> | MessageCreateWithoutChannelInput[] | MessageUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChannelInput | MessageCreateOrConnectWithoutChannelInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutChannelInput | MessageUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: MessageCreateManyChannelInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutChannelInput | MessageUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutChannelInput | MessageUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ChannelSubscriptionUpdateManyWithoutChannelNestedInput = {
    create?: XOR<ChannelSubscriptionCreateWithoutChannelInput, ChannelSubscriptionUncheckedCreateWithoutChannelInput> | ChannelSubscriptionCreateWithoutChannelInput[] | ChannelSubscriptionUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: ChannelSubscriptionCreateOrConnectWithoutChannelInput | ChannelSubscriptionCreateOrConnectWithoutChannelInput[]
    upsert?: ChannelSubscriptionUpsertWithWhereUniqueWithoutChannelInput | ChannelSubscriptionUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: ChannelSubscriptionCreateManyChannelInputEnvelope
    set?: ChannelSubscriptionWhereUniqueInput | ChannelSubscriptionWhereUniqueInput[]
    disconnect?: ChannelSubscriptionWhereUniqueInput | ChannelSubscriptionWhereUniqueInput[]
    delete?: ChannelSubscriptionWhereUniqueInput | ChannelSubscriptionWhereUniqueInput[]
    connect?: ChannelSubscriptionWhereUniqueInput | ChannelSubscriptionWhereUniqueInput[]
    update?: ChannelSubscriptionUpdateWithWhereUniqueWithoutChannelInput | ChannelSubscriptionUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: ChannelSubscriptionUpdateManyWithWhereWithoutChannelInput | ChannelSubscriptionUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: ChannelSubscriptionScalarWhereInput | ChannelSubscriptionScalarWhereInput[]
  }

  export type InvitationLinkUpdateManyWithoutChannelNestedInput = {
    create?: XOR<InvitationLinkCreateWithoutChannelInput, InvitationLinkUncheckedCreateWithoutChannelInput> | InvitationLinkCreateWithoutChannelInput[] | InvitationLinkUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: InvitationLinkCreateOrConnectWithoutChannelInput | InvitationLinkCreateOrConnectWithoutChannelInput[]
    upsert?: InvitationLinkUpsertWithWhereUniqueWithoutChannelInput | InvitationLinkUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: InvitationLinkCreateManyChannelInputEnvelope
    set?: InvitationLinkWhereUniqueInput | InvitationLinkWhereUniqueInput[]
    disconnect?: InvitationLinkWhereUniqueInput | InvitationLinkWhereUniqueInput[]
    delete?: InvitationLinkWhereUniqueInput | InvitationLinkWhereUniqueInput[]
    connect?: InvitationLinkWhereUniqueInput | InvitationLinkWhereUniqueInput[]
    update?: InvitationLinkUpdateWithWhereUniqueWithoutChannelInput | InvitationLinkUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: InvitationLinkUpdateManyWithWhereWithoutChannelInput | InvitationLinkUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: InvitationLinkScalarWhereInput | InvitationLinkScalarWhereInput[]
  }

  export type QrCodeUpdateManyWithoutChannelNestedInput = {
    create?: XOR<QrCodeCreateWithoutChannelInput, QrCodeUncheckedCreateWithoutChannelInput> | QrCodeCreateWithoutChannelInput[] | QrCodeUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: QrCodeCreateOrConnectWithoutChannelInput | QrCodeCreateOrConnectWithoutChannelInput[]
    upsert?: QrCodeUpsertWithWhereUniqueWithoutChannelInput | QrCodeUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: QrCodeCreateManyChannelInputEnvelope
    set?: QrCodeWhereUniqueInput | QrCodeWhereUniqueInput[]
    disconnect?: QrCodeWhereUniqueInput | QrCodeWhereUniqueInput[]
    delete?: QrCodeWhereUniqueInput | QrCodeWhereUniqueInput[]
    connect?: QrCodeWhereUniqueInput | QrCodeWhereUniqueInput[]
    update?: QrCodeUpdateWithWhereUniqueWithoutChannelInput | QrCodeUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: QrCodeUpdateManyWithWhereWithoutChannelInput | QrCodeUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: QrCodeScalarWhereInput | QrCodeScalarWhereInput[]
  }

  export type ChannelApproverUpdateManyWithoutChannelNestedInput = {
    create?: XOR<ChannelApproverCreateWithoutChannelInput, ChannelApproverUncheckedCreateWithoutChannelInput> | ChannelApproverCreateWithoutChannelInput[] | ChannelApproverUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: ChannelApproverCreateOrConnectWithoutChannelInput | ChannelApproverCreateOrConnectWithoutChannelInput[]
    upsert?: ChannelApproverUpsertWithWhereUniqueWithoutChannelInput | ChannelApproverUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: ChannelApproverCreateManyChannelInputEnvelope
    set?: ChannelApproverWhereUniqueInput | ChannelApproverWhereUniqueInput[]
    disconnect?: ChannelApproverWhereUniqueInput | ChannelApproverWhereUniqueInput[]
    delete?: ChannelApproverWhereUniqueInput | ChannelApproverWhereUniqueInput[]
    connect?: ChannelApproverWhereUniqueInput | ChannelApproverWhereUniqueInput[]
    update?: ChannelApproverUpdateWithWhereUniqueWithoutChannelInput | ChannelApproverUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: ChannelApproverUpdateManyWithWhereWithoutChannelInput | ChannelApproverUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: ChannelApproverScalarWhereInput | ChannelApproverScalarWhereInput[]
  }

  export type ChannelVerificationDocumentUpdateManyWithoutChannelNestedInput = {
    create?: XOR<ChannelVerificationDocumentCreateWithoutChannelInput, ChannelVerificationDocumentUncheckedCreateWithoutChannelInput> | ChannelVerificationDocumentCreateWithoutChannelInput[] | ChannelVerificationDocumentUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: ChannelVerificationDocumentCreateOrConnectWithoutChannelInput | ChannelVerificationDocumentCreateOrConnectWithoutChannelInput[]
    upsert?: ChannelVerificationDocumentUpsertWithWhereUniqueWithoutChannelInput | ChannelVerificationDocumentUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: ChannelVerificationDocumentCreateManyChannelInputEnvelope
    set?: ChannelVerificationDocumentWhereUniqueInput | ChannelVerificationDocumentWhereUniqueInput[]
    disconnect?: ChannelVerificationDocumentWhereUniqueInput | ChannelVerificationDocumentWhereUniqueInput[]
    delete?: ChannelVerificationDocumentWhereUniqueInput | ChannelVerificationDocumentWhereUniqueInput[]
    connect?: ChannelVerificationDocumentWhereUniqueInput | ChannelVerificationDocumentWhereUniqueInput[]
    update?: ChannelVerificationDocumentUpdateWithWhereUniqueWithoutChannelInput | ChannelVerificationDocumentUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: ChannelVerificationDocumentUpdateManyWithWhereWithoutChannelInput | ChannelVerificationDocumentUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: ChannelVerificationDocumentScalarWhereInput | ChannelVerificationDocumentScalarWhereInput[]
  }

  export type ChannelCategoryAssignmentUpdateManyWithoutChannelNestedInput = {
    create?: XOR<ChannelCategoryAssignmentCreateWithoutChannelInput, ChannelCategoryAssignmentUncheckedCreateWithoutChannelInput> | ChannelCategoryAssignmentCreateWithoutChannelInput[] | ChannelCategoryAssignmentUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: ChannelCategoryAssignmentCreateOrConnectWithoutChannelInput | ChannelCategoryAssignmentCreateOrConnectWithoutChannelInput[]
    upsert?: ChannelCategoryAssignmentUpsertWithWhereUniqueWithoutChannelInput | ChannelCategoryAssignmentUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: ChannelCategoryAssignmentCreateManyChannelInputEnvelope
    set?: ChannelCategoryAssignmentWhereUniqueInput | ChannelCategoryAssignmentWhereUniqueInput[]
    disconnect?: ChannelCategoryAssignmentWhereUniqueInput | ChannelCategoryAssignmentWhereUniqueInput[]
    delete?: ChannelCategoryAssignmentWhereUniqueInput | ChannelCategoryAssignmentWhereUniqueInput[]
    connect?: ChannelCategoryAssignmentWhereUniqueInput | ChannelCategoryAssignmentWhereUniqueInput[]
    update?: ChannelCategoryAssignmentUpdateWithWhereUniqueWithoutChannelInput | ChannelCategoryAssignmentUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: ChannelCategoryAssignmentUpdateManyWithWhereWithoutChannelInput | ChannelCategoryAssignmentUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: ChannelCategoryAssignmentScalarWhereInput | ChannelCategoryAssignmentScalarWhereInput[]
  }

  export type MessageCategoryUpdateManyWithoutChannelNestedInput = {
    create?: XOR<MessageCategoryCreateWithoutChannelInput, MessageCategoryUncheckedCreateWithoutChannelInput> | MessageCategoryCreateWithoutChannelInput[] | MessageCategoryUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: MessageCategoryCreateOrConnectWithoutChannelInput | MessageCategoryCreateOrConnectWithoutChannelInput[]
    upsert?: MessageCategoryUpsertWithWhereUniqueWithoutChannelInput | MessageCategoryUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: MessageCategoryCreateManyChannelInputEnvelope
    set?: MessageCategoryWhereUniqueInput | MessageCategoryWhereUniqueInput[]
    disconnect?: MessageCategoryWhereUniqueInput | MessageCategoryWhereUniqueInput[]
    delete?: MessageCategoryWhereUniqueInput | MessageCategoryWhereUniqueInput[]
    connect?: MessageCategoryWhereUniqueInput | MessageCategoryWhereUniqueInput[]
    update?: MessageCategoryUpdateWithWhereUniqueWithoutChannelInput | MessageCategoryUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: MessageCategoryUpdateManyWithWhereWithoutChannelInput | MessageCategoryUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: MessageCategoryScalarWhereInput | MessageCategoryScalarWhereInput[]
  }

  export type ChannelVisitUpdateManyWithoutChannelNestedInput = {
    create?: XOR<ChannelVisitCreateWithoutChannelInput, ChannelVisitUncheckedCreateWithoutChannelInput> | ChannelVisitCreateWithoutChannelInput[] | ChannelVisitUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: ChannelVisitCreateOrConnectWithoutChannelInput | ChannelVisitCreateOrConnectWithoutChannelInput[]
    upsert?: ChannelVisitUpsertWithWhereUniqueWithoutChannelInput | ChannelVisitUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: ChannelVisitCreateManyChannelInputEnvelope
    set?: ChannelVisitWhereUniqueInput | ChannelVisitWhereUniqueInput[]
    disconnect?: ChannelVisitWhereUniqueInput | ChannelVisitWhereUniqueInput[]
    delete?: ChannelVisitWhereUniqueInput | ChannelVisitWhereUniqueInput[]
    connect?: ChannelVisitWhereUniqueInput | ChannelVisitWhereUniqueInput[]
    update?: ChannelVisitUpdateWithWhereUniqueWithoutChannelInput | ChannelVisitUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: ChannelVisitUpdateManyWithWhereWithoutChannelInput | ChannelVisitUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: ChannelVisitScalarWhereInput | ChannelVisitScalarWhereInput[]
  }

  export type ChannelUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<ChannelCreateWithoutParentInput, ChannelUncheckedCreateWithoutParentInput> | ChannelCreateWithoutParentInput[] | ChannelUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutParentInput | ChannelCreateOrConnectWithoutParentInput[]
    upsert?: ChannelUpsertWithWhereUniqueWithoutParentInput | ChannelUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: ChannelCreateManyParentInputEnvelope
    set?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    disconnect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    delete?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    update?: ChannelUpdateWithWhereUniqueWithoutParentInput | ChannelUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: ChannelUpdateManyWithWhereWithoutParentInput | ChannelUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: ChannelScalarWhereInput | ChannelScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutChannelNestedInput = {
    create?: XOR<MessageCreateWithoutChannelInput, MessageUncheckedCreateWithoutChannelInput> | MessageCreateWithoutChannelInput[] | MessageUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChannelInput | MessageCreateOrConnectWithoutChannelInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutChannelInput | MessageUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: MessageCreateManyChannelInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutChannelInput | MessageUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutChannelInput | MessageUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ChannelSubscriptionUncheckedUpdateManyWithoutChannelNestedInput = {
    create?: XOR<ChannelSubscriptionCreateWithoutChannelInput, ChannelSubscriptionUncheckedCreateWithoutChannelInput> | ChannelSubscriptionCreateWithoutChannelInput[] | ChannelSubscriptionUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: ChannelSubscriptionCreateOrConnectWithoutChannelInput | ChannelSubscriptionCreateOrConnectWithoutChannelInput[]
    upsert?: ChannelSubscriptionUpsertWithWhereUniqueWithoutChannelInput | ChannelSubscriptionUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: ChannelSubscriptionCreateManyChannelInputEnvelope
    set?: ChannelSubscriptionWhereUniqueInput | ChannelSubscriptionWhereUniqueInput[]
    disconnect?: ChannelSubscriptionWhereUniqueInput | ChannelSubscriptionWhereUniqueInput[]
    delete?: ChannelSubscriptionWhereUniqueInput | ChannelSubscriptionWhereUniqueInput[]
    connect?: ChannelSubscriptionWhereUniqueInput | ChannelSubscriptionWhereUniqueInput[]
    update?: ChannelSubscriptionUpdateWithWhereUniqueWithoutChannelInput | ChannelSubscriptionUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: ChannelSubscriptionUpdateManyWithWhereWithoutChannelInput | ChannelSubscriptionUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: ChannelSubscriptionScalarWhereInput | ChannelSubscriptionScalarWhereInput[]
  }

  export type InvitationLinkUncheckedUpdateManyWithoutChannelNestedInput = {
    create?: XOR<InvitationLinkCreateWithoutChannelInput, InvitationLinkUncheckedCreateWithoutChannelInput> | InvitationLinkCreateWithoutChannelInput[] | InvitationLinkUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: InvitationLinkCreateOrConnectWithoutChannelInput | InvitationLinkCreateOrConnectWithoutChannelInput[]
    upsert?: InvitationLinkUpsertWithWhereUniqueWithoutChannelInput | InvitationLinkUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: InvitationLinkCreateManyChannelInputEnvelope
    set?: InvitationLinkWhereUniqueInput | InvitationLinkWhereUniqueInput[]
    disconnect?: InvitationLinkWhereUniqueInput | InvitationLinkWhereUniqueInput[]
    delete?: InvitationLinkWhereUniqueInput | InvitationLinkWhereUniqueInput[]
    connect?: InvitationLinkWhereUniqueInput | InvitationLinkWhereUniqueInput[]
    update?: InvitationLinkUpdateWithWhereUniqueWithoutChannelInput | InvitationLinkUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: InvitationLinkUpdateManyWithWhereWithoutChannelInput | InvitationLinkUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: InvitationLinkScalarWhereInput | InvitationLinkScalarWhereInput[]
  }

  export type QrCodeUncheckedUpdateManyWithoutChannelNestedInput = {
    create?: XOR<QrCodeCreateWithoutChannelInput, QrCodeUncheckedCreateWithoutChannelInput> | QrCodeCreateWithoutChannelInput[] | QrCodeUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: QrCodeCreateOrConnectWithoutChannelInput | QrCodeCreateOrConnectWithoutChannelInput[]
    upsert?: QrCodeUpsertWithWhereUniqueWithoutChannelInput | QrCodeUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: QrCodeCreateManyChannelInputEnvelope
    set?: QrCodeWhereUniqueInput | QrCodeWhereUniqueInput[]
    disconnect?: QrCodeWhereUniqueInput | QrCodeWhereUniqueInput[]
    delete?: QrCodeWhereUniqueInput | QrCodeWhereUniqueInput[]
    connect?: QrCodeWhereUniqueInput | QrCodeWhereUniqueInput[]
    update?: QrCodeUpdateWithWhereUniqueWithoutChannelInput | QrCodeUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: QrCodeUpdateManyWithWhereWithoutChannelInput | QrCodeUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: QrCodeScalarWhereInput | QrCodeScalarWhereInput[]
  }

  export type ChannelApproverUncheckedUpdateManyWithoutChannelNestedInput = {
    create?: XOR<ChannelApproverCreateWithoutChannelInput, ChannelApproverUncheckedCreateWithoutChannelInput> | ChannelApproverCreateWithoutChannelInput[] | ChannelApproverUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: ChannelApproverCreateOrConnectWithoutChannelInput | ChannelApproverCreateOrConnectWithoutChannelInput[]
    upsert?: ChannelApproverUpsertWithWhereUniqueWithoutChannelInput | ChannelApproverUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: ChannelApproverCreateManyChannelInputEnvelope
    set?: ChannelApproverWhereUniqueInput | ChannelApproverWhereUniqueInput[]
    disconnect?: ChannelApproverWhereUniqueInput | ChannelApproverWhereUniqueInput[]
    delete?: ChannelApproverWhereUniqueInput | ChannelApproverWhereUniqueInput[]
    connect?: ChannelApproverWhereUniqueInput | ChannelApproverWhereUniqueInput[]
    update?: ChannelApproverUpdateWithWhereUniqueWithoutChannelInput | ChannelApproverUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: ChannelApproverUpdateManyWithWhereWithoutChannelInput | ChannelApproverUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: ChannelApproverScalarWhereInput | ChannelApproverScalarWhereInput[]
  }

  export type ChannelVerificationDocumentUncheckedUpdateManyWithoutChannelNestedInput = {
    create?: XOR<ChannelVerificationDocumentCreateWithoutChannelInput, ChannelVerificationDocumentUncheckedCreateWithoutChannelInput> | ChannelVerificationDocumentCreateWithoutChannelInput[] | ChannelVerificationDocumentUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: ChannelVerificationDocumentCreateOrConnectWithoutChannelInput | ChannelVerificationDocumentCreateOrConnectWithoutChannelInput[]
    upsert?: ChannelVerificationDocumentUpsertWithWhereUniqueWithoutChannelInput | ChannelVerificationDocumentUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: ChannelVerificationDocumentCreateManyChannelInputEnvelope
    set?: ChannelVerificationDocumentWhereUniqueInput | ChannelVerificationDocumentWhereUniqueInput[]
    disconnect?: ChannelVerificationDocumentWhereUniqueInput | ChannelVerificationDocumentWhereUniqueInput[]
    delete?: ChannelVerificationDocumentWhereUniqueInput | ChannelVerificationDocumentWhereUniqueInput[]
    connect?: ChannelVerificationDocumentWhereUniqueInput | ChannelVerificationDocumentWhereUniqueInput[]
    update?: ChannelVerificationDocumentUpdateWithWhereUniqueWithoutChannelInput | ChannelVerificationDocumentUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: ChannelVerificationDocumentUpdateManyWithWhereWithoutChannelInput | ChannelVerificationDocumentUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: ChannelVerificationDocumentScalarWhereInput | ChannelVerificationDocumentScalarWhereInput[]
  }

  export type ChannelCategoryAssignmentUncheckedUpdateManyWithoutChannelNestedInput = {
    create?: XOR<ChannelCategoryAssignmentCreateWithoutChannelInput, ChannelCategoryAssignmentUncheckedCreateWithoutChannelInput> | ChannelCategoryAssignmentCreateWithoutChannelInput[] | ChannelCategoryAssignmentUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: ChannelCategoryAssignmentCreateOrConnectWithoutChannelInput | ChannelCategoryAssignmentCreateOrConnectWithoutChannelInput[]
    upsert?: ChannelCategoryAssignmentUpsertWithWhereUniqueWithoutChannelInput | ChannelCategoryAssignmentUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: ChannelCategoryAssignmentCreateManyChannelInputEnvelope
    set?: ChannelCategoryAssignmentWhereUniqueInput | ChannelCategoryAssignmentWhereUniqueInput[]
    disconnect?: ChannelCategoryAssignmentWhereUniqueInput | ChannelCategoryAssignmentWhereUniqueInput[]
    delete?: ChannelCategoryAssignmentWhereUniqueInput | ChannelCategoryAssignmentWhereUniqueInput[]
    connect?: ChannelCategoryAssignmentWhereUniqueInput | ChannelCategoryAssignmentWhereUniqueInput[]
    update?: ChannelCategoryAssignmentUpdateWithWhereUniqueWithoutChannelInput | ChannelCategoryAssignmentUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: ChannelCategoryAssignmentUpdateManyWithWhereWithoutChannelInput | ChannelCategoryAssignmentUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: ChannelCategoryAssignmentScalarWhereInput | ChannelCategoryAssignmentScalarWhereInput[]
  }

  export type MessageCategoryUncheckedUpdateManyWithoutChannelNestedInput = {
    create?: XOR<MessageCategoryCreateWithoutChannelInput, MessageCategoryUncheckedCreateWithoutChannelInput> | MessageCategoryCreateWithoutChannelInput[] | MessageCategoryUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: MessageCategoryCreateOrConnectWithoutChannelInput | MessageCategoryCreateOrConnectWithoutChannelInput[]
    upsert?: MessageCategoryUpsertWithWhereUniqueWithoutChannelInput | MessageCategoryUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: MessageCategoryCreateManyChannelInputEnvelope
    set?: MessageCategoryWhereUniqueInput | MessageCategoryWhereUniqueInput[]
    disconnect?: MessageCategoryWhereUniqueInput | MessageCategoryWhereUniqueInput[]
    delete?: MessageCategoryWhereUniqueInput | MessageCategoryWhereUniqueInput[]
    connect?: MessageCategoryWhereUniqueInput | MessageCategoryWhereUniqueInput[]
    update?: MessageCategoryUpdateWithWhereUniqueWithoutChannelInput | MessageCategoryUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: MessageCategoryUpdateManyWithWhereWithoutChannelInput | MessageCategoryUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: MessageCategoryScalarWhereInput | MessageCategoryScalarWhereInput[]
  }

  export type ChannelVisitUncheckedUpdateManyWithoutChannelNestedInput = {
    create?: XOR<ChannelVisitCreateWithoutChannelInput, ChannelVisitUncheckedCreateWithoutChannelInput> | ChannelVisitCreateWithoutChannelInput[] | ChannelVisitUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: ChannelVisitCreateOrConnectWithoutChannelInput | ChannelVisitCreateOrConnectWithoutChannelInput[]
    upsert?: ChannelVisitUpsertWithWhereUniqueWithoutChannelInput | ChannelVisitUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: ChannelVisitCreateManyChannelInputEnvelope
    set?: ChannelVisitWhereUniqueInput | ChannelVisitWhereUniqueInput[]
    disconnect?: ChannelVisitWhereUniqueInput | ChannelVisitWhereUniqueInput[]
    delete?: ChannelVisitWhereUniqueInput | ChannelVisitWhereUniqueInput[]
    connect?: ChannelVisitWhereUniqueInput | ChannelVisitWhereUniqueInput[]
    update?: ChannelVisitUpdateWithWhereUniqueWithoutChannelInput | ChannelVisitUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: ChannelVisitUpdateManyWithWhereWithoutChannelInput | ChannelVisitUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: ChannelVisitScalarWhereInput | ChannelVisitScalarWhereInput[]
  }

  export type ChannelCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ChannelCreateWithoutMessagesInput, ChannelUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutMessagesInput
    connect?: ChannelWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMessagesSentInput = {
    create?: XOR<UserCreateWithoutMessagesSentInput, UserUncheckedCreateWithoutMessagesSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesSentInput
    connect?: UserWhereUniqueInput
  }

  export type MessageCategoryCreateNestedOneWithoutMessagesInput = {
    create?: XOR<MessageCategoryCreateWithoutMessagesInput, MessageCategoryUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: MessageCategoryCreateOrConnectWithoutMessagesInput
    connect?: MessageCategoryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMessagesOverrideSetInput = {
    create?: XOR<UserCreateWithoutMessagesOverrideSetInput, UserUncheckedCreateWithoutMessagesOverrideSetInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesOverrideSetInput
    connect?: UserWhereUniqueInput
  }

  export type MessageDeliveryCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageDeliveryCreateWithoutMessageInput, MessageDeliveryUncheckedCreateWithoutMessageInput> | MessageDeliveryCreateWithoutMessageInput[] | MessageDeliveryUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageDeliveryCreateOrConnectWithoutMessageInput | MessageDeliveryCreateOrConnectWithoutMessageInput[]
    createMany?: MessageDeliveryCreateManyMessageInputEnvelope
    connect?: MessageDeliveryWhereUniqueInput | MessageDeliveryWhereUniqueInput[]
  }

  export type MessageApprovalCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageApprovalCreateWithoutMessageInput, MessageApprovalUncheckedCreateWithoutMessageInput> | MessageApprovalCreateWithoutMessageInput[] | MessageApprovalUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageApprovalCreateOrConnectWithoutMessageInput | MessageApprovalCreateOrConnectWithoutMessageInput[]
    createMany?: MessageApprovalCreateManyMessageInputEnvelope
    connect?: MessageApprovalWhereUniqueInput | MessageApprovalWhereUniqueInput[]
  }

  export type MessageAttachmentCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageAttachmentCreateWithoutMessageInput, MessageAttachmentUncheckedCreateWithoutMessageInput> | MessageAttachmentCreateWithoutMessageInput[] | MessageAttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageAttachmentCreateOrConnectWithoutMessageInput | MessageAttachmentCreateOrConnectWithoutMessageInput[]
    createMany?: MessageAttachmentCreateManyMessageInputEnvelope
    connect?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
  }

  export type MessageRevisionCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageRevisionCreateWithoutMessageInput, MessageRevisionUncheckedCreateWithoutMessageInput> | MessageRevisionCreateWithoutMessageInput[] | MessageRevisionUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageRevisionCreateOrConnectWithoutMessageInput | MessageRevisionCreateOrConnectWithoutMessageInput[]
    createMany?: MessageRevisionCreateManyMessageInputEnvelope
    connect?: MessageRevisionWhereUniqueInput | MessageRevisionWhereUniqueInput[]
  }

  export type MessageViewCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageViewCreateWithoutMessageInput, MessageViewUncheckedCreateWithoutMessageInput> | MessageViewCreateWithoutMessageInput[] | MessageViewUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageViewCreateOrConnectWithoutMessageInput | MessageViewCreateOrConnectWithoutMessageInput[]
    createMany?: MessageViewCreateManyMessageInputEnvelope
    connect?: MessageViewWhereUniqueInput | MessageViewWhereUniqueInput[]
  }

  export type MessageDeliveryUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageDeliveryCreateWithoutMessageInput, MessageDeliveryUncheckedCreateWithoutMessageInput> | MessageDeliveryCreateWithoutMessageInput[] | MessageDeliveryUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageDeliveryCreateOrConnectWithoutMessageInput | MessageDeliveryCreateOrConnectWithoutMessageInput[]
    createMany?: MessageDeliveryCreateManyMessageInputEnvelope
    connect?: MessageDeliveryWhereUniqueInput | MessageDeliveryWhereUniqueInput[]
  }

  export type MessageApprovalUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageApprovalCreateWithoutMessageInput, MessageApprovalUncheckedCreateWithoutMessageInput> | MessageApprovalCreateWithoutMessageInput[] | MessageApprovalUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageApprovalCreateOrConnectWithoutMessageInput | MessageApprovalCreateOrConnectWithoutMessageInput[]
    createMany?: MessageApprovalCreateManyMessageInputEnvelope
    connect?: MessageApprovalWhereUniqueInput | MessageApprovalWhereUniqueInput[]
  }

  export type MessageAttachmentUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageAttachmentCreateWithoutMessageInput, MessageAttachmentUncheckedCreateWithoutMessageInput> | MessageAttachmentCreateWithoutMessageInput[] | MessageAttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageAttachmentCreateOrConnectWithoutMessageInput | MessageAttachmentCreateOrConnectWithoutMessageInput[]
    createMany?: MessageAttachmentCreateManyMessageInputEnvelope
    connect?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
  }

  export type MessageRevisionUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageRevisionCreateWithoutMessageInput, MessageRevisionUncheckedCreateWithoutMessageInput> | MessageRevisionCreateWithoutMessageInput[] | MessageRevisionUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageRevisionCreateOrConnectWithoutMessageInput | MessageRevisionCreateOrConnectWithoutMessageInput[]
    createMany?: MessageRevisionCreateManyMessageInputEnvelope
    connect?: MessageRevisionWhereUniqueInput | MessageRevisionWhereUniqueInput[]
  }

  export type MessageViewUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageViewCreateWithoutMessageInput, MessageViewUncheckedCreateWithoutMessageInput> | MessageViewCreateWithoutMessageInput[] | MessageViewUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageViewCreateOrConnectWithoutMessageInput | MessageViewCreateOrConnectWithoutMessageInput[]
    createMany?: MessageViewCreateManyMessageInputEnvelope
    connect?: MessageViewWhereUniqueInput | MessageViewWhereUniqueInput[]
  }

  export type EnumMessagePriorityFieldUpdateOperationsInput = {
    set?: $Enums.MessagePriority
  }

  export type NullableEnumApprovalPolicyFieldUpdateOperationsInput = {
    set?: $Enums.ApprovalPolicy | null
  }

  export type EnumDeliveryMethodFieldUpdateOperationsInput = {
    set?: $Enums.DeliveryMethod
  }

  export type EnumMessageStateFieldUpdateOperationsInput = {
    set?: $Enums.MessageState
  }

  export type ChannelUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ChannelCreateWithoutMessagesInput, ChannelUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutMessagesInput
    upsert?: ChannelUpsertWithoutMessagesInput
    connect?: ChannelWhereUniqueInput
    update?: XOR<XOR<ChannelUpdateToOneWithWhereWithoutMessagesInput, ChannelUpdateWithoutMessagesInput>, ChannelUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutMessagesSentNestedInput = {
    create?: XOR<UserCreateWithoutMessagesSentInput, UserUncheckedCreateWithoutMessagesSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesSentInput
    upsert?: UserUpsertWithoutMessagesSentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessagesSentInput, UserUpdateWithoutMessagesSentInput>, UserUncheckedUpdateWithoutMessagesSentInput>
  }

  export type MessageCategoryUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<MessageCategoryCreateWithoutMessagesInput, MessageCategoryUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: MessageCategoryCreateOrConnectWithoutMessagesInput
    upsert?: MessageCategoryUpsertWithoutMessagesInput
    connect?: MessageCategoryWhereUniqueInput
    update?: XOR<XOR<MessageCategoryUpdateToOneWithWhereWithoutMessagesInput, MessageCategoryUpdateWithoutMessagesInput>, MessageCategoryUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneWithoutMessagesOverrideSetNestedInput = {
    create?: XOR<UserCreateWithoutMessagesOverrideSetInput, UserUncheckedCreateWithoutMessagesOverrideSetInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesOverrideSetInput
    upsert?: UserUpsertWithoutMessagesOverrideSetInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessagesOverrideSetInput, UserUpdateWithoutMessagesOverrideSetInput>, UserUncheckedUpdateWithoutMessagesOverrideSetInput>
  }

  export type MessageDeliveryUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageDeliveryCreateWithoutMessageInput, MessageDeliveryUncheckedCreateWithoutMessageInput> | MessageDeliveryCreateWithoutMessageInput[] | MessageDeliveryUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageDeliveryCreateOrConnectWithoutMessageInput | MessageDeliveryCreateOrConnectWithoutMessageInput[]
    upsert?: MessageDeliveryUpsertWithWhereUniqueWithoutMessageInput | MessageDeliveryUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageDeliveryCreateManyMessageInputEnvelope
    set?: MessageDeliveryWhereUniqueInput | MessageDeliveryWhereUniqueInput[]
    disconnect?: MessageDeliveryWhereUniqueInput | MessageDeliveryWhereUniqueInput[]
    delete?: MessageDeliveryWhereUniqueInput | MessageDeliveryWhereUniqueInput[]
    connect?: MessageDeliveryWhereUniqueInput | MessageDeliveryWhereUniqueInput[]
    update?: MessageDeliveryUpdateWithWhereUniqueWithoutMessageInput | MessageDeliveryUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageDeliveryUpdateManyWithWhereWithoutMessageInput | MessageDeliveryUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageDeliveryScalarWhereInput | MessageDeliveryScalarWhereInput[]
  }

  export type MessageApprovalUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageApprovalCreateWithoutMessageInput, MessageApprovalUncheckedCreateWithoutMessageInput> | MessageApprovalCreateWithoutMessageInput[] | MessageApprovalUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageApprovalCreateOrConnectWithoutMessageInput | MessageApprovalCreateOrConnectWithoutMessageInput[]
    upsert?: MessageApprovalUpsertWithWhereUniqueWithoutMessageInput | MessageApprovalUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageApprovalCreateManyMessageInputEnvelope
    set?: MessageApprovalWhereUniqueInput | MessageApprovalWhereUniqueInput[]
    disconnect?: MessageApprovalWhereUniqueInput | MessageApprovalWhereUniqueInput[]
    delete?: MessageApprovalWhereUniqueInput | MessageApprovalWhereUniqueInput[]
    connect?: MessageApprovalWhereUniqueInput | MessageApprovalWhereUniqueInput[]
    update?: MessageApprovalUpdateWithWhereUniqueWithoutMessageInput | MessageApprovalUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageApprovalUpdateManyWithWhereWithoutMessageInput | MessageApprovalUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageApprovalScalarWhereInput | MessageApprovalScalarWhereInput[]
  }

  export type MessageAttachmentUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageAttachmentCreateWithoutMessageInput, MessageAttachmentUncheckedCreateWithoutMessageInput> | MessageAttachmentCreateWithoutMessageInput[] | MessageAttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageAttachmentCreateOrConnectWithoutMessageInput | MessageAttachmentCreateOrConnectWithoutMessageInput[]
    upsert?: MessageAttachmentUpsertWithWhereUniqueWithoutMessageInput | MessageAttachmentUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageAttachmentCreateManyMessageInputEnvelope
    set?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    disconnect?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    delete?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    connect?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    update?: MessageAttachmentUpdateWithWhereUniqueWithoutMessageInput | MessageAttachmentUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageAttachmentUpdateManyWithWhereWithoutMessageInput | MessageAttachmentUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageAttachmentScalarWhereInput | MessageAttachmentScalarWhereInput[]
  }

  export type MessageRevisionUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageRevisionCreateWithoutMessageInput, MessageRevisionUncheckedCreateWithoutMessageInput> | MessageRevisionCreateWithoutMessageInput[] | MessageRevisionUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageRevisionCreateOrConnectWithoutMessageInput | MessageRevisionCreateOrConnectWithoutMessageInput[]
    upsert?: MessageRevisionUpsertWithWhereUniqueWithoutMessageInput | MessageRevisionUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageRevisionCreateManyMessageInputEnvelope
    set?: MessageRevisionWhereUniqueInput | MessageRevisionWhereUniqueInput[]
    disconnect?: MessageRevisionWhereUniqueInput | MessageRevisionWhereUniqueInput[]
    delete?: MessageRevisionWhereUniqueInput | MessageRevisionWhereUniqueInput[]
    connect?: MessageRevisionWhereUniqueInput | MessageRevisionWhereUniqueInput[]
    update?: MessageRevisionUpdateWithWhereUniqueWithoutMessageInput | MessageRevisionUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageRevisionUpdateManyWithWhereWithoutMessageInput | MessageRevisionUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageRevisionScalarWhereInput | MessageRevisionScalarWhereInput[]
  }

  export type MessageViewUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageViewCreateWithoutMessageInput, MessageViewUncheckedCreateWithoutMessageInput> | MessageViewCreateWithoutMessageInput[] | MessageViewUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageViewCreateOrConnectWithoutMessageInput | MessageViewCreateOrConnectWithoutMessageInput[]
    upsert?: MessageViewUpsertWithWhereUniqueWithoutMessageInput | MessageViewUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageViewCreateManyMessageInputEnvelope
    set?: MessageViewWhereUniqueInput | MessageViewWhereUniqueInput[]
    disconnect?: MessageViewWhereUniqueInput | MessageViewWhereUniqueInput[]
    delete?: MessageViewWhereUniqueInput | MessageViewWhereUniqueInput[]
    connect?: MessageViewWhereUniqueInput | MessageViewWhereUniqueInput[]
    update?: MessageViewUpdateWithWhereUniqueWithoutMessageInput | MessageViewUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageViewUpdateManyWithWhereWithoutMessageInput | MessageViewUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageViewScalarWhereInput | MessageViewScalarWhereInput[]
  }

  export type MessageDeliveryUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageDeliveryCreateWithoutMessageInput, MessageDeliveryUncheckedCreateWithoutMessageInput> | MessageDeliveryCreateWithoutMessageInput[] | MessageDeliveryUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageDeliveryCreateOrConnectWithoutMessageInput | MessageDeliveryCreateOrConnectWithoutMessageInput[]
    upsert?: MessageDeliveryUpsertWithWhereUniqueWithoutMessageInput | MessageDeliveryUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageDeliveryCreateManyMessageInputEnvelope
    set?: MessageDeliveryWhereUniqueInput | MessageDeliveryWhereUniqueInput[]
    disconnect?: MessageDeliveryWhereUniqueInput | MessageDeliveryWhereUniqueInput[]
    delete?: MessageDeliveryWhereUniqueInput | MessageDeliveryWhereUniqueInput[]
    connect?: MessageDeliveryWhereUniqueInput | MessageDeliveryWhereUniqueInput[]
    update?: MessageDeliveryUpdateWithWhereUniqueWithoutMessageInput | MessageDeliveryUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageDeliveryUpdateManyWithWhereWithoutMessageInput | MessageDeliveryUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageDeliveryScalarWhereInput | MessageDeliveryScalarWhereInput[]
  }

  export type MessageApprovalUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageApprovalCreateWithoutMessageInput, MessageApprovalUncheckedCreateWithoutMessageInput> | MessageApprovalCreateWithoutMessageInput[] | MessageApprovalUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageApprovalCreateOrConnectWithoutMessageInput | MessageApprovalCreateOrConnectWithoutMessageInput[]
    upsert?: MessageApprovalUpsertWithWhereUniqueWithoutMessageInput | MessageApprovalUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageApprovalCreateManyMessageInputEnvelope
    set?: MessageApprovalWhereUniqueInput | MessageApprovalWhereUniqueInput[]
    disconnect?: MessageApprovalWhereUniqueInput | MessageApprovalWhereUniqueInput[]
    delete?: MessageApprovalWhereUniqueInput | MessageApprovalWhereUniqueInput[]
    connect?: MessageApprovalWhereUniqueInput | MessageApprovalWhereUniqueInput[]
    update?: MessageApprovalUpdateWithWhereUniqueWithoutMessageInput | MessageApprovalUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageApprovalUpdateManyWithWhereWithoutMessageInput | MessageApprovalUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageApprovalScalarWhereInput | MessageApprovalScalarWhereInput[]
  }

  export type MessageAttachmentUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageAttachmentCreateWithoutMessageInput, MessageAttachmentUncheckedCreateWithoutMessageInput> | MessageAttachmentCreateWithoutMessageInput[] | MessageAttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageAttachmentCreateOrConnectWithoutMessageInput | MessageAttachmentCreateOrConnectWithoutMessageInput[]
    upsert?: MessageAttachmentUpsertWithWhereUniqueWithoutMessageInput | MessageAttachmentUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageAttachmentCreateManyMessageInputEnvelope
    set?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    disconnect?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    delete?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    connect?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    update?: MessageAttachmentUpdateWithWhereUniqueWithoutMessageInput | MessageAttachmentUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageAttachmentUpdateManyWithWhereWithoutMessageInput | MessageAttachmentUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageAttachmentScalarWhereInput | MessageAttachmentScalarWhereInput[]
  }

  export type MessageRevisionUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageRevisionCreateWithoutMessageInput, MessageRevisionUncheckedCreateWithoutMessageInput> | MessageRevisionCreateWithoutMessageInput[] | MessageRevisionUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageRevisionCreateOrConnectWithoutMessageInput | MessageRevisionCreateOrConnectWithoutMessageInput[]
    upsert?: MessageRevisionUpsertWithWhereUniqueWithoutMessageInput | MessageRevisionUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageRevisionCreateManyMessageInputEnvelope
    set?: MessageRevisionWhereUniqueInput | MessageRevisionWhereUniqueInput[]
    disconnect?: MessageRevisionWhereUniqueInput | MessageRevisionWhereUniqueInput[]
    delete?: MessageRevisionWhereUniqueInput | MessageRevisionWhereUniqueInput[]
    connect?: MessageRevisionWhereUniqueInput | MessageRevisionWhereUniqueInput[]
    update?: MessageRevisionUpdateWithWhereUniqueWithoutMessageInput | MessageRevisionUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageRevisionUpdateManyWithWhereWithoutMessageInput | MessageRevisionUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageRevisionScalarWhereInput | MessageRevisionScalarWhereInput[]
  }

  export type MessageViewUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageViewCreateWithoutMessageInput, MessageViewUncheckedCreateWithoutMessageInput> | MessageViewCreateWithoutMessageInput[] | MessageViewUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageViewCreateOrConnectWithoutMessageInput | MessageViewCreateOrConnectWithoutMessageInput[]
    upsert?: MessageViewUpsertWithWhereUniqueWithoutMessageInput | MessageViewUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageViewCreateManyMessageInputEnvelope
    set?: MessageViewWhereUniqueInput | MessageViewWhereUniqueInput[]
    disconnect?: MessageViewWhereUniqueInput | MessageViewWhereUniqueInput[]
    delete?: MessageViewWhereUniqueInput | MessageViewWhereUniqueInput[]
    connect?: MessageViewWhereUniqueInput | MessageViewWhereUniqueInput[]
    update?: MessageViewUpdateWithWhereUniqueWithoutMessageInput | MessageViewUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageViewUpdateManyWithWhereWithoutMessageInput | MessageViewUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageViewScalarWhereInput | MessageViewScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionsInput
    connect?: UserWhereUniqueInput
  }

  export type ChannelCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<ChannelCreateWithoutSubscriptionsInput, ChannelUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutSubscriptionsInput
    connect?: ChannelWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionsInput
    upsert?: UserUpsertWithoutSubscriptionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubscriptionsInput, UserUpdateWithoutSubscriptionsInput>, UserUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type ChannelUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<ChannelCreateWithoutSubscriptionsInput, ChannelUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutSubscriptionsInput
    upsert?: ChannelUpsertWithoutSubscriptionsInput
    connect?: ChannelWhereUniqueInput
    update?: XOR<XOR<ChannelUpdateToOneWithWhereWithoutSubscriptionsInput, ChannelUpdateWithoutSubscriptionsInput>, ChannelUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type MessageCreateNestedOneWithoutDeliveriesInput = {
    create?: XOR<MessageCreateWithoutDeliveriesInput, MessageUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: MessageCreateOrConnectWithoutDeliveriesInput
    connect?: MessageWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMessageDeliveriesInput = {
    create?: XOR<UserCreateWithoutMessageDeliveriesInput, UserUncheckedCreateWithoutMessageDeliveriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessageDeliveriesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumDeliveryStatusFieldUpdateOperationsInput = {
    set?: $Enums.DeliveryStatus
  }

  export type NullableEnumDeliveryMethodFieldUpdateOperationsInput = {
    set?: $Enums.DeliveryMethod | null
  }

  export type MessageUpdateOneRequiredWithoutDeliveriesNestedInput = {
    create?: XOR<MessageCreateWithoutDeliveriesInput, MessageUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: MessageCreateOrConnectWithoutDeliveriesInput
    upsert?: MessageUpsertWithoutDeliveriesInput
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutDeliveriesInput, MessageUpdateWithoutDeliveriesInput>, MessageUncheckedUpdateWithoutDeliveriesInput>
  }

  export type UserUpdateOneRequiredWithoutMessageDeliveriesNestedInput = {
    create?: XOR<UserCreateWithoutMessageDeliveriesInput, UserUncheckedCreateWithoutMessageDeliveriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessageDeliveriesInput
    upsert?: UserUpsertWithoutMessageDeliveriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessageDeliveriesInput, UserUpdateWithoutMessageDeliveriesInput>, UserUncheckedUpdateWithoutMessageDeliveriesInput>
  }

  export type ChannelCreateNestedOneWithoutInvitationLinksInput = {
    create?: XOR<ChannelCreateWithoutInvitationLinksInput, ChannelUncheckedCreateWithoutInvitationLinksInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutInvitationLinksInput
    connect?: ChannelWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInvitationLinksInput = {
    create?: XOR<UserCreateWithoutInvitationLinksInput, UserUncheckedCreateWithoutInvitationLinksInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitationLinksInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ChannelUpdateOneRequiredWithoutInvitationLinksNestedInput = {
    create?: XOR<ChannelCreateWithoutInvitationLinksInput, ChannelUncheckedCreateWithoutInvitationLinksInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutInvitationLinksInput
    upsert?: ChannelUpsertWithoutInvitationLinksInput
    connect?: ChannelWhereUniqueInput
    update?: XOR<XOR<ChannelUpdateToOneWithWhereWithoutInvitationLinksInput, ChannelUpdateWithoutInvitationLinksInput>, ChannelUncheckedUpdateWithoutInvitationLinksInput>
  }

  export type UserUpdateOneRequiredWithoutInvitationLinksNestedInput = {
    create?: XOR<UserCreateWithoutInvitationLinksInput, UserUncheckedCreateWithoutInvitationLinksInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitationLinksInput
    upsert?: UserUpsertWithoutInvitationLinksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvitationLinksInput, UserUpdateWithoutInvitationLinksInput>, UserUncheckedUpdateWithoutInvitationLinksInput>
  }

  export type ChannelCreateNestedOneWithoutQrCodesInput = {
    create?: XOR<ChannelCreateWithoutQrCodesInput, ChannelUncheckedCreateWithoutQrCodesInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutQrCodesInput
    connect?: ChannelWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutQrCodesInput = {
    create?: XOR<UserCreateWithoutQrCodesInput, UserUncheckedCreateWithoutQrCodesInput>
    connectOrCreate?: UserCreateOrConnectWithoutQrCodesInput
    connect?: UserWhereUniqueInput
  }

  export type ChannelUpdateOneRequiredWithoutQrCodesNestedInput = {
    create?: XOR<ChannelCreateWithoutQrCodesInput, ChannelUncheckedCreateWithoutQrCodesInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutQrCodesInput
    upsert?: ChannelUpsertWithoutQrCodesInput
    connect?: ChannelWhereUniqueInput
    update?: XOR<XOR<ChannelUpdateToOneWithWhereWithoutQrCodesInput, ChannelUpdateWithoutQrCodesInput>, ChannelUncheckedUpdateWithoutQrCodesInput>
  }

  export type UserUpdateOneRequiredWithoutQrCodesNestedInput = {
    create?: XOR<UserCreateWithoutQrCodesInput, UserUncheckedCreateWithoutQrCodesInput>
    connectOrCreate?: UserCreateOrConnectWithoutQrCodesInput
    upsert?: UserUpsertWithoutQrCodesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutQrCodesInput, UserUpdateWithoutQrCodesInput>, UserUncheckedUpdateWithoutQrCodesInput>
  }

  export type ChannelCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ChannelCreateWithoutOrganizationInput, ChannelUncheckedCreateWithoutOrganizationInput> | ChannelCreateWithoutOrganizationInput[] | ChannelUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutOrganizationInput | ChannelCreateOrConnectWithoutOrganizationInput[]
    createMany?: ChannelCreateManyOrganizationInputEnvelope
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
  }

  export type ChannelUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ChannelCreateWithoutOrganizationInput, ChannelUncheckedCreateWithoutOrganizationInput> | ChannelCreateWithoutOrganizationInput[] | ChannelUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutOrganizationInput | ChannelCreateOrConnectWithoutOrganizationInput[]
    createMany?: ChannelCreateManyOrganizationInputEnvelope
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
  }

  export type ChannelUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ChannelCreateWithoutOrganizationInput, ChannelUncheckedCreateWithoutOrganizationInput> | ChannelCreateWithoutOrganizationInput[] | ChannelUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutOrganizationInput | ChannelCreateOrConnectWithoutOrganizationInput[]
    upsert?: ChannelUpsertWithWhereUniqueWithoutOrganizationInput | ChannelUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ChannelCreateManyOrganizationInputEnvelope
    set?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    disconnect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    delete?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    update?: ChannelUpdateWithWhereUniqueWithoutOrganizationInput | ChannelUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ChannelUpdateManyWithWhereWithoutOrganizationInput | ChannelUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ChannelScalarWhereInput | ChannelScalarWhereInput[]
  }

  export type ChannelUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ChannelCreateWithoutOrganizationInput, ChannelUncheckedCreateWithoutOrganizationInput> | ChannelCreateWithoutOrganizationInput[] | ChannelUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutOrganizationInput | ChannelCreateOrConnectWithoutOrganizationInput[]
    upsert?: ChannelUpsertWithWhereUniqueWithoutOrganizationInput | ChannelUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ChannelCreateManyOrganizationInputEnvelope
    set?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    disconnect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    delete?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    update?: ChannelUpdateWithWhereUniqueWithoutOrganizationInput | ChannelUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ChannelUpdateManyWithWhereWithoutOrganizationInput | ChannelUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ChannelScalarWhereInput | ChannelScalarWhereInput[]
  }

  export type ChannelCreateNestedOneWithoutApproversInput = {
    create?: XOR<ChannelCreateWithoutApproversInput, ChannelUncheckedCreateWithoutApproversInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutApproversInput
    connect?: ChannelWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutApproverAssignmentsInput = {
    create?: XOR<UserCreateWithoutApproverAssignmentsInput, UserUncheckedCreateWithoutApproverAssignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApproverAssignmentsInput
    connect?: UserWhereUniqueInput
  }

  export type ChannelUpdateOneRequiredWithoutApproversNestedInput = {
    create?: XOR<ChannelCreateWithoutApproversInput, ChannelUncheckedCreateWithoutApproversInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutApproversInput
    upsert?: ChannelUpsertWithoutApproversInput
    connect?: ChannelWhereUniqueInput
    update?: XOR<XOR<ChannelUpdateToOneWithWhereWithoutApproversInput, ChannelUpdateWithoutApproversInput>, ChannelUncheckedUpdateWithoutApproversInput>
  }

  export type UserUpdateOneRequiredWithoutApproverAssignmentsNestedInput = {
    create?: XOR<UserCreateWithoutApproverAssignmentsInput, UserUncheckedCreateWithoutApproverAssignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApproverAssignmentsInput
    upsert?: UserUpsertWithoutApproverAssignmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApproverAssignmentsInput, UserUpdateWithoutApproverAssignmentsInput>, UserUncheckedUpdateWithoutApproverAssignmentsInput>
  }

  export type MessageCreateNestedOneWithoutApprovalsInput = {
    create?: XOR<MessageCreateWithoutApprovalsInput, MessageUncheckedCreateWithoutApprovalsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutApprovalsInput
    connect?: MessageWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMessageApprovalsInput = {
    create?: XOR<UserCreateWithoutMessageApprovalsInput, UserUncheckedCreateWithoutMessageApprovalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessageApprovalsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumApprovalStatusFieldUpdateOperationsInput = {
    set?: $Enums.ApprovalStatus
  }

  export type MessageUpdateOneRequiredWithoutApprovalsNestedInput = {
    create?: XOR<MessageCreateWithoutApprovalsInput, MessageUncheckedCreateWithoutApprovalsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutApprovalsInput
    upsert?: MessageUpsertWithoutApprovalsInput
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutApprovalsInput, MessageUpdateWithoutApprovalsInput>, MessageUncheckedUpdateWithoutApprovalsInput>
  }

  export type UserUpdateOneRequiredWithoutMessageApprovalsNestedInput = {
    create?: XOR<UserCreateWithoutMessageApprovalsInput, UserUncheckedCreateWithoutMessageApprovalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessageApprovalsInput
    upsert?: UserUpsertWithoutMessageApprovalsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessageApprovalsInput, UserUpdateWithoutMessageApprovalsInput>, UserUncheckedUpdateWithoutMessageApprovalsInput>
  }

  export type ChannelCreateNestedOneWithoutMessageCategoriesInput = {
    create?: XOR<ChannelCreateWithoutMessageCategoriesInput, ChannelUncheckedCreateWithoutMessageCategoriesInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutMessageCategoriesInput
    connect?: ChannelWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedCategoriesInput = {
    create?: XOR<UserCreateWithoutCreatedCategoriesInput, UserUncheckedCreateWithoutCreatedCategoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedCategoriesInput
    connect?: UserWhereUniqueInput
  }

  export type MessageCreateNestedManyWithoutCategoryInput = {
    create?: XOR<MessageCreateWithoutCategoryInput, MessageUncheckedCreateWithoutCategoryInput> | MessageCreateWithoutCategoryInput[] | MessageUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutCategoryInput | MessageCreateOrConnectWithoutCategoryInput[]
    createMany?: MessageCreateManyCategoryInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<MessageCreateWithoutCategoryInput, MessageUncheckedCreateWithoutCategoryInput> | MessageCreateWithoutCategoryInput[] | MessageUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutCategoryInput | MessageCreateOrConnectWithoutCategoryInput[]
    createMany?: MessageCreateManyCategoryInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type EnumCategoryScopeFieldUpdateOperationsInput = {
    set?: $Enums.CategoryScope
  }

  export type ChannelUpdateOneWithoutMessageCategoriesNestedInput = {
    create?: XOR<ChannelCreateWithoutMessageCategoriesInput, ChannelUncheckedCreateWithoutMessageCategoriesInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutMessageCategoriesInput
    upsert?: ChannelUpsertWithoutMessageCategoriesInput
    disconnect?: ChannelWhereInput | boolean
    delete?: ChannelWhereInput | boolean
    connect?: ChannelWhereUniqueInput
    update?: XOR<XOR<ChannelUpdateToOneWithWhereWithoutMessageCategoriesInput, ChannelUpdateWithoutMessageCategoriesInput>, ChannelUncheckedUpdateWithoutMessageCategoriesInput>
  }

  export type UserUpdateOneWithoutCreatedCategoriesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedCategoriesInput, UserUncheckedCreateWithoutCreatedCategoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedCategoriesInput
    upsert?: UserUpsertWithoutCreatedCategoriesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedCategoriesInput, UserUpdateWithoutCreatedCategoriesInput>, UserUncheckedUpdateWithoutCreatedCategoriesInput>
  }

  export type MessageUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<MessageCreateWithoutCategoryInput, MessageUncheckedCreateWithoutCategoryInput> | MessageCreateWithoutCategoryInput[] | MessageUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutCategoryInput | MessageCreateOrConnectWithoutCategoryInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutCategoryInput | MessageUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: MessageCreateManyCategoryInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutCategoryInput | MessageUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutCategoryInput | MessageUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<MessageCreateWithoutCategoryInput, MessageUncheckedCreateWithoutCategoryInput> | MessageCreateWithoutCategoryInput[] | MessageUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutCategoryInput | MessageCreateOrConnectWithoutCategoryInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutCategoryInput | MessageUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: MessageCreateManyCategoryInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutCategoryInput | MessageUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutCategoryInput | MessageUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<MessageCreateWithoutAttachmentsInput, MessageUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutAttachmentsInput
    connect?: MessageWhereUniqueInput
  }

  export type EnumAttachmentTypeFieldUpdateOperationsInput = {
    set?: $Enums.AttachmentType
  }

  export type MessageUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<MessageCreateWithoutAttachmentsInput, MessageUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutAttachmentsInput
    upsert?: MessageUpsertWithoutAttachmentsInput
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutAttachmentsInput, MessageUpdateWithoutAttachmentsInput>, MessageUncheckedUpdateWithoutAttachmentsInput>
  }

  export type MessageCreateNestedOneWithoutRevisionsInput = {
    create?: XOR<MessageCreateWithoutRevisionsInput, MessageUncheckedCreateWithoutRevisionsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutRevisionsInput
    connect?: MessageWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMessageRevisionsEditedInput = {
    create?: XOR<UserCreateWithoutMessageRevisionsEditedInput, UserUncheckedCreateWithoutMessageRevisionsEditedInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessageRevisionsEditedInput
    connect?: UserWhereUniqueInput
  }

  export type MessageUpdateOneRequiredWithoutRevisionsNestedInput = {
    create?: XOR<MessageCreateWithoutRevisionsInput, MessageUncheckedCreateWithoutRevisionsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutRevisionsInput
    upsert?: MessageUpsertWithoutRevisionsInput
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutRevisionsInput, MessageUpdateWithoutRevisionsInput>, MessageUncheckedUpdateWithoutRevisionsInput>
  }

  export type UserUpdateOneRequiredWithoutMessageRevisionsEditedNestedInput = {
    create?: XOR<UserCreateWithoutMessageRevisionsEditedInput, UserUncheckedCreateWithoutMessageRevisionsEditedInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessageRevisionsEditedInput
    upsert?: UserUpsertWithoutMessageRevisionsEditedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessageRevisionsEditedInput, UserUpdateWithoutMessageRevisionsEditedInput>, UserUncheckedUpdateWithoutMessageRevisionsEditedInput>
  }

  export type ChannelCreateNestedOneWithoutVerificationDocsInput = {
    create?: XOR<ChannelCreateWithoutVerificationDocsInput, ChannelUncheckedCreateWithoutVerificationDocsInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutVerificationDocsInput
    connect?: ChannelWhereUniqueInput
  }

  export type ChannelUpdateOneRequiredWithoutVerificationDocsNestedInput = {
    create?: XOR<ChannelCreateWithoutVerificationDocsInput, ChannelUncheckedCreateWithoutVerificationDocsInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutVerificationDocsInput
    upsert?: ChannelUpsertWithoutVerificationDocsInput
    connect?: ChannelWhereUniqueInput
    update?: XOR<XOR<ChannelUpdateToOneWithWhereWithoutVerificationDocsInput, ChannelUpdateWithoutVerificationDocsInput>, ChannelUncheckedUpdateWithoutVerificationDocsInput>
  }

  export type UserCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    upsert?: UserUpsertWithoutProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProfileInput, UserUpdateWithoutProfileInput>, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserCreateNestedOneWithoutMessagingSettingsInput = {
    create?: XOR<UserCreateWithoutMessagingSettingsInput, UserUncheckedCreateWithoutMessagingSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagingSettingsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumMessagingPlatformFieldUpdateOperationsInput = {
    set?: $Enums.MessagingPlatform
  }

  export type UserUpdateOneRequiredWithoutMessagingSettingsNestedInput = {
    create?: XOR<UserCreateWithoutMessagingSettingsInput, UserUncheckedCreateWithoutMessagingSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagingSettingsInput
    upsert?: UserUpsertWithoutMessagingSettingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessagingSettingsInput, UserUpdateWithoutMessagingSettingsInput>, UserUncheckedUpdateWithoutMessagingSettingsInput>
  }

  export type ChannelCategoryAssignmentCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ChannelCategoryAssignmentCreateWithoutCategoryInput, ChannelCategoryAssignmentUncheckedCreateWithoutCategoryInput> | ChannelCategoryAssignmentCreateWithoutCategoryInput[] | ChannelCategoryAssignmentUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ChannelCategoryAssignmentCreateOrConnectWithoutCategoryInput | ChannelCategoryAssignmentCreateOrConnectWithoutCategoryInput[]
    createMany?: ChannelCategoryAssignmentCreateManyCategoryInputEnvelope
    connect?: ChannelCategoryAssignmentWhereUniqueInput | ChannelCategoryAssignmentWhereUniqueInput[]
  }

  export type ChannelCategoryAssignmentUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ChannelCategoryAssignmentCreateWithoutCategoryInput, ChannelCategoryAssignmentUncheckedCreateWithoutCategoryInput> | ChannelCategoryAssignmentCreateWithoutCategoryInput[] | ChannelCategoryAssignmentUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ChannelCategoryAssignmentCreateOrConnectWithoutCategoryInput | ChannelCategoryAssignmentCreateOrConnectWithoutCategoryInput[]
    createMany?: ChannelCategoryAssignmentCreateManyCategoryInputEnvelope
    connect?: ChannelCategoryAssignmentWhereUniqueInput | ChannelCategoryAssignmentWhereUniqueInput[]
  }

  export type ChannelCategoryAssignmentUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ChannelCategoryAssignmentCreateWithoutCategoryInput, ChannelCategoryAssignmentUncheckedCreateWithoutCategoryInput> | ChannelCategoryAssignmentCreateWithoutCategoryInput[] | ChannelCategoryAssignmentUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ChannelCategoryAssignmentCreateOrConnectWithoutCategoryInput | ChannelCategoryAssignmentCreateOrConnectWithoutCategoryInput[]
    upsert?: ChannelCategoryAssignmentUpsertWithWhereUniqueWithoutCategoryInput | ChannelCategoryAssignmentUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ChannelCategoryAssignmentCreateManyCategoryInputEnvelope
    set?: ChannelCategoryAssignmentWhereUniqueInput | ChannelCategoryAssignmentWhereUniqueInput[]
    disconnect?: ChannelCategoryAssignmentWhereUniqueInput | ChannelCategoryAssignmentWhereUniqueInput[]
    delete?: ChannelCategoryAssignmentWhereUniqueInput | ChannelCategoryAssignmentWhereUniqueInput[]
    connect?: ChannelCategoryAssignmentWhereUniqueInput | ChannelCategoryAssignmentWhereUniqueInput[]
    update?: ChannelCategoryAssignmentUpdateWithWhereUniqueWithoutCategoryInput | ChannelCategoryAssignmentUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ChannelCategoryAssignmentUpdateManyWithWhereWithoutCategoryInput | ChannelCategoryAssignmentUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ChannelCategoryAssignmentScalarWhereInput | ChannelCategoryAssignmentScalarWhereInput[]
  }

  export type ChannelCategoryAssignmentUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ChannelCategoryAssignmentCreateWithoutCategoryInput, ChannelCategoryAssignmentUncheckedCreateWithoutCategoryInput> | ChannelCategoryAssignmentCreateWithoutCategoryInput[] | ChannelCategoryAssignmentUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ChannelCategoryAssignmentCreateOrConnectWithoutCategoryInput | ChannelCategoryAssignmentCreateOrConnectWithoutCategoryInput[]
    upsert?: ChannelCategoryAssignmentUpsertWithWhereUniqueWithoutCategoryInput | ChannelCategoryAssignmentUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ChannelCategoryAssignmentCreateManyCategoryInputEnvelope
    set?: ChannelCategoryAssignmentWhereUniqueInput | ChannelCategoryAssignmentWhereUniqueInput[]
    disconnect?: ChannelCategoryAssignmentWhereUniqueInput | ChannelCategoryAssignmentWhereUniqueInput[]
    delete?: ChannelCategoryAssignmentWhereUniqueInput | ChannelCategoryAssignmentWhereUniqueInput[]
    connect?: ChannelCategoryAssignmentWhereUniqueInput | ChannelCategoryAssignmentWhereUniqueInput[]
    update?: ChannelCategoryAssignmentUpdateWithWhereUniqueWithoutCategoryInput | ChannelCategoryAssignmentUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ChannelCategoryAssignmentUpdateManyWithWhereWithoutCategoryInput | ChannelCategoryAssignmentUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ChannelCategoryAssignmentScalarWhereInput | ChannelCategoryAssignmentScalarWhereInput[]
  }

  export type ChannelCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<ChannelCreateWithoutCategoriesInput, ChannelUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutCategoriesInput
    connect?: ChannelWhereUniqueInput
  }

  export type ChannelCategoryCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<ChannelCategoryCreateWithoutAssignmentsInput, ChannelCategoryUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: ChannelCategoryCreateOrConnectWithoutAssignmentsInput
    connect?: ChannelCategoryWhereUniqueInput
  }

  export type ChannelUpdateOneRequiredWithoutCategoriesNestedInput = {
    create?: XOR<ChannelCreateWithoutCategoriesInput, ChannelUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutCategoriesInput
    upsert?: ChannelUpsertWithoutCategoriesInput
    connect?: ChannelWhereUniqueInput
    update?: XOR<XOR<ChannelUpdateToOneWithWhereWithoutCategoriesInput, ChannelUpdateWithoutCategoriesInput>, ChannelUncheckedUpdateWithoutCategoriesInput>
  }

  export type ChannelCategoryUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<ChannelCategoryCreateWithoutAssignmentsInput, ChannelCategoryUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: ChannelCategoryCreateOrConnectWithoutAssignmentsInput
    upsert?: ChannelCategoryUpsertWithoutAssignmentsInput
    connect?: ChannelCategoryWhereUniqueInput
    update?: XOR<XOR<ChannelCategoryUpdateToOneWithWhereWithoutAssignmentsInput, ChannelCategoryUpdateWithoutAssignmentsInput>, ChannelCategoryUncheckedUpdateWithoutAssignmentsInput>
  }

  export type MessageCreateNestedOneWithoutViewsInput = {
    create?: XOR<MessageCreateWithoutViewsInput, MessageUncheckedCreateWithoutViewsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutViewsInput
    connect?: MessageWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMessageViewsInput = {
    create?: XOR<UserCreateWithoutMessageViewsInput, UserUncheckedCreateWithoutMessageViewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessageViewsInput
    connect?: UserWhereUniqueInput
  }

  export type MessageUpdateOneRequiredWithoutViewsNestedInput = {
    create?: XOR<MessageCreateWithoutViewsInput, MessageUncheckedCreateWithoutViewsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutViewsInput
    upsert?: MessageUpsertWithoutViewsInput
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutViewsInput, MessageUpdateWithoutViewsInput>, MessageUncheckedUpdateWithoutViewsInput>
  }

  export type UserUpdateOneWithoutMessageViewsNestedInput = {
    create?: XOR<UserCreateWithoutMessageViewsInput, UserUncheckedCreateWithoutMessageViewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessageViewsInput
    upsert?: UserUpsertWithoutMessageViewsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessageViewsInput, UserUpdateWithoutMessageViewsInput>, UserUncheckedUpdateWithoutMessageViewsInput>
  }

  export type ChannelCreateNestedOneWithoutVisitsInput = {
    create?: XOR<ChannelCreateWithoutVisitsInput, ChannelUncheckedCreateWithoutVisitsInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutVisitsInput
    connect?: ChannelWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutChannelVisitsInput = {
    create?: XOR<UserCreateWithoutChannelVisitsInput, UserUncheckedCreateWithoutChannelVisitsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChannelVisitsInput
    connect?: UserWhereUniqueInput
  }

  export type ChannelUpdateOneRequiredWithoutVisitsNestedInput = {
    create?: XOR<ChannelCreateWithoutVisitsInput, ChannelUncheckedCreateWithoutVisitsInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutVisitsInput
    upsert?: ChannelUpsertWithoutVisitsInput
    connect?: ChannelWhereUniqueInput
    update?: XOR<XOR<ChannelUpdateToOneWithWhereWithoutVisitsInput, ChannelUpdateWithoutVisitsInput>, ChannelUncheckedUpdateWithoutVisitsInput>
  }

  export type UserUpdateOneWithoutChannelVisitsNestedInput = {
    create?: XOR<UserCreateWithoutChannelVisitsInput, UserUncheckedCreateWithoutChannelVisitsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChannelVisitsInput
    upsert?: UserUpsertWithoutChannelVisitsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChannelVisitsInput, UserUpdateWithoutChannelVisitsInput>, UserUncheckedUpdateWithoutChannelVisitsInput>
  }

  export type UserCreateNestedOneWithoutCreatedFormsInput = {
    create?: XOR<UserCreateWithoutCreatedFormsInput, UserUncheckedCreateWithoutCreatedFormsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedFormsInput
    connect?: UserWhereUniqueInput
  }

  export type FormFieldCreateNestedManyWithoutFormInput = {
    create?: XOR<FormFieldCreateWithoutFormInput, FormFieldUncheckedCreateWithoutFormInput> | FormFieldCreateWithoutFormInput[] | FormFieldUncheckedCreateWithoutFormInput[]
    connectOrCreate?: FormFieldCreateOrConnectWithoutFormInput | FormFieldCreateOrConnectWithoutFormInput[]
    createMany?: FormFieldCreateManyFormInputEnvelope
    connect?: FormFieldWhereUniqueInput | FormFieldWhereUniqueInput[]
  }

  export type FormSubmissionCreateNestedManyWithoutFormInput = {
    create?: XOR<FormSubmissionCreateWithoutFormInput, FormSubmissionUncheckedCreateWithoutFormInput> | FormSubmissionCreateWithoutFormInput[] | FormSubmissionUncheckedCreateWithoutFormInput[]
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutFormInput | FormSubmissionCreateOrConnectWithoutFormInput[]
    createMany?: FormSubmissionCreateManyFormInputEnvelope
    connect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
  }

  export type FormFieldUncheckedCreateNestedManyWithoutFormInput = {
    create?: XOR<FormFieldCreateWithoutFormInput, FormFieldUncheckedCreateWithoutFormInput> | FormFieldCreateWithoutFormInput[] | FormFieldUncheckedCreateWithoutFormInput[]
    connectOrCreate?: FormFieldCreateOrConnectWithoutFormInput | FormFieldCreateOrConnectWithoutFormInput[]
    createMany?: FormFieldCreateManyFormInputEnvelope
    connect?: FormFieldWhereUniqueInput | FormFieldWhereUniqueInput[]
  }

  export type FormSubmissionUncheckedCreateNestedManyWithoutFormInput = {
    create?: XOR<FormSubmissionCreateWithoutFormInput, FormSubmissionUncheckedCreateWithoutFormInput> | FormSubmissionCreateWithoutFormInput[] | FormSubmissionUncheckedCreateWithoutFormInput[]
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutFormInput | FormSubmissionCreateOrConnectWithoutFormInput[]
    createMany?: FormSubmissionCreateManyFormInputEnvelope
    connect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutCreatedFormsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedFormsInput, UserUncheckedCreateWithoutCreatedFormsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedFormsInput
    upsert?: UserUpsertWithoutCreatedFormsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedFormsInput, UserUpdateWithoutCreatedFormsInput>, UserUncheckedUpdateWithoutCreatedFormsInput>
  }

  export type FormFieldUpdateManyWithoutFormNestedInput = {
    create?: XOR<FormFieldCreateWithoutFormInput, FormFieldUncheckedCreateWithoutFormInput> | FormFieldCreateWithoutFormInput[] | FormFieldUncheckedCreateWithoutFormInput[]
    connectOrCreate?: FormFieldCreateOrConnectWithoutFormInput | FormFieldCreateOrConnectWithoutFormInput[]
    upsert?: FormFieldUpsertWithWhereUniqueWithoutFormInput | FormFieldUpsertWithWhereUniqueWithoutFormInput[]
    createMany?: FormFieldCreateManyFormInputEnvelope
    set?: FormFieldWhereUniqueInput | FormFieldWhereUniqueInput[]
    disconnect?: FormFieldWhereUniqueInput | FormFieldWhereUniqueInput[]
    delete?: FormFieldWhereUniqueInput | FormFieldWhereUniqueInput[]
    connect?: FormFieldWhereUniqueInput | FormFieldWhereUniqueInput[]
    update?: FormFieldUpdateWithWhereUniqueWithoutFormInput | FormFieldUpdateWithWhereUniqueWithoutFormInput[]
    updateMany?: FormFieldUpdateManyWithWhereWithoutFormInput | FormFieldUpdateManyWithWhereWithoutFormInput[]
    deleteMany?: FormFieldScalarWhereInput | FormFieldScalarWhereInput[]
  }

  export type FormSubmissionUpdateManyWithoutFormNestedInput = {
    create?: XOR<FormSubmissionCreateWithoutFormInput, FormSubmissionUncheckedCreateWithoutFormInput> | FormSubmissionCreateWithoutFormInput[] | FormSubmissionUncheckedCreateWithoutFormInput[]
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutFormInput | FormSubmissionCreateOrConnectWithoutFormInput[]
    upsert?: FormSubmissionUpsertWithWhereUniqueWithoutFormInput | FormSubmissionUpsertWithWhereUniqueWithoutFormInput[]
    createMany?: FormSubmissionCreateManyFormInputEnvelope
    set?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    disconnect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    delete?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    connect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    update?: FormSubmissionUpdateWithWhereUniqueWithoutFormInput | FormSubmissionUpdateWithWhereUniqueWithoutFormInput[]
    updateMany?: FormSubmissionUpdateManyWithWhereWithoutFormInput | FormSubmissionUpdateManyWithWhereWithoutFormInput[]
    deleteMany?: FormSubmissionScalarWhereInput | FormSubmissionScalarWhereInput[]
  }

  export type FormFieldUncheckedUpdateManyWithoutFormNestedInput = {
    create?: XOR<FormFieldCreateWithoutFormInput, FormFieldUncheckedCreateWithoutFormInput> | FormFieldCreateWithoutFormInput[] | FormFieldUncheckedCreateWithoutFormInput[]
    connectOrCreate?: FormFieldCreateOrConnectWithoutFormInput | FormFieldCreateOrConnectWithoutFormInput[]
    upsert?: FormFieldUpsertWithWhereUniqueWithoutFormInput | FormFieldUpsertWithWhereUniqueWithoutFormInput[]
    createMany?: FormFieldCreateManyFormInputEnvelope
    set?: FormFieldWhereUniqueInput | FormFieldWhereUniqueInput[]
    disconnect?: FormFieldWhereUniqueInput | FormFieldWhereUniqueInput[]
    delete?: FormFieldWhereUniqueInput | FormFieldWhereUniqueInput[]
    connect?: FormFieldWhereUniqueInput | FormFieldWhereUniqueInput[]
    update?: FormFieldUpdateWithWhereUniqueWithoutFormInput | FormFieldUpdateWithWhereUniqueWithoutFormInput[]
    updateMany?: FormFieldUpdateManyWithWhereWithoutFormInput | FormFieldUpdateManyWithWhereWithoutFormInput[]
    deleteMany?: FormFieldScalarWhereInput | FormFieldScalarWhereInput[]
  }

  export type FormSubmissionUncheckedUpdateManyWithoutFormNestedInput = {
    create?: XOR<FormSubmissionCreateWithoutFormInput, FormSubmissionUncheckedCreateWithoutFormInput> | FormSubmissionCreateWithoutFormInput[] | FormSubmissionUncheckedCreateWithoutFormInput[]
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutFormInput | FormSubmissionCreateOrConnectWithoutFormInput[]
    upsert?: FormSubmissionUpsertWithWhereUniqueWithoutFormInput | FormSubmissionUpsertWithWhereUniqueWithoutFormInput[]
    createMany?: FormSubmissionCreateManyFormInputEnvelope
    set?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    disconnect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    delete?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    connect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    update?: FormSubmissionUpdateWithWhereUniqueWithoutFormInput | FormSubmissionUpdateWithWhereUniqueWithoutFormInput[]
    updateMany?: FormSubmissionUpdateManyWithWhereWithoutFormInput | FormSubmissionUpdateManyWithWhereWithoutFormInput[]
    deleteMany?: FormSubmissionScalarWhereInput | FormSubmissionScalarWhereInput[]
  }

  export type FormCreateNestedOneWithoutFieldsInput = {
    create?: XOR<FormCreateWithoutFieldsInput, FormUncheckedCreateWithoutFieldsInput>
    connectOrCreate?: FormCreateOrConnectWithoutFieldsInput
    connect?: FormWhereUniqueInput
  }

  export type FormUpdateOneRequiredWithoutFieldsNestedInput = {
    create?: XOR<FormCreateWithoutFieldsInput, FormUncheckedCreateWithoutFieldsInput>
    connectOrCreate?: FormCreateOrConnectWithoutFieldsInput
    upsert?: FormUpsertWithoutFieldsInput
    connect?: FormWhereUniqueInput
    update?: XOR<XOR<FormUpdateToOneWithWhereWithoutFieldsInput, FormUpdateWithoutFieldsInput>, FormUncheckedUpdateWithoutFieldsInput>
  }

  export type FormCreateNestedOneWithoutSubmissionsInput = {
    create?: XOR<FormCreateWithoutSubmissionsInput, FormUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: FormCreateOrConnectWithoutSubmissionsInput
    connect?: FormWhereUniqueInput
  }

  export type FormUpdateOneRequiredWithoutSubmissionsNestedInput = {
    create?: XOR<FormCreateWithoutSubmissionsInput, FormUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: FormCreateOrConnectWithoutSubmissionsInput
    upsert?: FormUpsertWithoutSubmissionsInput
    connect?: FormWhereUniqueInput
    update?: XOR<XOR<FormUpdateToOneWithWhereWithoutSubmissionsInput, FormUpdateWithoutSubmissionsInput>, FormUncheckedUpdateWithoutSubmissionsInput>
  }

  export type UserCreateNestedOneWithoutOrganizedEventsInput = {
    create?: XOR<UserCreateWithoutOrganizedEventsInput, UserUncheckedCreateWithoutOrganizedEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrganizedEventsInput
    connect?: UserWhereUniqueInput
  }

  export type EventZoneCreateNestedManyWithoutEventInput = {
    create?: XOR<EventZoneCreateWithoutEventInput, EventZoneUncheckedCreateWithoutEventInput> | EventZoneCreateWithoutEventInput[] | EventZoneUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventZoneCreateOrConnectWithoutEventInput | EventZoneCreateOrConnectWithoutEventInput[]
    createMany?: EventZoneCreateManyEventInputEnvelope
    connect?: EventZoneWhereUniqueInput | EventZoneWhereUniqueInput[]
  }

  export type EventSeatCreateNestedManyWithoutEventInput = {
    create?: XOR<EventSeatCreateWithoutEventInput, EventSeatUncheckedCreateWithoutEventInput> | EventSeatCreateWithoutEventInput[] | EventSeatUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventSeatCreateOrConnectWithoutEventInput | EventSeatCreateOrConnectWithoutEventInput[]
    createMany?: EventSeatCreateManyEventInputEnvelope
    connect?: EventSeatWhereUniqueInput | EventSeatWhereUniqueInput[]
  }

  export type TicketCreateNestedManyWithoutEventInput = {
    create?: XOR<TicketCreateWithoutEventInput, TicketUncheckedCreateWithoutEventInput> | TicketCreateWithoutEventInput[] | TicketUncheckedCreateWithoutEventInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutEventInput | TicketCreateOrConnectWithoutEventInput[]
    createMany?: TicketCreateManyEventInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type EventZoneUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<EventZoneCreateWithoutEventInput, EventZoneUncheckedCreateWithoutEventInput> | EventZoneCreateWithoutEventInput[] | EventZoneUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventZoneCreateOrConnectWithoutEventInput | EventZoneCreateOrConnectWithoutEventInput[]
    createMany?: EventZoneCreateManyEventInputEnvelope
    connect?: EventZoneWhereUniqueInput | EventZoneWhereUniqueInput[]
  }

  export type EventSeatUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<EventSeatCreateWithoutEventInput, EventSeatUncheckedCreateWithoutEventInput> | EventSeatCreateWithoutEventInput[] | EventSeatUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventSeatCreateOrConnectWithoutEventInput | EventSeatCreateOrConnectWithoutEventInput[]
    createMany?: EventSeatCreateManyEventInputEnvelope
    connect?: EventSeatWhereUniqueInput | EventSeatWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<TicketCreateWithoutEventInput, TicketUncheckedCreateWithoutEventInput> | TicketCreateWithoutEventInput[] | TicketUncheckedCreateWithoutEventInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutEventInput | TicketCreateOrConnectWithoutEventInput[]
    createMany?: TicketCreateManyEventInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type EnumEventStatusFieldUpdateOperationsInput = {
    set?: $Enums.EventStatus
  }

  export type UserUpdateOneRequiredWithoutOrganizedEventsNestedInput = {
    create?: XOR<UserCreateWithoutOrganizedEventsInput, UserUncheckedCreateWithoutOrganizedEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrganizedEventsInput
    upsert?: UserUpsertWithoutOrganizedEventsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrganizedEventsInput, UserUpdateWithoutOrganizedEventsInput>, UserUncheckedUpdateWithoutOrganizedEventsInput>
  }

  export type EventZoneUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventZoneCreateWithoutEventInput, EventZoneUncheckedCreateWithoutEventInput> | EventZoneCreateWithoutEventInput[] | EventZoneUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventZoneCreateOrConnectWithoutEventInput | EventZoneCreateOrConnectWithoutEventInput[]
    upsert?: EventZoneUpsertWithWhereUniqueWithoutEventInput | EventZoneUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventZoneCreateManyEventInputEnvelope
    set?: EventZoneWhereUniqueInput | EventZoneWhereUniqueInput[]
    disconnect?: EventZoneWhereUniqueInput | EventZoneWhereUniqueInput[]
    delete?: EventZoneWhereUniqueInput | EventZoneWhereUniqueInput[]
    connect?: EventZoneWhereUniqueInput | EventZoneWhereUniqueInput[]
    update?: EventZoneUpdateWithWhereUniqueWithoutEventInput | EventZoneUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventZoneUpdateManyWithWhereWithoutEventInput | EventZoneUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventZoneScalarWhereInput | EventZoneScalarWhereInput[]
  }

  export type EventSeatUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventSeatCreateWithoutEventInput, EventSeatUncheckedCreateWithoutEventInput> | EventSeatCreateWithoutEventInput[] | EventSeatUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventSeatCreateOrConnectWithoutEventInput | EventSeatCreateOrConnectWithoutEventInput[]
    upsert?: EventSeatUpsertWithWhereUniqueWithoutEventInput | EventSeatUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventSeatCreateManyEventInputEnvelope
    set?: EventSeatWhereUniqueInput | EventSeatWhereUniqueInput[]
    disconnect?: EventSeatWhereUniqueInput | EventSeatWhereUniqueInput[]
    delete?: EventSeatWhereUniqueInput | EventSeatWhereUniqueInput[]
    connect?: EventSeatWhereUniqueInput | EventSeatWhereUniqueInput[]
    update?: EventSeatUpdateWithWhereUniqueWithoutEventInput | EventSeatUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventSeatUpdateManyWithWhereWithoutEventInput | EventSeatUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventSeatScalarWhereInput | EventSeatScalarWhereInput[]
  }

  export type TicketUpdateManyWithoutEventNestedInput = {
    create?: XOR<TicketCreateWithoutEventInput, TicketUncheckedCreateWithoutEventInput> | TicketCreateWithoutEventInput[] | TicketUncheckedCreateWithoutEventInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutEventInput | TicketCreateOrConnectWithoutEventInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutEventInput | TicketUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: TicketCreateManyEventInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutEventInput | TicketUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutEventInput | TicketUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type EventZoneUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventZoneCreateWithoutEventInput, EventZoneUncheckedCreateWithoutEventInput> | EventZoneCreateWithoutEventInput[] | EventZoneUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventZoneCreateOrConnectWithoutEventInput | EventZoneCreateOrConnectWithoutEventInput[]
    upsert?: EventZoneUpsertWithWhereUniqueWithoutEventInput | EventZoneUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventZoneCreateManyEventInputEnvelope
    set?: EventZoneWhereUniqueInput | EventZoneWhereUniqueInput[]
    disconnect?: EventZoneWhereUniqueInput | EventZoneWhereUniqueInput[]
    delete?: EventZoneWhereUniqueInput | EventZoneWhereUniqueInput[]
    connect?: EventZoneWhereUniqueInput | EventZoneWhereUniqueInput[]
    update?: EventZoneUpdateWithWhereUniqueWithoutEventInput | EventZoneUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventZoneUpdateManyWithWhereWithoutEventInput | EventZoneUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventZoneScalarWhereInput | EventZoneScalarWhereInput[]
  }

  export type EventSeatUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventSeatCreateWithoutEventInput, EventSeatUncheckedCreateWithoutEventInput> | EventSeatCreateWithoutEventInput[] | EventSeatUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventSeatCreateOrConnectWithoutEventInput | EventSeatCreateOrConnectWithoutEventInput[]
    upsert?: EventSeatUpsertWithWhereUniqueWithoutEventInput | EventSeatUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventSeatCreateManyEventInputEnvelope
    set?: EventSeatWhereUniqueInput | EventSeatWhereUniqueInput[]
    disconnect?: EventSeatWhereUniqueInput | EventSeatWhereUniqueInput[]
    delete?: EventSeatWhereUniqueInput | EventSeatWhereUniqueInput[]
    connect?: EventSeatWhereUniqueInput | EventSeatWhereUniqueInput[]
    update?: EventSeatUpdateWithWhereUniqueWithoutEventInput | EventSeatUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventSeatUpdateManyWithWhereWithoutEventInput | EventSeatUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventSeatScalarWhereInput | EventSeatScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<TicketCreateWithoutEventInput, TicketUncheckedCreateWithoutEventInput> | TicketCreateWithoutEventInput[] | TicketUncheckedCreateWithoutEventInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutEventInput | TicketCreateOrConnectWithoutEventInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutEventInput | TicketUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: TicketCreateManyEventInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutEventInput | TicketUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutEventInput | TicketUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type EventCreateNestedOneWithoutZonesInput = {
    create?: XOR<EventCreateWithoutZonesInput, EventUncheckedCreateWithoutZonesInput>
    connectOrCreate?: EventCreateOrConnectWithoutZonesInput
    connect?: EventWhereUniqueInput
  }

  export type EventSeatCreateNestedManyWithoutZoneInput = {
    create?: XOR<EventSeatCreateWithoutZoneInput, EventSeatUncheckedCreateWithoutZoneInput> | EventSeatCreateWithoutZoneInput[] | EventSeatUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: EventSeatCreateOrConnectWithoutZoneInput | EventSeatCreateOrConnectWithoutZoneInput[]
    createMany?: EventSeatCreateManyZoneInputEnvelope
    connect?: EventSeatWhereUniqueInput | EventSeatWhereUniqueInput[]
  }

  export type TicketCreateNestedManyWithoutZoneInput = {
    create?: XOR<TicketCreateWithoutZoneInput, TicketUncheckedCreateWithoutZoneInput> | TicketCreateWithoutZoneInput[] | TicketUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutZoneInput | TicketCreateOrConnectWithoutZoneInput[]
    createMany?: TicketCreateManyZoneInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type EventSeatUncheckedCreateNestedManyWithoutZoneInput = {
    create?: XOR<EventSeatCreateWithoutZoneInput, EventSeatUncheckedCreateWithoutZoneInput> | EventSeatCreateWithoutZoneInput[] | EventSeatUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: EventSeatCreateOrConnectWithoutZoneInput | EventSeatCreateOrConnectWithoutZoneInput[]
    createMany?: EventSeatCreateManyZoneInputEnvelope
    connect?: EventSeatWhereUniqueInput | EventSeatWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutZoneInput = {
    create?: XOR<TicketCreateWithoutZoneInput, TicketUncheckedCreateWithoutZoneInput> | TicketCreateWithoutZoneInput[] | TicketUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutZoneInput | TicketCreateOrConnectWithoutZoneInput[]
    createMany?: TicketCreateManyZoneInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumZoneTypeFieldUpdateOperationsInput = {
    set?: $Enums.ZoneType
  }

  export type EventUpdateOneRequiredWithoutZonesNestedInput = {
    create?: XOR<EventCreateWithoutZonesInput, EventUncheckedCreateWithoutZonesInput>
    connectOrCreate?: EventCreateOrConnectWithoutZonesInput
    upsert?: EventUpsertWithoutZonesInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutZonesInput, EventUpdateWithoutZonesInput>, EventUncheckedUpdateWithoutZonesInput>
  }

  export type EventSeatUpdateManyWithoutZoneNestedInput = {
    create?: XOR<EventSeatCreateWithoutZoneInput, EventSeatUncheckedCreateWithoutZoneInput> | EventSeatCreateWithoutZoneInput[] | EventSeatUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: EventSeatCreateOrConnectWithoutZoneInput | EventSeatCreateOrConnectWithoutZoneInput[]
    upsert?: EventSeatUpsertWithWhereUniqueWithoutZoneInput | EventSeatUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: EventSeatCreateManyZoneInputEnvelope
    set?: EventSeatWhereUniqueInput | EventSeatWhereUniqueInput[]
    disconnect?: EventSeatWhereUniqueInput | EventSeatWhereUniqueInput[]
    delete?: EventSeatWhereUniqueInput | EventSeatWhereUniqueInput[]
    connect?: EventSeatWhereUniqueInput | EventSeatWhereUniqueInput[]
    update?: EventSeatUpdateWithWhereUniqueWithoutZoneInput | EventSeatUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: EventSeatUpdateManyWithWhereWithoutZoneInput | EventSeatUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: EventSeatScalarWhereInput | EventSeatScalarWhereInput[]
  }

  export type TicketUpdateManyWithoutZoneNestedInput = {
    create?: XOR<TicketCreateWithoutZoneInput, TicketUncheckedCreateWithoutZoneInput> | TicketCreateWithoutZoneInput[] | TicketUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutZoneInput | TicketCreateOrConnectWithoutZoneInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutZoneInput | TicketUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: TicketCreateManyZoneInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutZoneInput | TicketUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutZoneInput | TicketUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type EventSeatUncheckedUpdateManyWithoutZoneNestedInput = {
    create?: XOR<EventSeatCreateWithoutZoneInput, EventSeatUncheckedCreateWithoutZoneInput> | EventSeatCreateWithoutZoneInput[] | EventSeatUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: EventSeatCreateOrConnectWithoutZoneInput | EventSeatCreateOrConnectWithoutZoneInput[]
    upsert?: EventSeatUpsertWithWhereUniqueWithoutZoneInput | EventSeatUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: EventSeatCreateManyZoneInputEnvelope
    set?: EventSeatWhereUniqueInput | EventSeatWhereUniqueInput[]
    disconnect?: EventSeatWhereUniqueInput | EventSeatWhereUniqueInput[]
    delete?: EventSeatWhereUniqueInput | EventSeatWhereUniqueInput[]
    connect?: EventSeatWhereUniqueInput | EventSeatWhereUniqueInput[]
    update?: EventSeatUpdateWithWhereUniqueWithoutZoneInput | EventSeatUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: EventSeatUpdateManyWithWhereWithoutZoneInput | EventSeatUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: EventSeatScalarWhereInput | EventSeatScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutZoneNestedInput = {
    create?: XOR<TicketCreateWithoutZoneInput, TicketUncheckedCreateWithoutZoneInput> | TicketCreateWithoutZoneInput[] | TicketUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutZoneInput | TicketCreateOrConnectWithoutZoneInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutZoneInput | TicketUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: TicketCreateManyZoneInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutZoneInput | TicketUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutZoneInput | TicketUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type EventCreateNestedOneWithoutSeatsInput = {
    create?: XOR<EventCreateWithoutSeatsInput, EventUncheckedCreateWithoutSeatsInput>
    connectOrCreate?: EventCreateOrConnectWithoutSeatsInput
    connect?: EventWhereUniqueInput
  }

  export type EventZoneCreateNestedOneWithoutSeatsInput = {
    create?: XOR<EventZoneCreateWithoutSeatsInput, EventZoneUncheckedCreateWithoutSeatsInput>
    connectOrCreate?: EventZoneCreateOrConnectWithoutSeatsInput
    connect?: EventZoneWhereUniqueInput
  }

  export type TicketCreateNestedManyWithoutSeatInput = {
    create?: XOR<TicketCreateWithoutSeatInput, TicketUncheckedCreateWithoutSeatInput> | TicketCreateWithoutSeatInput[] | TicketUncheckedCreateWithoutSeatInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutSeatInput | TicketCreateOrConnectWithoutSeatInput[]
    createMany?: TicketCreateManySeatInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutSeatInput = {
    create?: XOR<TicketCreateWithoutSeatInput, TicketUncheckedCreateWithoutSeatInput> | TicketCreateWithoutSeatInput[] | TicketUncheckedCreateWithoutSeatInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutSeatInput | TicketCreateOrConnectWithoutSeatInput[]
    createMany?: TicketCreateManySeatInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type EnumSeatStatusFieldUpdateOperationsInput = {
    set?: $Enums.SeatStatus
  }

  export type EnumSeatTypeFieldUpdateOperationsInput = {
    set?: $Enums.SeatType
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EventUpdateOneRequiredWithoutSeatsNestedInput = {
    create?: XOR<EventCreateWithoutSeatsInput, EventUncheckedCreateWithoutSeatsInput>
    connectOrCreate?: EventCreateOrConnectWithoutSeatsInput
    upsert?: EventUpsertWithoutSeatsInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutSeatsInput, EventUpdateWithoutSeatsInput>, EventUncheckedUpdateWithoutSeatsInput>
  }

  export type EventZoneUpdateOneRequiredWithoutSeatsNestedInput = {
    create?: XOR<EventZoneCreateWithoutSeatsInput, EventZoneUncheckedCreateWithoutSeatsInput>
    connectOrCreate?: EventZoneCreateOrConnectWithoutSeatsInput
    upsert?: EventZoneUpsertWithoutSeatsInput
    connect?: EventZoneWhereUniqueInput
    update?: XOR<XOR<EventZoneUpdateToOneWithWhereWithoutSeatsInput, EventZoneUpdateWithoutSeatsInput>, EventZoneUncheckedUpdateWithoutSeatsInput>
  }

  export type TicketUpdateManyWithoutSeatNestedInput = {
    create?: XOR<TicketCreateWithoutSeatInput, TicketUncheckedCreateWithoutSeatInput> | TicketCreateWithoutSeatInput[] | TicketUncheckedCreateWithoutSeatInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutSeatInput | TicketCreateOrConnectWithoutSeatInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutSeatInput | TicketUpsertWithWhereUniqueWithoutSeatInput[]
    createMany?: TicketCreateManySeatInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutSeatInput | TicketUpdateWithWhereUniqueWithoutSeatInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutSeatInput | TicketUpdateManyWithWhereWithoutSeatInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutSeatNestedInput = {
    create?: XOR<TicketCreateWithoutSeatInput, TicketUncheckedCreateWithoutSeatInput> | TicketCreateWithoutSeatInput[] | TicketUncheckedCreateWithoutSeatInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutSeatInput | TicketCreateOrConnectWithoutSeatInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutSeatInput | TicketUpsertWithWhereUniqueWithoutSeatInput[]
    createMany?: TicketCreateManySeatInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutSeatInput | TicketUpdateWithWhereUniqueWithoutSeatInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutSeatInput | TicketUpdateManyWithWhereWithoutSeatInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type EventCreateNestedOneWithoutTicketsInput = {
    create?: XOR<EventCreateWithoutTicketsInput, EventUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: EventCreateOrConnectWithoutTicketsInput
    connect?: EventWhereUniqueInput
  }

  export type EventZoneCreateNestedOneWithoutTicketsInput = {
    create?: XOR<EventZoneCreateWithoutTicketsInput, EventZoneUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: EventZoneCreateOrConnectWithoutTicketsInput
    connect?: EventZoneWhereUniqueInput
  }

  export type EventSeatCreateNestedOneWithoutTicketsInput = {
    create?: XOR<EventSeatCreateWithoutTicketsInput, EventSeatUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: EventSeatCreateOrConnectWithoutTicketsInput
    connect?: EventSeatWhereUniqueInput
  }

  export type EnumTicketStatusFieldUpdateOperationsInput = {
    set?: $Enums.TicketStatus
  }

  export type EventUpdateOneRequiredWithoutTicketsNestedInput = {
    create?: XOR<EventCreateWithoutTicketsInput, EventUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: EventCreateOrConnectWithoutTicketsInput
    upsert?: EventUpsertWithoutTicketsInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutTicketsInput, EventUpdateWithoutTicketsInput>, EventUncheckedUpdateWithoutTicketsInput>
  }

  export type EventZoneUpdateOneRequiredWithoutTicketsNestedInput = {
    create?: XOR<EventZoneCreateWithoutTicketsInput, EventZoneUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: EventZoneCreateOrConnectWithoutTicketsInput
    upsert?: EventZoneUpsertWithoutTicketsInput
    connect?: EventZoneWhereUniqueInput
    update?: XOR<XOR<EventZoneUpdateToOneWithWhereWithoutTicketsInput, EventZoneUpdateWithoutTicketsInput>, EventZoneUncheckedUpdateWithoutTicketsInput>
  }

  export type EventSeatUpdateOneWithoutTicketsNestedInput = {
    create?: XOR<EventSeatCreateWithoutTicketsInput, EventSeatUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: EventSeatCreateOrConnectWithoutTicketsInput
    upsert?: EventSeatUpsertWithoutTicketsInput
    disconnect?: EventSeatWhereInput | boolean
    delete?: EventSeatWhereInput | boolean
    connect?: EventSeatWhereUniqueInput
    update?: XOR<XOR<EventSeatUpdateToOneWithWhereWithoutTicketsInput, EventSeatUpdateWithoutTicketsInput>, EventSeatUncheckedUpdateWithoutTicketsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumVerificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[]
    notIn?: $Enums.VerificationStatus[]
    not?: NestedEnumVerificationStatusFilter<$PrismaModel> | $Enums.VerificationStatus
  }

  export type NestedEnumApprovalPolicyFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalPolicy | EnumApprovalPolicyFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalPolicy[]
    notIn?: $Enums.ApprovalPolicy[]
    not?: NestedEnumApprovalPolicyFilter<$PrismaModel> | $Enums.ApprovalPolicy
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumVerificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[]
    notIn?: $Enums.VerificationStatus[]
    not?: NestedEnumVerificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.VerificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVerificationStatusFilter<$PrismaModel>
    _max?: NestedEnumVerificationStatusFilter<$PrismaModel>
  }

  export type NestedEnumApprovalPolicyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalPolicy | EnumApprovalPolicyFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalPolicy[]
    notIn?: $Enums.ApprovalPolicy[]
    not?: NestedEnumApprovalPolicyWithAggregatesFilter<$PrismaModel> | $Enums.ApprovalPolicy
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApprovalPolicyFilter<$PrismaModel>
    _max?: NestedEnumApprovalPolicyFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumMessagePriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.MessagePriority | EnumMessagePriorityFieldRefInput<$PrismaModel>
    in?: $Enums.MessagePriority[]
    notIn?: $Enums.MessagePriority[]
    not?: NestedEnumMessagePriorityFilter<$PrismaModel> | $Enums.MessagePriority
  }

  export type NestedEnumApprovalPolicyNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalPolicy | EnumApprovalPolicyFieldRefInput<$PrismaModel> | null
    in?: $Enums.ApprovalPolicy[] | null
    notIn?: $Enums.ApprovalPolicy[] | null
    not?: NestedEnumApprovalPolicyNullableFilter<$PrismaModel> | $Enums.ApprovalPolicy | null
  }

  export type NestedEnumDeliveryMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryMethod | EnumDeliveryMethodFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryMethod[]
    notIn?: $Enums.DeliveryMethod[]
    not?: NestedEnumDeliveryMethodFilter<$PrismaModel> | $Enums.DeliveryMethod
  }

  export type NestedEnumMessageStateFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageState | EnumMessageStateFieldRefInput<$PrismaModel>
    in?: $Enums.MessageState[]
    notIn?: $Enums.MessageState[]
    not?: NestedEnumMessageStateFilter<$PrismaModel> | $Enums.MessageState
  }

  export type NestedEnumMessagePriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessagePriority | EnumMessagePriorityFieldRefInput<$PrismaModel>
    in?: $Enums.MessagePriority[]
    notIn?: $Enums.MessagePriority[]
    not?: NestedEnumMessagePriorityWithAggregatesFilter<$PrismaModel> | $Enums.MessagePriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessagePriorityFilter<$PrismaModel>
    _max?: NestedEnumMessagePriorityFilter<$PrismaModel>
  }

  export type NestedEnumApprovalPolicyNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalPolicy | EnumApprovalPolicyFieldRefInput<$PrismaModel> | null
    in?: $Enums.ApprovalPolicy[] | null
    notIn?: $Enums.ApprovalPolicy[] | null
    not?: NestedEnumApprovalPolicyNullableWithAggregatesFilter<$PrismaModel> | $Enums.ApprovalPolicy | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumApprovalPolicyNullableFilter<$PrismaModel>
    _max?: NestedEnumApprovalPolicyNullableFilter<$PrismaModel>
  }

  export type NestedEnumDeliveryMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryMethod | EnumDeliveryMethodFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryMethod[]
    notIn?: $Enums.DeliveryMethod[]
    not?: NestedEnumDeliveryMethodWithAggregatesFilter<$PrismaModel> | $Enums.DeliveryMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeliveryMethodFilter<$PrismaModel>
    _max?: NestedEnumDeliveryMethodFilter<$PrismaModel>
  }

  export type NestedEnumMessageStateWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageState | EnumMessageStateFieldRefInput<$PrismaModel>
    in?: $Enums.MessageState[]
    notIn?: $Enums.MessageState[]
    not?: NestedEnumMessageStateWithAggregatesFilter<$PrismaModel> | $Enums.MessageState
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageStateFilter<$PrismaModel>
    _max?: NestedEnumMessageStateFilter<$PrismaModel>
  }

  export type NestedEnumDeliveryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryStatus | EnumDeliveryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryStatus[]
    notIn?: $Enums.DeliveryStatus[]
    not?: NestedEnumDeliveryStatusFilter<$PrismaModel> | $Enums.DeliveryStatus
  }

  export type NestedEnumDeliveryMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryMethod | EnumDeliveryMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.DeliveryMethod[] | null
    notIn?: $Enums.DeliveryMethod[] | null
    not?: NestedEnumDeliveryMethodNullableFilter<$PrismaModel> | $Enums.DeliveryMethod | null
  }

  export type NestedEnumDeliveryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryStatus | EnumDeliveryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryStatus[]
    notIn?: $Enums.DeliveryStatus[]
    not?: NestedEnumDeliveryStatusWithAggregatesFilter<$PrismaModel> | $Enums.DeliveryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeliveryStatusFilter<$PrismaModel>
    _max?: NestedEnumDeliveryStatusFilter<$PrismaModel>
  }

  export type NestedEnumDeliveryMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryMethod | EnumDeliveryMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.DeliveryMethod[] | null
    notIn?: $Enums.DeliveryMethod[] | null
    not?: NestedEnumDeliveryMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.DeliveryMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDeliveryMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumDeliveryMethodNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumApprovalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[]
    notIn?: $Enums.ApprovalStatus[]
    not?: NestedEnumApprovalStatusFilter<$PrismaModel> | $Enums.ApprovalStatus
  }

  export type NestedEnumApprovalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[]
    notIn?: $Enums.ApprovalStatus[]
    not?: NestedEnumApprovalStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApprovalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApprovalStatusFilter<$PrismaModel>
    _max?: NestedEnumApprovalStatusFilter<$PrismaModel>
  }

  export type NestedEnumCategoryScopeFilter<$PrismaModel = never> = {
    equals?: $Enums.CategoryScope | EnumCategoryScopeFieldRefInput<$PrismaModel>
    in?: $Enums.CategoryScope[]
    notIn?: $Enums.CategoryScope[]
    not?: NestedEnumCategoryScopeFilter<$PrismaModel> | $Enums.CategoryScope
  }

  export type NestedEnumCategoryScopeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CategoryScope | EnumCategoryScopeFieldRefInput<$PrismaModel>
    in?: $Enums.CategoryScope[]
    notIn?: $Enums.CategoryScope[]
    not?: NestedEnumCategoryScopeWithAggregatesFilter<$PrismaModel> | $Enums.CategoryScope
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCategoryScopeFilter<$PrismaModel>
    _max?: NestedEnumCategoryScopeFilter<$PrismaModel>
  }

  export type NestedEnumAttachmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AttachmentType | EnumAttachmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AttachmentType[]
    notIn?: $Enums.AttachmentType[]
    not?: NestedEnumAttachmentTypeFilter<$PrismaModel> | $Enums.AttachmentType
  }

  export type NestedEnumAttachmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttachmentType | EnumAttachmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AttachmentType[]
    notIn?: $Enums.AttachmentType[]
    not?: NestedEnumAttachmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.AttachmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttachmentTypeFilter<$PrismaModel>
    _max?: NestedEnumAttachmentTypeFilter<$PrismaModel>
  }

  export type NestedEnumMessagingPlatformFilter<$PrismaModel = never> = {
    equals?: $Enums.MessagingPlatform | EnumMessagingPlatformFieldRefInput<$PrismaModel>
    in?: $Enums.MessagingPlatform[]
    notIn?: $Enums.MessagingPlatform[]
    not?: NestedEnumMessagingPlatformFilter<$PrismaModel> | $Enums.MessagingPlatform
  }

  export type NestedEnumMessagingPlatformWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessagingPlatform | EnumMessagingPlatformFieldRefInput<$PrismaModel>
    in?: $Enums.MessagingPlatform[]
    notIn?: $Enums.MessagingPlatform[]
    not?: NestedEnumMessagingPlatformWithAggregatesFilter<$PrismaModel> | $Enums.MessagingPlatform
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessagingPlatformFilter<$PrismaModel>
    _max?: NestedEnumMessagingPlatformFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumEventStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EventStatus | EnumEventStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EventStatus[]
    notIn?: $Enums.EventStatus[]
    not?: NestedEnumEventStatusFilter<$PrismaModel> | $Enums.EventStatus
  }

  export type NestedEnumEventStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventStatus | EnumEventStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EventStatus[]
    notIn?: $Enums.EventStatus[]
    not?: NestedEnumEventStatusWithAggregatesFilter<$PrismaModel> | $Enums.EventStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventStatusFilter<$PrismaModel>
    _max?: NestedEnumEventStatusFilter<$PrismaModel>
  }

  export type NestedEnumZoneTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ZoneType | EnumZoneTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ZoneType[]
    notIn?: $Enums.ZoneType[]
    not?: NestedEnumZoneTypeFilter<$PrismaModel> | $Enums.ZoneType
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumZoneTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ZoneType | EnumZoneTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ZoneType[]
    notIn?: $Enums.ZoneType[]
    not?: NestedEnumZoneTypeWithAggregatesFilter<$PrismaModel> | $Enums.ZoneType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumZoneTypeFilter<$PrismaModel>
    _max?: NestedEnumZoneTypeFilter<$PrismaModel>
  }

  export type NestedEnumSeatStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SeatStatus | EnumSeatStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SeatStatus[]
    notIn?: $Enums.SeatStatus[]
    not?: NestedEnumSeatStatusFilter<$PrismaModel> | $Enums.SeatStatus
  }

  export type NestedEnumSeatTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SeatType | EnumSeatTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SeatType[]
    notIn?: $Enums.SeatType[]
    not?: NestedEnumSeatTypeFilter<$PrismaModel> | $Enums.SeatType
  }

  export type NestedEnumSeatStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SeatStatus | EnumSeatStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SeatStatus[]
    notIn?: $Enums.SeatStatus[]
    not?: NestedEnumSeatStatusWithAggregatesFilter<$PrismaModel> | $Enums.SeatStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSeatStatusFilter<$PrismaModel>
    _max?: NestedEnumSeatStatusFilter<$PrismaModel>
  }

  export type NestedEnumSeatTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SeatType | EnumSeatTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SeatType[]
    notIn?: $Enums.SeatType[]
    not?: NestedEnumSeatTypeWithAggregatesFilter<$PrismaModel> | $Enums.SeatType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSeatTypeFilter<$PrismaModel>
    _max?: NestedEnumSeatTypeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumTicketStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[]
    notIn?: $Enums.TicketStatus[]
    not?: NestedEnumTicketStatusFilter<$PrismaModel> | $Enums.TicketStatus
  }

  export type NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[]
    notIn?: $Enums.TicketStatus[]
    not?: NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel> | $Enums.TicketStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketStatusFilter<$PrismaModel>
    _max?: NestedEnumTicketStatusFilter<$PrismaModel>
  }

  export type ChannelCreateWithoutOwnerInput = {
    id?: string
    title: string
    description?: string | null
    websiteUrl?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: string | null
    icon?: string
    isPublic?: boolean
    isHidden?: boolean
    searchExactOnly?: boolean
    passwordHash?: string | null
    referenceCode?: string | null
    verificationStatus?: $Enums.VerificationStatus
    approvalPolicy?: $Enums.ApprovalPolicy
    memberCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutChannelsInput
    parent?: ChannelCreateNestedOneWithoutSubchannelsInput
    subchannels?: ChannelCreateNestedManyWithoutParentInput
    messages?: MessageCreateNestedManyWithoutChannelInput
    subscriptions?: ChannelSubscriptionCreateNestedManyWithoutChannelInput
    invitationLinks?: InvitationLinkCreateNestedManyWithoutChannelInput
    qrCodes?: QrCodeCreateNestedManyWithoutChannelInput
    approvers?: ChannelApproverCreateNestedManyWithoutChannelInput
    verificationDocs?: ChannelVerificationDocumentCreateNestedManyWithoutChannelInput
    categories?: ChannelCategoryAssignmentCreateNestedManyWithoutChannelInput
    messageCategories?: MessageCategoryCreateNestedManyWithoutChannelInput
    visits?: ChannelVisitCreateNestedManyWithoutChannelInput
  }

  export type ChannelUncheckedCreateWithoutOwnerInput = {
    id?: string
    title: string
    description?: string | null
    websiteUrl?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: string | null
    icon?: string
    parentId?: string | null
    organizationId: string
    isPublic?: boolean
    isHidden?: boolean
    searchExactOnly?: boolean
    passwordHash?: string | null
    referenceCode?: string | null
    verificationStatus?: $Enums.VerificationStatus
    approvalPolicy?: $Enums.ApprovalPolicy
    memberCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    subchannels?: ChannelUncheckedCreateNestedManyWithoutParentInput
    messages?: MessageUncheckedCreateNestedManyWithoutChannelInput
    subscriptions?: ChannelSubscriptionUncheckedCreateNestedManyWithoutChannelInput
    invitationLinks?: InvitationLinkUncheckedCreateNestedManyWithoutChannelInput
    qrCodes?: QrCodeUncheckedCreateNestedManyWithoutChannelInput
    approvers?: ChannelApproverUncheckedCreateNestedManyWithoutChannelInput
    verificationDocs?: ChannelVerificationDocumentUncheckedCreateNestedManyWithoutChannelInput
    categories?: ChannelCategoryAssignmentUncheckedCreateNestedManyWithoutChannelInput
    messageCategories?: MessageCategoryUncheckedCreateNestedManyWithoutChannelInput
    visits?: ChannelVisitUncheckedCreateNestedManyWithoutChannelInput
  }

  export type ChannelCreateOrConnectWithoutOwnerInput = {
    where: ChannelWhereUniqueInput
    create: XOR<ChannelCreateWithoutOwnerInput, ChannelUncheckedCreateWithoutOwnerInput>
  }

  export type ChannelCreateManyOwnerInputEnvelope = {
    data: ChannelCreateManyOwnerInput | ChannelCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutSenderInput = {
    id?: string
    content: string
    durationSeconds?: number
    expiresAt?: Date | string | null
    isEmergency?: boolean
    isImmediate?: boolean
    priority?: $Enums.MessagePriority
    approvalOverride?: $Enums.ApprovalPolicy | null
    approvalOverrideSetAt?: Date | string | null
    deliveryMethod?: $Enums.DeliveryMethod
    eventAt?: Date | string | null
    publishedAt?: Date | string | null
    state?: $Enums.MessageState
    createdAt?: Date | string
    updatedAt?: Date | string
    channel: ChannelCreateNestedOneWithoutMessagesInput
    category: MessageCategoryCreateNestedOneWithoutMessagesInput
    overrideSetter?: UserCreateNestedOneWithoutMessagesOverrideSetInput
    deliveries?: MessageDeliveryCreateNestedManyWithoutMessageInput
    approvals?: MessageApprovalCreateNestedManyWithoutMessageInput
    attachments?: MessageAttachmentCreateNestedManyWithoutMessageInput
    revisions?: MessageRevisionCreateNestedManyWithoutMessageInput
    views?: MessageViewCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: string
    channelId: string
    categoryId: string
    content: string
    durationSeconds?: number
    expiresAt?: Date | string | null
    isEmergency?: boolean
    isImmediate?: boolean
    priority?: $Enums.MessagePriority
    approvalOverride?: $Enums.ApprovalPolicy | null
    approvalOverrideSetBy?: string | null
    approvalOverrideSetAt?: Date | string | null
    deliveryMethod?: $Enums.DeliveryMethod
    eventAt?: Date | string | null
    publishedAt?: Date | string | null
    state?: $Enums.MessageState
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveries?: MessageDeliveryUncheckedCreateNestedManyWithoutMessageInput
    approvals?: MessageApprovalUncheckedCreateNestedManyWithoutMessageInput
    attachments?: MessageAttachmentUncheckedCreateNestedManyWithoutMessageInput
    revisions?: MessageRevisionUncheckedCreateNestedManyWithoutMessageInput
    views?: MessageViewUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutOverrideSetterInput = {
    id?: string
    content: string
    durationSeconds?: number
    expiresAt?: Date | string | null
    isEmergency?: boolean
    isImmediate?: boolean
    priority?: $Enums.MessagePriority
    approvalOverride?: $Enums.ApprovalPolicy | null
    approvalOverrideSetAt?: Date | string | null
    deliveryMethod?: $Enums.DeliveryMethod
    eventAt?: Date | string | null
    publishedAt?: Date | string | null
    state?: $Enums.MessageState
    createdAt?: Date | string
    updatedAt?: Date | string
    channel: ChannelCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutMessagesSentInput
    category: MessageCategoryCreateNestedOneWithoutMessagesInput
    deliveries?: MessageDeliveryCreateNestedManyWithoutMessageInput
    approvals?: MessageApprovalCreateNestedManyWithoutMessageInput
    attachments?: MessageAttachmentCreateNestedManyWithoutMessageInput
    revisions?: MessageRevisionCreateNestedManyWithoutMessageInput
    views?: MessageViewCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutOverrideSetterInput = {
    id?: string
    channelId: string
    senderId: string
    categoryId: string
    content: string
    durationSeconds?: number
    expiresAt?: Date | string | null
    isEmergency?: boolean
    isImmediate?: boolean
    priority?: $Enums.MessagePriority
    approvalOverride?: $Enums.ApprovalPolicy | null
    approvalOverrideSetAt?: Date | string | null
    deliveryMethod?: $Enums.DeliveryMethod
    eventAt?: Date | string | null
    publishedAt?: Date | string | null
    state?: $Enums.MessageState
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveries?: MessageDeliveryUncheckedCreateNestedManyWithoutMessageInput
    approvals?: MessageApprovalUncheckedCreateNestedManyWithoutMessageInput
    attachments?: MessageAttachmentUncheckedCreateNestedManyWithoutMessageInput
    revisions?: MessageRevisionUncheckedCreateNestedManyWithoutMessageInput
    views?: MessageViewUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutOverrideSetterInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutOverrideSetterInput, MessageUncheckedCreateWithoutOverrideSetterInput>
  }

  export type MessageCreateManyOverrideSetterInputEnvelope = {
    data: MessageCreateManyOverrideSetterInput | MessageCreateManyOverrideSetterInput[]
    skipDuplicates?: boolean
  }

  export type ChannelSubscriptionCreateWithoutUserInput = {
    id?: string
    subscribedAt?: Date | string
    isActive?: boolean
    isFavorite?: boolean
    receiveMessages?: boolean
    channel: ChannelCreateNestedOneWithoutSubscriptionsInput
  }

  export type ChannelSubscriptionUncheckedCreateWithoutUserInput = {
    id?: string
    channelId: string
    subscribedAt?: Date | string
    isActive?: boolean
    isFavorite?: boolean
    receiveMessages?: boolean
  }

  export type ChannelSubscriptionCreateOrConnectWithoutUserInput = {
    where: ChannelSubscriptionWhereUniqueInput
    create: XOR<ChannelSubscriptionCreateWithoutUserInput, ChannelSubscriptionUncheckedCreateWithoutUserInput>
  }

  export type ChannelSubscriptionCreateManyUserInputEnvelope = {
    data: ChannelSubscriptionCreateManyUserInput | ChannelSubscriptionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InvitationLinkCreateWithoutCreatorInput = {
    id?: string
    linkCode: string
    expiresAt?: Date | string | null
    maxUses?: number | null
    currentUses?: number
    isActive?: boolean
    createdAt?: Date | string
    channel: ChannelCreateNestedOneWithoutInvitationLinksInput
  }

  export type InvitationLinkUncheckedCreateWithoutCreatorInput = {
    id?: string
    channelId: string
    linkCode: string
    expiresAt?: Date | string | null
    maxUses?: number | null
    currentUses?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type InvitationLinkCreateOrConnectWithoutCreatorInput = {
    where: InvitationLinkWhereUniqueInput
    create: XOR<InvitationLinkCreateWithoutCreatorInput, InvitationLinkUncheckedCreateWithoutCreatorInput>
  }

  export type InvitationLinkCreateManyCreatorInputEnvelope = {
    data: InvitationLinkCreateManyCreatorInput | InvitationLinkCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type QrCodeCreateWithoutCreatorInput = {
    id?: string
    qrData: string
    expiresAt?: Date | string | null
    scanCount?: number
    isActive?: boolean
    createdAt?: Date | string
    channel: ChannelCreateNestedOneWithoutQrCodesInput
  }

  export type QrCodeUncheckedCreateWithoutCreatorInput = {
    id?: string
    channelId: string
    qrData: string
    expiresAt?: Date | string | null
    scanCount?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type QrCodeCreateOrConnectWithoutCreatorInput = {
    where: QrCodeWhereUniqueInput
    create: XOR<QrCodeCreateWithoutCreatorInput, QrCodeUncheckedCreateWithoutCreatorInput>
  }

  export type QrCodeCreateManyCreatorInputEnvelope = {
    data: QrCodeCreateManyCreatorInput | QrCodeCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type MessageDeliveryCreateWithoutUserInput = {
    id?: string
    deliveryStatus?: $Enums.DeliveryStatus
    deliveryMethod?: $Enums.DeliveryMethod | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
    message: MessageCreateNestedOneWithoutDeliveriesInput
  }

  export type MessageDeliveryUncheckedCreateWithoutUserInput = {
    id?: string
    messageId: string
    deliveryStatus?: $Enums.DeliveryStatus
    deliveryMethod?: $Enums.DeliveryMethod | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MessageDeliveryCreateOrConnectWithoutUserInput = {
    where: MessageDeliveryWhereUniqueInput
    create: XOR<MessageDeliveryCreateWithoutUserInput, MessageDeliveryUncheckedCreateWithoutUserInput>
  }

  export type MessageDeliveryCreateManyUserInputEnvelope = {
    data: MessageDeliveryCreateManyUserInput | MessageDeliveryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MessageApprovalCreateWithoutApproverInput = {
    id?: string
    status?: $Enums.ApprovalStatus
    decidedAt?: Date | string | null
    message: MessageCreateNestedOneWithoutApprovalsInput
  }

  export type MessageApprovalUncheckedCreateWithoutApproverInput = {
    id?: string
    messageId: string
    status?: $Enums.ApprovalStatus
    decidedAt?: Date | string | null
  }

  export type MessageApprovalCreateOrConnectWithoutApproverInput = {
    where: MessageApprovalWhereUniqueInput
    create: XOR<MessageApprovalCreateWithoutApproverInput, MessageApprovalUncheckedCreateWithoutApproverInput>
  }

  export type MessageApprovalCreateManyApproverInputEnvelope = {
    data: MessageApprovalCreateManyApproverInput | MessageApprovalCreateManyApproverInput[]
    skipDuplicates?: boolean
  }

  export type MessageRevisionCreateWithoutEditorInput = {
    id?: string
    previousContent: string
    previousCategoryId?: string | null
    previousPriority: $Enums.MessagePriority
    previousIsImmediate: boolean
    previousDeliveryMethod: $Enums.DeliveryMethod
    changedAt?: Date | string
    message: MessageCreateNestedOneWithoutRevisionsInput
  }

  export type MessageRevisionUncheckedCreateWithoutEditorInput = {
    id?: string
    messageId: string
    previousContent: string
    previousCategoryId?: string | null
    previousPriority: $Enums.MessagePriority
    previousIsImmediate: boolean
    previousDeliveryMethod: $Enums.DeliveryMethod
    changedAt?: Date | string
  }

  export type MessageRevisionCreateOrConnectWithoutEditorInput = {
    where: MessageRevisionWhereUniqueInput
    create: XOR<MessageRevisionCreateWithoutEditorInput, MessageRevisionUncheckedCreateWithoutEditorInput>
  }

  export type MessageRevisionCreateManyEditorInputEnvelope = {
    data: MessageRevisionCreateManyEditorInput | MessageRevisionCreateManyEditorInput[]
    skipDuplicates?: boolean
  }

  export type UserProfileCreateWithoutUserInput = {
    id?: string
    country?: string | null
    department?: string | null
    city?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserProfileUncheckedCreateWithoutUserInput = {
    id?: string
    country?: string | null
    department?: string | null
    city?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserProfileCreateOrConnectWithoutUserInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
  }

  export type UserMessagingSettingCreateWithoutUserInput = {
    id?: string
    platform: $Enums.MessagingPlatform
    handle?: string | null
    isEnabled?: boolean
    verified?: boolean
    createdAt?: Date | string
  }

  export type UserMessagingSettingUncheckedCreateWithoutUserInput = {
    id?: string
    platform: $Enums.MessagingPlatform
    handle?: string | null
    isEnabled?: boolean
    verified?: boolean
    createdAt?: Date | string
  }

  export type UserMessagingSettingCreateOrConnectWithoutUserInput = {
    where: UserMessagingSettingWhereUniqueInput
    create: XOR<UserMessagingSettingCreateWithoutUserInput, UserMessagingSettingUncheckedCreateWithoutUserInput>
  }

  export type UserMessagingSettingCreateManyUserInputEnvelope = {
    data: UserMessagingSettingCreateManyUserInput | UserMessagingSettingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ChannelApproverCreateWithoutUserInput = {
    id?: string
    isActive?: boolean
    removedAt?: Date | string | null
    removedBy?: string | null
    createdAt?: Date | string
    channel: ChannelCreateNestedOneWithoutApproversInput
  }

  export type ChannelApproverUncheckedCreateWithoutUserInput = {
    id?: string
    channelId: string
    isActive?: boolean
    removedAt?: Date | string | null
    removedBy?: string | null
    createdAt?: Date | string
  }

  export type ChannelApproverCreateOrConnectWithoutUserInput = {
    where: ChannelApproverWhereUniqueInput
    create: XOR<ChannelApproverCreateWithoutUserInput, ChannelApproverUncheckedCreateWithoutUserInput>
  }

  export type ChannelApproverCreateManyUserInputEnvelope = {
    data: ChannelApproverCreateManyUserInput | ChannelApproverCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MessageCategoryCreateWithoutCreatorInput = {
    id?: string
    name: string
    scope?: $Enums.CategoryScope
    createdAt?: Date | string
    channel?: ChannelCreateNestedOneWithoutMessageCategoriesInput
    messages?: MessageCreateNestedManyWithoutCategoryInput
  }

  export type MessageCategoryUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    scope?: $Enums.CategoryScope
    channelId?: string | null
    createdAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type MessageCategoryCreateOrConnectWithoutCreatorInput = {
    where: MessageCategoryWhereUniqueInput
    create: XOR<MessageCategoryCreateWithoutCreatorInput, MessageCategoryUncheckedCreateWithoutCreatorInput>
  }

  export type MessageCategoryCreateManyCreatorInputEnvelope = {
    data: MessageCategoryCreateManyCreatorInput | MessageCategoryCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type MessageViewCreateWithoutUserInput = {
    id?: string
    viewedAt?: Date | string
    message: MessageCreateNestedOneWithoutViewsInput
  }

  export type MessageViewUncheckedCreateWithoutUserInput = {
    id?: string
    messageId: string
    viewedAt?: Date | string
  }

  export type MessageViewCreateOrConnectWithoutUserInput = {
    where: MessageViewWhereUniqueInput
    create: XOR<MessageViewCreateWithoutUserInput, MessageViewUncheckedCreateWithoutUserInput>
  }

  export type MessageViewCreateManyUserInputEnvelope = {
    data: MessageViewCreateManyUserInput | MessageViewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ChannelVisitCreateWithoutUserInput = {
    id?: string
    visitedAt?: Date | string
    channel: ChannelCreateNestedOneWithoutVisitsInput
  }

  export type ChannelVisitUncheckedCreateWithoutUserInput = {
    id?: string
    channelId: string
    visitedAt?: Date | string
  }

  export type ChannelVisitCreateOrConnectWithoutUserInput = {
    where: ChannelVisitWhereUniqueInput
    create: XOR<ChannelVisitCreateWithoutUserInput, ChannelVisitUncheckedCreateWithoutUserInput>
  }

  export type ChannelVisitCreateManyUserInputEnvelope = {
    data: ChannelVisitCreateManyUserInput | ChannelVisitCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FormCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    slug: string
    headerContent?: string | null
    footerContent?: string | null
    successMessage?: string | null
    isActive?: boolean
    isPublished?: boolean
    wasPublished?: boolean
    isDeleted?: boolean
    collectUserInfo?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fields?: FormFieldCreateNestedManyWithoutFormInput
    submissions?: FormSubmissionCreateNestedManyWithoutFormInput
  }

  export type FormUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    slug: string
    headerContent?: string | null
    footerContent?: string | null
    successMessage?: string | null
    isActive?: boolean
    isPublished?: boolean
    wasPublished?: boolean
    isDeleted?: boolean
    collectUserInfo?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fields?: FormFieldUncheckedCreateNestedManyWithoutFormInput
    submissions?: FormSubmissionUncheckedCreateNestedManyWithoutFormInput
  }

  export type FormCreateOrConnectWithoutUserInput = {
    where: FormWhereUniqueInput
    create: XOR<FormCreateWithoutUserInput, FormUncheckedCreateWithoutUserInput>
  }

  export type FormCreateManyUserInputEnvelope = {
    data: FormCreateManyUserInput | FormCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EventCreateWithoutOrganizerInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    location: string
    imageUrl?: string | null
    status?: $Enums.EventStatus
    categories?: NullableJsonNullValueInput | InputJsonValue
    paymentInfo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    zones?: EventZoneCreateNestedManyWithoutEventInput
    seats?: EventSeatCreateNestedManyWithoutEventInput
    tickets?: TicketCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutOrganizerInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    location: string
    imageUrl?: string | null
    status?: $Enums.EventStatus
    categories?: NullableJsonNullValueInput | InputJsonValue
    paymentInfo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    zones?: EventZoneUncheckedCreateNestedManyWithoutEventInput
    seats?: EventSeatUncheckedCreateNestedManyWithoutEventInput
    tickets?: TicketUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutOrganizerInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutOrganizerInput, EventUncheckedCreateWithoutOrganizerInput>
  }

  export type EventCreateManyOrganizerInputEnvelope = {
    data: EventCreateManyOrganizerInput | EventCreateManyOrganizerInput[]
    skipDuplicates?: boolean
  }

  export type ChannelUpsertWithWhereUniqueWithoutOwnerInput = {
    where: ChannelWhereUniqueInput
    update: XOR<ChannelUpdateWithoutOwnerInput, ChannelUncheckedUpdateWithoutOwnerInput>
    create: XOR<ChannelCreateWithoutOwnerInput, ChannelUncheckedCreateWithoutOwnerInput>
  }

  export type ChannelUpdateWithWhereUniqueWithoutOwnerInput = {
    where: ChannelWhereUniqueInput
    data: XOR<ChannelUpdateWithoutOwnerInput, ChannelUncheckedUpdateWithoutOwnerInput>
  }

  export type ChannelUpdateManyWithWhereWithoutOwnerInput = {
    where: ChannelScalarWhereInput
    data: XOR<ChannelUpdateManyMutationInput, ChannelUncheckedUpdateManyWithoutOwnerInput>
  }

  export type ChannelScalarWhereInput = {
    AND?: ChannelScalarWhereInput | ChannelScalarWhereInput[]
    OR?: ChannelScalarWhereInput[]
    NOT?: ChannelScalarWhereInput | ChannelScalarWhereInput[]
    id?: StringFilter<"Channel"> | string
    title?: StringFilter<"Channel"> | string
    description?: StringNullableFilter<"Channel"> | string | null
    websiteUrl?: StringNullableFilter<"Channel"> | string | null
    socialLinks?: JsonNullableFilter<"Channel">
    logoUrl?: StringNullableFilter<"Channel"> | string | null
    icon?: StringFilter<"Channel"> | string
    parentId?: StringNullableFilter<"Channel"> | string | null
    ownerId?: StringFilter<"Channel"> | string
    organizationId?: StringFilter<"Channel"> | string
    isPublic?: BoolFilter<"Channel"> | boolean
    isHidden?: BoolFilter<"Channel"> | boolean
    searchExactOnly?: BoolFilter<"Channel"> | boolean
    passwordHash?: StringNullableFilter<"Channel"> | string | null
    referenceCode?: StringNullableFilter<"Channel"> | string | null
    verificationStatus?: EnumVerificationStatusFilter<"Channel"> | $Enums.VerificationStatus
    approvalPolicy?: EnumApprovalPolicyFilter<"Channel"> | $Enums.ApprovalPolicy
    memberCount?: IntFilter<"Channel"> | number
    createdAt?: DateTimeFilter<"Channel"> | Date | string
    updatedAt?: DateTimeFilter<"Channel"> | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    channelId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    categoryId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    durationSeconds?: IntFilter<"Message"> | number
    expiresAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    isEmergency?: BoolFilter<"Message"> | boolean
    isImmediate?: BoolFilter<"Message"> | boolean
    priority?: EnumMessagePriorityFilter<"Message"> | $Enums.MessagePriority
    approvalOverride?: EnumApprovalPolicyNullableFilter<"Message"> | $Enums.ApprovalPolicy | null
    approvalOverrideSetBy?: StringNullableFilter<"Message"> | string | null
    approvalOverrideSetAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    deliveryMethod?: EnumDeliveryMethodFilter<"Message"> | $Enums.DeliveryMethod
    eventAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    publishedAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    state?: EnumMessageStateFilter<"Message"> | $Enums.MessageState
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutOverrideSetterInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutOverrideSetterInput, MessageUncheckedUpdateWithoutOverrideSetterInput>
    create: XOR<MessageCreateWithoutOverrideSetterInput, MessageUncheckedCreateWithoutOverrideSetterInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutOverrideSetterInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutOverrideSetterInput, MessageUncheckedUpdateWithoutOverrideSetterInput>
  }

  export type MessageUpdateManyWithWhereWithoutOverrideSetterInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutOverrideSetterInput>
  }

  export type ChannelSubscriptionUpsertWithWhereUniqueWithoutUserInput = {
    where: ChannelSubscriptionWhereUniqueInput
    update: XOR<ChannelSubscriptionUpdateWithoutUserInput, ChannelSubscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<ChannelSubscriptionCreateWithoutUserInput, ChannelSubscriptionUncheckedCreateWithoutUserInput>
  }

  export type ChannelSubscriptionUpdateWithWhereUniqueWithoutUserInput = {
    where: ChannelSubscriptionWhereUniqueInput
    data: XOR<ChannelSubscriptionUpdateWithoutUserInput, ChannelSubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type ChannelSubscriptionUpdateManyWithWhereWithoutUserInput = {
    where: ChannelSubscriptionScalarWhereInput
    data: XOR<ChannelSubscriptionUpdateManyMutationInput, ChannelSubscriptionUncheckedUpdateManyWithoutUserInput>
  }

  export type ChannelSubscriptionScalarWhereInput = {
    AND?: ChannelSubscriptionScalarWhereInput | ChannelSubscriptionScalarWhereInput[]
    OR?: ChannelSubscriptionScalarWhereInput[]
    NOT?: ChannelSubscriptionScalarWhereInput | ChannelSubscriptionScalarWhereInput[]
    id?: StringFilter<"ChannelSubscription"> | string
    userId?: StringFilter<"ChannelSubscription"> | string
    channelId?: StringFilter<"ChannelSubscription"> | string
    subscribedAt?: DateTimeFilter<"ChannelSubscription"> | Date | string
    isActive?: BoolFilter<"ChannelSubscription"> | boolean
    isFavorite?: BoolFilter<"ChannelSubscription"> | boolean
    receiveMessages?: BoolFilter<"ChannelSubscription"> | boolean
  }

  export type InvitationLinkUpsertWithWhereUniqueWithoutCreatorInput = {
    where: InvitationLinkWhereUniqueInput
    update: XOR<InvitationLinkUpdateWithoutCreatorInput, InvitationLinkUncheckedUpdateWithoutCreatorInput>
    create: XOR<InvitationLinkCreateWithoutCreatorInput, InvitationLinkUncheckedCreateWithoutCreatorInput>
  }

  export type InvitationLinkUpdateWithWhereUniqueWithoutCreatorInput = {
    where: InvitationLinkWhereUniqueInput
    data: XOR<InvitationLinkUpdateWithoutCreatorInput, InvitationLinkUncheckedUpdateWithoutCreatorInput>
  }

  export type InvitationLinkUpdateManyWithWhereWithoutCreatorInput = {
    where: InvitationLinkScalarWhereInput
    data: XOR<InvitationLinkUpdateManyMutationInput, InvitationLinkUncheckedUpdateManyWithoutCreatorInput>
  }

  export type InvitationLinkScalarWhereInput = {
    AND?: InvitationLinkScalarWhereInput | InvitationLinkScalarWhereInput[]
    OR?: InvitationLinkScalarWhereInput[]
    NOT?: InvitationLinkScalarWhereInput | InvitationLinkScalarWhereInput[]
    id?: StringFilter<"InvitationLink"> | string
    channelId?: StringFilter<"InvitationLink"> | string
    createdBy?: StringFilter<"InvitationLink"> | string
    linkCode?: StringFilter<"InvitationLink"> | string
    expiresAt?: DateTimeNullableFilter<"InvitationLink"> | Date | string | null
    maxUses?: IntNullableFilter<"InvitationLink"> | number | null
    currentUses?: IntFilter<"InvitationLink"> | number
    isActive?: BoolFilter<"InvitationLink"> | boolean
    createdAt?: DateTimeFilter<"InvitationLink"> | Date | string
  }

  export type QrCodeUpsertWithWhereUniqueWithoutCreatorInput = {
    where: QrCodeWhereUniqueInput
    update: XOR<QrCodeUpdateWithoutCreatorInput, QrCodeUncheckedUpdateWithoutCreatorInput>
    create: XOR<QrCodeCreateWithoutCreatorInput, QrCodeUncheckedCreateWithoutCreatorInput>
  }

  export type QrCodeUpdateWithWhereUniqueWithoutCreatorInput = {
    where: QrCodeWhereUniqueInput
    data: XOR<QrCodeUpdateWithoutCreatorInput, QrCodeUncheckedUpdateWithoutCreatorInput>
  }

  export type QrCodeUpdateManyWithWhereWithoutCreatorInput = {
    where: QrCodeScalarWhereInput
    data: XOR<QrCodeUpdateManyMutationInput, QrCodeUncheckedUpdateManyWithoutCreatorInput>
  }

  export type QrCodeScalarWhereInput = {
    AND?: QrCodeScalarWhereInput | QrCodeScalarWhereInput[]
    OR?: QrCodeScalarWhereInput[]
    NOT?: QrCodeScalarWhereInput | QrCodeScalarWhereInput[]
    id?: StringFilter<"QrCode"> | string
    channelId?: StringFilter<"QrCode"> | string
    createdBy?: StringFilter<"QrCode"> | string
    qrData?: StringFilter<"QrCode"> | string
    expiresAt?: DateTimeNullableFilter<"QrCode"> | Date | string | null
    scanCount?: IntFilter<"QrCode"> | number
    isActive?: BoolFilter<"QrCode"> | boolean
    createdAt?: DateTimeFilter<"QrCode"> | Date | string
  }

  export type MessageDeliveryUpsertWithWhereUniqueWithoutUserInput = {
    where: MessageDeliveryWhereUniqueInput
    update: XOR<MessageDeliveryUpdateWithoutUserInput, MessageDeliveryUncheckedUpdateWithoutUserInput>
    create: XOR<MessageDeliveryCreateWithoutUserInput, MessageDeliveryUncheckedCreateWithoutUserInput>
  }

  export type MessageDeliveryUpdateWithWhereUniqueWithoutUserInput = {
    where: MessageDeliveryWhereUniqueInput
    data: XOR<MessageDeliveryUpdateWithoutUserInput, MessageDeliveryUncheckedUpdateWithoutUserInput>
  }

  export type MessageDeliveryUpdateManyWithWhereWithoutUserInput = {
    where: MessageDeliveryScalarWhereInput
    data: XOR<MessageDeliveryUpdateManyMutationInput, MessageDeliveryUncheckedUpdateManyWithoutUserInput>
  }

  export type MessageDeliveryScalarWhereInput = {
    AND?: MessageDeliveryScalarWhereInput | MessageDeliveryScalarWhereInput[]
    OR?: MessageDeliveryScalarWhereInput[]
    NOT?: MessageDeliveryScalarWhereInput | MessageDeliveryScalarWhereInput[]
    id?: StringFilter<"MessageDelivery"> | string
    messageId?: StringFilter<"MessageDelivery"> | string
    userId?: StringFilter<"MessageDelivery"> | string
    deliveryStatus?: EnumDeliveryStatusFilter<"MessageDelivery"> | $Enums.DeliveryStatus
    deliveryMethod?: EnumDeliveryMethodNullableFilter<"MessageDelivery"> | $Enums.DeliveryMethod | null
    deliveredAt?: DateTimeNullableFilter<"MessageDelivery"> | Date | string | null
    readAt?: DateTimeNullableFilter<"MessageDelivery"> | Date | string | null
    createdAt?: DateTimeFilter<"MessageDelivery"> | Date | string
  }

  export type MessageApprovalUpsertWithWhereUniqueWithoutApproverInput = {
    where: MessageApprovalWhereUniqueInput
    update: XOR<MessageApprovalUpdateWithoutApproverInput, MessageApprovalUncheckedUpdateWithoutApproverInput>
    create: XOR<MessageApprovalCreateWithoutApproverInput, MessageApprovalUncheckedCreateWithoutApproverInput>
  }

  export type MessageApprovalUpdateWithWhereUniqueWithoutApproverInput = {
    where: MessageApprovalWhereUniqueInput
    data: XOR<MessageApprovalUpdateWithoutApproverInput, MessageApprovalUncheckedUpdateWithoutApproverInput>
  }

  export type MessageApprovalUpdateManyWithWhereWithoutApproverInput = {
    where: MessageApprovalScalarWhereInput
    data: XOR<MessageApprovalUpdateManyMutationInput, MessageApprovalUncheckedUpdateManyWithoutApproverInput>
  }

  export type MessageApprovalScalarWhereInput = {
    AND?: MessageApprovalScalarWhereInput | MessageApprovalScalarWhereInput[]
    OR?: MessageApprovalScalarWhereInput[]
    NOT?: MessageApprovalScalarWhereInput | MessageApprovalScalarWhereInput[]
    id?: StringFilter<"MessageApproval"> | string
    messageId?: StringFilter<"MessageApproval"> | string
    approverId?: StringFilter<"MessageApproval"> | string
    status?: EnumApprovalStatusFilter<"MessageApproval"> | $Enums.ApprovalStatus
    decidedAt?: DateTimeNullableFilter<"MessageApproval"> | Date | string | null
  }

  export type MessageRevisionUpsertWithWhereUniqueWithoutEditorInput = {
    where: MessageRevisionWhereUniqueInput
    update: XOR<MessageRevisionUpdateWithoutEditorInput, MessageRevisionUncheckedUpdateWithoutEditorInput>
    create: XOR<MessageRevisionCreateWithoutEditorInput, MessageRevisionUncheckedCreateWithoutEditorInput>
  }

  export type MessageRevisionUpdateWithWhereUniqueWithoutEditorInput = {
    where: MessageRevisionWhereUniqueInput
    data: XOR<MessageRevisionUpdateWithoutEditorInput, MessageRevisionUncheckedUpdateWithoutEditorInput>
  }

  export type MessageRevisionUpdateManyWithWhereWithoutEditorInput = {
    where: MessageRevisionScalarWhereInput
    data: XOR<MessageRevisionUpdateManyMutationInput, MessageRevisionUncheckedUpdateManyWithoutEditorInput>
  }

  export type MessageRevisionScalarWhereInput = {
    AND?: MessageRevisionScalarWhereInput | MessageRevisionScalarWhereInput[]
    OR?: MessageRevisionScalarWhereInput[]
    NOT?: MessageRevisionScalarWhereInput | MessageRevisionScalarWhereInput[]
    id?: StringFilter<"MessageRevision"> | string
    messageId?: StringFilter<"MessageRevision"> | string
    editorId?: StringFilter<"MessageRevision"> | string
    previousContent?: StringFilter<"MessageRevision"> | string
    previousCategoryId?: StringNullableFilter<"MessageRevision"> | string | null
    previousPriority?: EnumMessagePriorityFilter<"MessageRevision"> | $Enums.MessagePriority
    previousIsImmediate?: BoolFilter<"MessageRevision"> | boolean
    previousDeliveryMethod?: EnumDeliveryMethodFilter<"MessageRevision"> | $Enums.DeliveryMethod
    changedAt?: DateTimeFilter<"MessageRevision"> | Date | string
  }

  export type UserProfileUpsertWithoutUserInput = {
    update: XOR<UserProfileUpdateWithoutUserInput, UserProfileUncheckedUpdateWithoutUserInput>
    create: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutUserInput, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserMessagingSettingUpsertWithWhereUniqueWithoutUserInput = {
    where: UserMessagingSettingWhereUniqueInput
    update: XOR<UserMessagingSettingUpdateWithoutUserInput, UserMessagingSettingUncheckedUpdateWithoutUserInput>
    create: XOR<UserMessagingSettingCreateWithoutUserInput, UserMessagingSettingUncheckedCreateWithoutUserInput>
  }

  export type UserMessagingSettingUpdateWithWhereUniqueWithoutUserInput = {
    where: UserMessagingSettingWhereUniqueInput
    data: XOR<UserMessagingSettingUpdateWithoutUserInput, UserMessagingSettingUncheckedUpdateWithoutUserInput>
  }

  export type UserMessagingSettingUpdateManyWithWhereWithoutUserInput = {
    where: UserMessagingSettingScalarWhereInput
    data: XOR<UserMessagingSettingUpdateManyMutationInput, UserMessagingSettingUncheckedUpdateManyWithoutUserInput>
  }

  export type UserMessagingSettingScalarWhereInput = {
    AND?: UserMessagingSettingScalarWhereInput | UserMessagingSettingScalarWhereInput[]
    OR?: UserMessagingSettingScalarWhereInput[]
    NOT?: UserMessagingSettingScalarWhereInput | UserMessagingSettingScalarWhereInput[]
    id?: StringFilter<"UserMessagingSetting"> | string
    userId?: StringFilter<"UserMessagingSetting"> | string
    platform?: EnumMessagingPlatformFilter<"UserMessagingSetting"> | $Enums.MessagingPlatform
    handle?: StringNullableFilter<"UserMessagingSetting"> | string | null
    isEnabled?: BoolFilter<"UserMessagingSetting"> | boolean
    verified?: BoolFilter<"UserMessagingSetting"> | boolean
    createdAt?: DateTimeFilter<"UserMessagingSetting"> | Date | string
  }

  export type ChannelApproverUpsertWithWhereUniqueWithoutUserInput = {
    where: ChannelApproverWhereUniqueInput
    update: XOR<ChannelApproverUpdateWithoutUserInput, ChannelApproverUncheckedUpdateWithoutUserInput>
    create: XOR<ChannelApproverCreateWithoutUserInput, ChannelApproverUncheckedCreateWithoutUserInput>
  }

  export type ChannelApproverUpdateWithWhereUniqueWithoutUserInput = {
    where: ChannelApproverWhereUniqueInput
    data: XOR<ChannelApproverUpdateWithoutUserInput, ChannelApproverUncheckedUpdateWithoutUserInput>
  }

  export type ChannelApproverUpdateManyWithWhereWithoutUserInput = {
    where: ChannelApproverScalarWhereInput
    data: XOR<ChannelApproverUpdateManyMutationInput, ChannelApproverUncheckedUpdateManyWithoutUserInput>
  }

  export type ChannelApproverScalarWhereInput = {
    AND?: ChannelApproverScalarWhereInput | ChannelApproverScalarWhereInput[]
    OR?: ChannelApproverScalarWhereInput[]
    NOT?: ChannelApproverScalarWhereInput | ChannelApproverScalarWhereInput[]
    id?: StringFilter<"ChannelApprover"> | string
    channelId?: StringFilter<"ChannelApprover"> | string
    userId?: StringFilter<"ChannelApprover"> | string
    isActive?: BoolFilter<"ChannelApprover"> | boolean
    removedAt?: DateTimeNullableFilter<"ChannelApprover"> | Date | string | null
    removedBy?: StringNullableFilter<"ChannelApprover"> | string | null
    createdAt?: DateTimeFilter<"ChannelApprover"> | Date | string
  }

  export type MessageCategoryUpsertWithWhereUniqueWithoutCreatorInput = {
    where: MessageCategoryWhereUniqueInput
    update: XOR<MessageCategoryUpdateWithoutCreatorInput, MessageCategoryUncheckedUpdateWithoutCreatorInput>
    create: XOR<MessageCategoryCreateWithoutCreatorInput, MessageCategoryUncheckedCreateWithoutCreatorInput>
  }

  export type MessageCategoryUpdateWithWhereUniqueWithoutCreatorInput = {
    where: MessageCategoryWhereUniqueInput
    data: XOR<MessageCategoryUpdateWithoutCreatorInput, MessageCategoryUncheckedUpdateWithoutCreatorInput>
  }

  export type MessageCategoryUpdateManyWithWhereWithoutCreatorInput = {
    where: MessageCategoryScalarWhereInput
    data: XOR<MessageCategoryUpdateManyMutationInput, MessageCategoryUncheckedUpdateManyWithoutCreatorInput>
  }

  export type MessageCategoryScalarWhereInput = {
    AND?: MessageCategoryScalarWhereInput | MessageCategoryScalarWhereInput[]
    OR?: MessageCategoryScalarWhereInput[]
    NOT?: MessageCategoryScalarWhereInput | MessageCategoryScalarWhereInput[]
    id?: StringFilter<"MessageCategory"> | string
    name?: StringFilter<"MessageCategory"> | string
    scope?: EnumCategoryScopeFilter<"MessageCategory"> | $Enums.CategoryScope
    channelId?: StringNullableFilter<"MessageCategory"> | string | null
    createdBy?: StringNullableFilter<"MessageCategory"> | string | null
    createdAt?: DateTimeFilter<"MessageCategory"> | Date | string
  }

  export type MessageViewUpsertWithWhereUniqueWithoutUserInput = {
    where: MessageViewWhereUniqueInput
    update: XOR<MessageViewUpdateWithoutUserInput, MessageViewUncheckedUpdateWithoutUserInput>
    create: XOR<MessageViewCreateWithoutUserInput, MessageViewUncheckedCreateWithoutUserInput>
  }

  export type MessageViewUpdateWithWhereUniqueWithoutUserInput = {
    where: MessageViewWhereUniqueInput
    data: XOR<MessageViewUpdateWithoutUserInput, MessageViewUncheckedUpdateWithoutUserInput>
  }

  export type MessageViewUpdateManyWithWhereWithoutUserInput = {
    where: MessageViewScalarWhereInput
    data: XOR<MessageViewUpdateManyMutationInput, MessageViewUncheckedUpdateManyWithoutUserInput>
  }

  export type MessageViewScalarWhereInput = {
    AND?: MessageViewScalarWhereInput | MessageViewScalarWhereInput[]
    OR?: MessageViewScalarWhereInput[]
    NOT?: MessageViewScalarWhereInput | MessageViewScalarWhereInput[]
    id?: StringFilter<"MessageView"> | string
    messageId?: StringFilter<"MessageView"> | string
    userId?: StringNullableFilter<"MessageView"> | string | null
    viewedAt?: DateTimeFilter<"MessageView"> | Date | string
  }

  export type ChannelVisitUpsertWithWhereUniqueWithoutUserInput = {
    where: ChannelVisitWhereUniqueInput
    update: XOR<ChannelVisitUpdateWithoutUserInput, ChannelVisitUncheckedUpdateWithoutUserInput>
    create: XOR<ChannelVisitCreateWithoutUserInput, ChannelVisitUncheckedCreateWithoutUserInput>
  }

  export type ChannelVisitUpdateWithWhereUniqueWithoutUserInput = {
    where: ChannelVisitWhereUniqueInput
    data: XOR<ChannelVisitUpdateWithoutUserInput, ChannelVisitUncheckedUpdateWithoutUserInput>
  }

  export type ChannelVisitUpdateManyWithWhereWithoutUserInput = {
    where: ChannelVisitScalarWhereInput
    data: XOR<ChannelVisitUpdateManyMutationInput, ChannelVisitUncheckedUpdateManyWithoutUserInput>
  }

  export type ChannelVisitScalarWhereInput = {
    AND?: ChannelVisitScalarWhereInput | ChannelVisitScalarWhereInput[]
    OR?: ChannelVisitScalarWhereInput[]
    NOT?: ChannelVisitScalarWhereInput | ChannelVisitScalarWhereInput[]
    id?: StringFilter<"ChannelVisit"> | string
    channelId?: StringFilter<"ChannelVisit"> | string
    userId?: StringNullableFilter<"ChannelVisit"> | string | null
    visitedAt?: DateTimeFilter<"ChannelVisit"> | Date | string
  }

  export type FormUpsertWithWhereUniqueWithoutUserInput = {
    where: FormWhereUniqueInput
    update: XOR<FormUpdateWithoutUserInput, FormUncheckedUpdateWithoutUserInput>
    create: XOR<FormCreateWithoutUserInput, FormUncheckedCreateWithoutUserInput>
  }

  export type FormUpdateWithWhereUniqueWithoutUserInput = {
    where: FormWhereUniqueInput
    data: XOR<FormUpdateWithoutUserInput, FormUncheckedUpdateWithoutUserInput>
  }

  export type FormUpdateManyWithWhereWithoutUserInput = {
    where: FormScalarWhereInput
    data: XOR<FormUpdateManyMutationInput, FormUncheckedUpdateManyWithoutUserInput>
  }

  export type FormScalarWhereInput = {
    AND?: FormScalarWhereInput | FormScalarWhereInput[]
    OR?: FormScalarWhereInput[]
    NOT?: FormScalarWhereInput | FormScalarWhereInput[]
    id?: StringFilter<"Form"> | string
    title?: StringFilter<"Form"> | string
    description?: StringNullableFilter<"Form"> | string | null
    slug?: StringFilter<"Form"> | string
    headerContent?: StringNullableFilter<"Form"> | string | null
    footerContent?: StringNullableFilter<"Form"> | string | null
    successMessage?: StringNullableFilter<"Form"> | string | null
    isActive?: BoolFilter<"Form"> | boolean
    isPublished?: BoolFilter<"Form"> | boolean
    wasPublished?: BoolFilter<"Form"> | boolean
    isDeleted?: BoolFilter<"Form"> | boolean
    collectUserInfo?: BoolFilter<"Form"> | boolean
    expiresAt?: DateTimeNullableFilter<"Form"> | Date | string | null
    userId?: StringFilter<"Form"> | string
    createdAt?: DateTimeFilter<"Form"> | Date | string
    updatedAt?: DateTimeFilter<"Form"> | Date | string
  }

  export type EventUpsertWithWhereUniqueWithoutOrganizerInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutOrganizerInput, EventUncheckedUpdateWithoutOrganizerInput>
    create: XOR<EventCreateWithoutOrganizerInput, EventUncheckedCreateWithoutOrganizerInput>
  }

  export type EventUpdateWithWhereUniqueWithoutOrganizerInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutOrganizerInput, EventUncheckedUpdateWithoutOrganizerInput>
  }

  export type EventUpdateManyWithWhereWithoutOrganizerInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutOrganizerInput>
  }

  export type EventScalarWhereInput = {
    AND?: EventScalarWhereInput | EventScalarWhereInput[]
    OR?: EventScalarWhereInput[]
    NOT?: EventScalarWhereInput | EventScalarWhereInput[]
    id?: StringFilter<"Event"> | string
    title?: StringFilter<"Event"> | string
    description?: StringNullableFilter<"Event"> | string | null
    startDate?: DateTimeFilter<"Event"> | Date | string
    endDate?: DateTimeFilter<"Event"> | Date | string
    location?: StringFilter<"Event"> | string
    imageUrl?: StringNullableFilter<"Event"> | string | null
    status?: EnumEventStatusFilter<"Event"> | $Enums.EventStatus
    categories?: JsonNullableFilter<"Event">
    paymentInfo?: StringNullableFilter<"Event"> | string | null
    organizerId?: StringFilter<"Event"> | string
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
  }

  export type UserCreateWithoutOwnedChannelsInput = {
    id?: string
    email: string
    username: string
    fullName?: string | null
    avatarUrl?: string | null
    passwordHash?: string | null
    deviceId?: string | null
    isGuest?: boolean
    phoneNumber?: string | null
    isPhoneVerified?: boolean
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    isAdmin?: boolean
    isCoordinator?: boolean
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesOverrideSet?: MessageCreateNestedManyWithoutOverrideSetterInput
    subscriptions?: ChannelSubscriptionCreateNestedManyWithoutUserInput
    invitationLinks?: InvitationLinkCreateNestedManyWithoutCreatorInput
    qrCodes?: QrCodeCreateNestedManyWithoutCreatorInput
    messageDeliveries?: MessageDeliveryCreateNestedManyWithoutUserInput
    messageApprovals?: MessageApprovalCreateNestedManyWithoutApproverInput
    messageRevisionsEdited?: MessageRevisionCreateNestedManyWithoutEditorInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    messagingSettings?: UserMessagingSettingCreateNestedManyWithoutUserInput
    approverAssignments?: ChannelApproverCreateNestedManyWithoutUserInput
    createdCategories?: MessageCategoryCreateNestedManyWithoutCreatorInput
    messageViews?: MessageViewCreateNestedManyWithoutUserInput
    channelVisits?: ChannelVisitCreateNestedManyWithoutUserInput
    createdForms?: FormCreateNestedManyWithoutUserInput
    organizedEvents?: EventCreateNestedManyWithoutOrganizerInput
  }

  export type UserUncheckedCreateWithoutOwnedChannelsInput = {
    id?: string
    email: string
    username: string
    fullName?: string | null
    avatarUrl?: string | null
    passwordHash?: string | null
    deviceId?: string | null
    isGuest?: boolean
    phoneNumber?: string | null
    isPhoneVerified?: boolean
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    isAdmin?: boolean
    isCoordinator?: boolean
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesOverrideSet?: MessageUncheckedCreateNestedManyWithoutOverrideSetterInput
    subscriptions?: ChannelSubscriptionUncheckedCreateNestedManyWithoutUserInput
    invitationLinks?: InvitationLinkUncheckedCreateNestedManyWithoutCreatorInput
    qrCodes?: QrCodeUncheckedCreateNestedManyWithoutCreatorInput
    messageDeliveries?: MessageDeliveryUncheckedCreateNestedManyWithoutUserInput
    messageApprovals?: MessageApprovalUncheckedCreateNestedManyWithoutApproverInput
    messageRevisionsEdited?: MessageRevisionUncheckedCreateNestedManyWithoutEditorInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    messagingSettings?: UserMessagingSettingUncheckedCreateNestedManyWithoutUserInput
    approverAssignments?: ChannelApproverUncheckedCreateNestedManyWithoutUserInput
    createdCategories?: MessageCategoryUncheckedCreateNestedManyWithoutCreatorInput
    messageViews?: MessageViewUncheckedCreateNestedManyWithoutUserInput
    channelVisits?: ChannelVisitUncheckedCreateNestedManyWithoutUserInput
    createdForms?: FormUncheckedCreateNestedManyWithoutUserInput
    organizedEvents?: EventUncheckedCreateNestedManyWithoutOrganizerInput
  }

  export type UserCreateOrConnectWithoutOwnedChannelsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedChannelsInput, UserUncheckedCreateWithoutOwnedChannelsInput>
  }

  export type OrganizationCreateWithoutChannelsInput = {
    id?: string
    name: string
    nit: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationUncheckedCreateWithoutChannelsInput = {
    id?: string
    name: string
    nit: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationCreateOrConnectWithoutChannelsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutChannelsInput, OrganizationUncheckedCreateWithoutChannelsInput>
  }

  export type ChannelCreateWithoutSubchannelsInput = {
    id?: string
    title: string
    description?: string | null
    websiteUrl?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: string | null
    icon?: string
    isPublic?: boolean
    isHidden?: boolean
    searchExactOnly?: boolean
    passwordHash?: string | null
    referenceCode?: string | null
    verificationStatus?: $Enums.VerificationStatus
    approvalPolicy?: $Enums.ApprovalPolicy
    memberCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedChannelsInput
    organization: OrganizationCreateNestedOneWithoutChannelsInput
    parent?: ChannelCreateNestedOneWithoutSubchannelsInput
    messages?: MessageCreateNestedManyWithoutChannelInput
    subscriptions?: ChannelSubscriptionCreateNestedManyWithoutChannelInput
    invitationLinks?: InvitationLinkCreateNestedManyWithoutChannelInput
    qrCodes?: QrCodeCreateNestedManyWithoutChannelInput
    approvers?: ChannelApproverCreateNestedManyWithoutChannelInput
    verificationDocs?: ChannelVerificationDocumentCreateNestedManyWithoutChannelInput
    categories?: ChannelCategoryAssignmentCreateNestedManyWithoutChannelInput
    messageCategories?: MessageCategoryCreateNestedManyWithoutChannelInput
    visits?: ChannelVisitCreateNestedManyWithoutChannelInput
  }

  export type ChannelUncheckedCreateWithoutSubchannelsInput = {
    id?: string
    title: string
    description?: string | null
    websiteUrl?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: string | null
    icon?: string
    parentId?: string | null
    ownerId: string
    organizationId: string
    isPublic?: boolean
    isHidden?: boolean
    searchExactOnly?: boolean
    passwordHash?: string | null
    referenceCode?: string | null
    verificationStatus?: $Enums.VerificationStatus
    approvalPolicy?: $Enums.ApprovalPolicy
    memberCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutChannelInput
    subscriptions?: ChannelSubscriptionUncheckedCreateNestedManyWithoutChannelInput
    invitationLinks?: InvitationLinkUncheckedCreateNestedManyWithoutChannelInput
    qrCodes?: QrCodeUncheckedCreateNestedManyWithoutChannelInput
    approvers?: ChannelApproverUncheckedCreateNestedManyWithoutChannelInput
    verificationDocs?: ChannelVerificationDocumentUncheckedCreateNestedManyWithoutChannelInput
    categories?: ChannelCategoryAssignmentUncheckedCreateNestedManyWithoutChannelInput
    messageCategories?: MessageCategoryUncheckedCreateNestedManyWithoutChannelInput
    visits?: ChannelVisitUncheckedCreateNestedManyWithoutChannelInput
  }

  export type ChannelCreateOrConnectWithoutSubchannelsInput = {
    where: ChannelWhereUniqueInput
    create: XOR<ChannelCreateWithoutSubchannelsInput, ChannelUncheckedCreateWithoutSubchannelsInput>
  }

  export type ChannelCreateWithoutParentInput = {
    id?: string
    title: string
    description?: string | null
    websiteUrl?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: string | null
    icon?: string
    isPublic?: boolean
    isHidden?: boolean
    searchExactOnly?: boolean
    passwordHash?: string | null
    referenceCode?: string | null
    verificationStatus?: $Enums.VerificationStatus
    approvalPolicy?: $Enums.ApprovalPolicy
    memberCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedChannelsInput
    organization: OrganizationCreateNestedOneWithoutChannelsInput
    subchannels?: ChannelCreateNestedManyWithoutParentInput
    messages?: MessageCreateNestedManyWithoutChannelInput
    subscriptions?: ChannelSubscriptionCreateNestedManyWithoutChannelInput
    invitationLinks?: InvitationLinkCreateNestedManyWithoutChannelInput
    qrCodes?: QrCodeCreateNestedManyWithoutChannelInput
    approvers?: ChannelApproverCreateNestedManyWithoutChannelInput
    verificationDocs?: ChannelVerificationDocumentCreateNestedManyWithoutChannelInput
    categories?: ChannelCategoryAssignmentCreateNestedManyWithoutChannelInput
    messageCategories?: MessageCategoryCreateNestedManyWithoutChannelInput
    visits?: ChannelVisitCreateNestedManyWithoutChannelInput
  }

  export type ChannelUncheckedCreateWithoutParentInput = {
    id?: string
    title: string
    description?: string | null
    websiteUrl?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: string | null
    icon?: string
    ownerId: string
    organizationId: string
    isPublic?: boolean
    isHidden?: boolean
    searchExactOnly?: boolean
    passwordHash?: string | null
    referenceCode?: string | null
    verificationStatus?: $Enums.VerificationStatus
    approvalPolicy?: $Enums.ApprovalPolicy
    memberCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    subchannels?: ChannelUncheckedCreateNestedManyWithoutParentInput
    messages?: MessageUncheckedCreateNestedManyWithoutChannelInput
    subscriptions?: ChannelSubscriptionUncheckedCreateNestedManyWithoutChannelInput
    invitationLinks?: InvitationLinkUncheckedCreateNestedManyWithoutChannelInput
    qrCodes?: QrCodeUncheckedCreateNestedManyWithoutChannelInput
    approvers?: ChannelApproverUncheckedCreateNestedManyWithoutChannelInput
    verificationDocs?: ChannelVerificationDocumentUncheckedCreateNestedManyWithoutChannelInput
    categories?: ChannelCategoryAssignmentUncheckedCreateNestedManyWithoutChannelInput
    messageCategories?: MessageCategoryUncheckedCreateNestedManyWithoutChannelInput
    visits?: ChannelVisitUncheckedCreateNestedManyWithoutChannelInput
  }

  export type ChannelCreateOrConnectWithoutParentInput = {
    where: ChannelWhereUniqueInput
    create: XOR<ChannelCreateWithoutParentInput, ChannelUncheckedCreateWithoutParentInput>
  }

  export type ChannelCreateManyParentInputEnvelope = {
    data: ChannelCreateManyParentInput | ChannelCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutChannelInput = {
    id?: string
    content: string
    durationSeconds?: number
    expiresAt?: Date | string | null
    isEmergency?: boolean
    isImmediate?: boolean
    priority?: $Enums.MessagePriority
    approvalOverride?: $Enums.ApprovalPolicy | null
    approvalOverrideSetAt?: Date | string | null
    deliveryMethod?: $Enums.DeliveryMethod
    eventAt?: Date | string | null
    publishedAt?: Date | string | null
    state?: $Enums.MessageState
    createdAt?: Date | string
    updatedAt?: Date | string
    sender: UserCreateNestedOneWithoutMessagesSentInput
    category: MessageCategoryCreateNestedOneWithoutMessagesInput
    overrideSetter?: UserCreateNestedOneWithoutMessagesOverrideSetInput
    deliveries?: MessageDeliveryCreateNestedManyWithoutMessageInput
    approvals?: MessageApprovalCreateNestedManyWithoutMessageInput
    attachments?: MessageAttachmentCreateNestedManyWithoutMessageInput
    revisions?: MessageRevisionCreateNestedManyWithoutMessageInput
    views?: MessageViewCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutChannelInput = {
    id?: string
    senderId: string
    categoryId: string
    content: string
    durationSeconds?: number
    expiresAt?: Date | string | null
    isEmergency?: boolean
    isImmediate?: boolean
    priority?: $Enums.MessagePriority
    approvalOverride?: $Enums.ApprovalPolicy | null
    approvalOverrideSetBy?: string | null
    approvalOverrideSetAt?: Date | string | null
    deliveryMethod?: $Enums.DeliveryMethod
    eventAt?: Date | string | null
    publishedAt?: Date | string | null
    state?: $Enums.MessageState
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveries?: MessageDeliveryUncheckedCreateNestedManyWithoutMessageInput
    approvals?: MessageApprovalUncheckedCreateNestedManyWithoutMessageInput
    attachments?: MessageAttachmentUncheckedCreateNestedManyWithoutMessageInput
    revisions?: MessageRevisionUncheckedCreateNestedManyWithoutMessageInput
    views?: MessageViewUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutChannelInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutChannelInput, MessageUncheckedCreateWithoutChannelInput>
  }

  export type MessageCreateManyChannelInputEnvelope = {
    data: MessageCreateManyChannelInput | MessageCreateManyChannelInput[]
    skipDuplicates?: boolean
  }

  export type ChannelSubscriptionCreateWithoutChannelInput = {
    id?: string
    subscribedAt?: Date | string
    isActive?: boolean
    isFavorite?: boolean
    receiveMessages?: boolean
    user: UserCreateNestedOneWithoutSubscriptionsInput
  }

  export type ChannelSubscriptionUncheckedCreateWithoutChannelInput = {
    id?: string
    userId: string
    subscribedAt?: Date | string
    isActive?: boolean
    isFavorite?: boolean
    receiveMessages?: boolean
  }

  export type ChannelSubscriptionCreateOrConnectWithoutChannelInput = {
    where: ChannelSubscriptionWhereUniqueInput
    create: XOR<ChannelSubscriptionCreateWithoutChannelInput, ChannelSubscriptionUncheckedCreateWithoutChannelInput>
  }

  export type ChannelSubscriptionCreateManyChannelInputEnvelope = {
    data: ChannelSubscriptionCreateManyChannelInput | ChannelSubscriptionCreateManyChannelInput[]
    skipDuplicates?: boolean
  }

  export type InvitationLinkCreateWithoutChannelInput = {
    id?: string
    linkCode: string
    expiresAt?: Date | string | null
    maxUses?: number | null
    currentUses?: number
    isActive?: boolean
    createdAt?: Date | string
    creator: UserCreateNestedOneWithoutInvitationLinksInput
  }

  export type InvitationLinkUncheckedCreateWithoutChannelInput = {
    id?: string
    createdBy: string
    linkCode: string
    expiresAt?: Date | string | null
    maxUses?: number | null
    currentUses?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type InvitationLinkCreateOrConnectWithoutChannelInput = {
    where: InvitationLinkWhereUniqueInput
    create: XOR<InvitationLinkCreateWithoutChannelInput, InvitationLinkUncheckedCreateWithoutChannelInput>
  }

  export type InvitationLinkCreateManyChannelInputEnvelope = {
    data: InvitationLinkCreateManyChannelInput | InvitationLinkCreateManyChannelInput[]
    skipDuplicates?: boolean
  }

  export type QrCodeCreateWithoutChannelInput = {
    id?: string
    qrData: string
    expiresAt?: Date | string | null
    scanCount?: number
    isActive?: boolean
    createdAt?: Date | string
    creator: UserCreateNestedOneWithoutQrCodesInput
  }

  export type QrCodeUncheckedCreateWithoutChannelInput = {
    id?: string
    createdBy: string
    qrData: string
    expiresAt?: Date | string | null
    scanCount?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type QrCodeCreateOrConnectWithoutChannelInput = {
    where: QrCodeWhereUniqueInput
    create: XOR<QrCodeCreateWithoutChannelInput, QrCodeUncheckedCreateWithoutChannelInput>
  }

  export type QrCodeCreateManyChannelInputEnvelope = {
    data: QrCodeCreateManyChannelInput | QrCodeCreateManyChannelInput[]
    skipDuplicates?: boolean
  }

  export type ChannelApproverCreateWithoutChannelInput = {
    id?: string
    isActive?: boolean
    removedAt?: Date | string | null
    removedBy?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutApproverAssignmentsInput
  }

  export type ChannelApproverUncheckedCreateWithoutChannelInput = {
    id?: string
    userId: string
    isActive?: boolean
    removedAt?: Date | string | null
    removedBy?: string | null
    createdAt?: Date | string
  }

  export type ChannelApproverCreateOrConnectWithoutChannelInput = {
    where: ChannelApproverWhereUniqueInput
    create: XOR<ChannelApproverCreateWithoutChannelInput, ChannelApproverUncheckedCreateWithoutChannelInput>
  }

  export type ChannelApproverCreateManyChannelInputEnvelope = {
    data: ChannelApproverCreateManyChannelInput | ChannelApproverCreateManyChannelInput[]
    skipDuplicates?: boolean
  }

  export type ChannelVerificationDocumentCreateWithoutChannelInput = {
    id?: string
    title: string
    docUrl: string
    issuer?: string | null
    issuedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ChannelVerificationDocumentUncheckedCreateWithoutChannelInput = {
    id?: string
    title: string
    docUrl: string
    issuer?: string | null
    issuedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ChannelVerificationDocumentCreateOrConnectWithoutChannelInput = {
    where: ChannelVerificationDocumentWhereUniqueInput
    create: XOR<ChannelVerificationDocumentCreateWithoutChannelInput, ChannelVerificationDocumentUncheckedCreateWithoutChannelInput>
  }

  export type ChannelVerificationDocumentCreateManyChannelInputEnvelope = {
    data: ChannelVerificationDocumentCreateManyChannelInput | ChannelVerificationDocumentCreateManyChannelInput[]
    skipDuplicates?: boolean
  }

  export type ChannelCategoryAssignmentCreateWithoutChannelInput = {
    id?: string
    category: ChannelCategoryCreateNestedOneWithoutAssignmentsInput
  }

  export type ChannelCategoryAssignmentUncheckedCreateWithoutChannelInput = {
    id?: string
    categoryId: string
  }

  export type ChannelCategoryAssignmentCreateOrConnectWithoutChannelInput = {
    where: ChannelCategoryAssignmentWhereUniqueInput
    create: XOR<ChannelCategoryAssignmentCreateWithoutChannelInput, ChannelCategoryAssignmentUncheckedCreateWithoutChannelInput>
  }

  export type ChannelCategoryAssignmentCreateManyChannelInputEnvelope = {
    data: ChannelCategoryAssignmentCreateManyChannelInput | ChannelCategoryAssignmentCreateManyChannelInput[]
    skipDuplicates?: boolean
  }

  export type MessageCategoryCreateWithoutChannelInput = {
    id?: string
    name: string
    scope?: $Enums.CategoryScope
    createdAt?: Date | string
    creator?: UserCreateNestedOneWithoutCreatedCategoriesInput
    messages?: MessageCreateNestedManyWithoutCategoryInput
  }

  export type MessageCategoryUncheckedCreateWithoutChannelInput = {
    id?: string
    name: string
    scope?: $Enums.CategoryScope
    createdBy?: string | null
    createdAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type MessageCategoryCreateOrConnectWithoutChannelInput = {
    where: MessageCategoryWhereUniqueInput
    create: XOR<MessageCategoryCreateWithoutChannelInput, MessageCategoryUncheckedCreateWithoutChannelInput>
  }

  export type MessageCategoryCreateManyChannelInputEnvelope = {
    data: MessageCategoryCreateManyChannelInput | MessageCategoryCreateManyChannelInput[]
    skipDuplicates?: boolean
  }

  export type ChannelVisitCreateWithoutChannelInput = {
    id?: string
    visitedAt?: Date | string
    user?: UserCreateNestedOneWithoutChannelVisitsInput
  }

  export type ChannelVisitUncheckedCreateWithoutChannelInput = {
    id?: string
    userId?: string | null
    visitedAt?: Date | string
  }

  export type ChannelVisitCreateOrConnectWithoutChannelInput = {
    where: ChannelVisitWhereUniqueInput
    create: XOR<ChannelVisitCreateWithoutChannelInput, ChannelVisitUncheckedCreateWithoutChannelInput>
  }

  export type ChannelVisitCreateManyChannelInputEnvelope = {
    data: ChannelVisitCreateManyChannelInput | ChannelVisitCreateManyChannelInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutOwnedChannelsInput = {
    update: XOR<UserUpdateWithoutOwnedChannelsInput, UserUncheckedUpdateWithoutOwnedChannelsInput>
    create: XOR<UserCreateWithoutOwnedChannelsInput, UserUncheckedCreateWithoutOwnedChannelsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedChannelsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedChannelsInput, UserUncheckedUpdateWithoutOwnedChannelsInput>
  }

  export type UserUpdateWithoutOwnedChannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isCoordinator?: BoolFieldUpdateOperationsInput | boolean
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesOverrideSet?: MessageUpdateManyWithoutOverrideSetterNestedInput
    subscriptions?: ChannelSubscriptionUpdateManyWithoutUserNestedInput
    invitationLinks?: InvitationLinkUpdateManyWithoutCreatorNestedInput
    qrCodes?: QrCodeUpdateManyWithoutCreatorNestedInput
    messageDeliveries?: MessageDeliveryUpdateManyWithoutUserNestedInput
    messageApprovals?: MessageApprovalUpdateManyWithoutApproverNestedInput
    messageRevisionsEdited?: MessageRevisionUpdateManyWithoutEditorNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    messagingSettings?: UserMessagingSettingUpdateManyWithoutUserNestedInput
    approverAssignments?: ChannelApproverUpdateManyWithoutUserNestedInput
    createdCategories?: MessageCategoryUpdateManyWithoutCreatorNestedInput
    messageViews?: MessageViewUpdateManyWithoutUserNestedInput
    channelVisits?: ChannelVisitUpdateManyWithoutUserNestedInput
    createdForms?: FormUpdateManyWithoutUserNestedInput
    organizedEvents?: EventUpdateManyWithoutOrganizerNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedChannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isCoordinator?: BoolFieldUpdateOperationsInput | boolean
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesOverrideSet?: MessageUncheckedUpdateManyWithoutOverrideSetterNestedInput
    subscriptions?: ChannelSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invitationLinks?: InvitationLinkUncheckedUpdateManyWithoutCreatorNestedInput
    qrCodes?: QrCodeUncheckedUpdateManyWithoutCreatorNestedInput
    messageDeliveries?: MessageDeliveryUncheckedUpdateManyWithoutUserNestedInput
    messageApprovals?: MessageApprovalUncheckedUpdateManyWithoutApproverNestedInput
    messageRevisionsEdited?: MessageRevisionUncheckedUpdateManyWithoutEditorNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    messagingSettings?: UserMessagingSettingUncheckedUpdateManyWithoutUserNestedInput
    approverAssignments?: ChannelApproverUncheckedUpdateManyWithoutUserNestedInput
    createdCategories?: MessageCategoryUncheckedUpdateManyWithoutCreatorNestedInput
    messageViews?: MessageViewUncheckedUpdateManyWithoutUserNestedInput
    channelVisits?: ChannelVisitUncheckedUpdateManyWithoutUserNestedInput
    createdForms?: FormUncheckedUpdateManyWithoutUserNestedInput
    organizedEvents?: EventUncheckedUpdateManyWithoutOrganizerNestedInput
  }

  export type OrganizationUpsertWithoutChannelsInput = {
    update: XOR<OrganizationUpdateWithoutChannelsInput, OrganizationUncheckedUpdateWithoutChannelsInput>
    create: XOR<OrganizationCreateWithoutChannelsInput, OrganizationUncheckedCreateWithoutChannelsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutChannelsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutChannelsInput, OrganizationUncheckedUpdateWithoutChannelsInput>
  }

  export type OrganizationUpdateWithoutChannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUncheckedUpdateWithoutChannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelUpsertWithoutSubchannelsInput = {
    update: XOR<ChannelUpdateWithoutSubchannelsInput, ChannelUncheckedUpdateWithoutSubchannelsInput>
    create: XOR<ChannelCreateWithoutSubchannelsInput, ChannelUncheckedCreateWithoutSubchannelsInput>
    where?: ChannelWhereInput
  }

  export type ChannelUpdateToOneWithWhereWithoutSubchannelsInput = {
    where?: ChannelWhereInput
    data: XOR<ChannelUpdateWithoutSubchannelsInput, ChannelUncheckedUpdateWithoutSubchannelsInput>
  }

  export type ChannelUpdateWithoutSubchannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    searchExactOnly?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    approvalPolicy?: EnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy
    memberCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedChannelsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutChannelsNestedInput
    parent?: ChannelUpdateOneWithoutSubchannelsNestedInput
    messages?: MessageUpdateManyWithoutChannelNestedInput
    subscriptions?: ChannelSubscriptionUpdateManyWithoutChannelNestedInput
    invitationLinks?: InvitationLinkUpdateManyWithoutChannelNestedInput
    qrCodes?: QrCodeUpdateManyWithoutChannelNestedInput
    approvers?: ChannelApproverUpdateManyWithoutChannelNestedInput
    verificationDocs?: ChannelVerificationDocumentUpdateManyWithoutChannelNestedInput
    categories?: ChannelCategoryAssignmentUpdateManyWithoutChannelNestedInput
    messageCategories?: MessageCategoryUpdateManyWithoutChannelNestedInput
    visits?: ChannelVisitUpdateManyWithoutChannelNestedInput
  }

  export type ChannelUncheckedUpdateWithoutSubchannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    searchExactOnly?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    approvalPolicy?: EnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy
    memberCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutChannelNestedInput
    subscriptions?: ChannelSubscriptionUncheckedUpdateManyWithoutChannelNestedInput
    invitationLinks?: InvitationLinkUncheckedUpdateManyWithoutChannelNestedInput
    qrCodes?: QrCodeUncheckedUpdateManyWithoutChannelNestedInput
    approvers?: ChannelApproverUncheckedUpdateManyWithoutChannelNestedInput
    verificationDocs?: ChannelVerificationDocumentUncheckedUpdateManyWithoutChannelNestedInput
    categories?: ChannelCategoryAssignmentUncheckedUpdateManyWithoutChannelNestedInput
    messageCategories?: MessageCategoryUncheckedUpdateManyWithoutChannelNestedInput
    visits?: ChannelVisitUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type ChannelUpsertWithWhereUniqueWithoutParentInput = {
    where: ChannelWhereUniqueInput
    update: XOR<ChannelUpdateWithoutParentInput, ChannelUncheckedUpdateWithoutParentInput>
    create: XOR<ChannelCreateWithoutParentInput, ChannelUncheckedCreateWithoutParentInput>
  }

  export type ChannelUpdateWithWhereUniqueWithoutParentInput = {
    where: ChannelWhereUniqueInput
    data: XOR<ChannelUpdateWithoutParentInput, ChannelUncheckedUpdateWithoutParentInput>
  }

  export type ChannelUpdateManyWithWhereWithoutParentInput = {
    where: ChannelScalarWhereInput
    data: XOR<ChannelUpdateManyMutationInput, ChannelUncheckedUpdateManyWithoutParentInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutChannelInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutChannelInput, MessageUncheckedUpdateWithoutChannelInput>
    create: XOR<MessageCreateWithoutChannelInput, MessageUncheckedCreateWithoutChannelInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutChannelInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutChannelInput, MessageUncheckedUpdateWithoutChannelInput>
  }

  export type MessageUpdateManyWithWhereWithoutChannelInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutChannelInput>
  }

  export type ChannelSubscriptionUpsertWithWhereUniqueWithoutChannelInput = {
    where: ChannelSubscriptionWhereUniqueInput
    update: XOR<ChannelSubscriptionUpdateWithoutChannelInput, ChannelSubscriptionUncheckedUpdateWithoutChannelInput>
    create: XOR<ChannelSubscriptionCreateWithoutChannelInput, ChannelSubscriptionUncheckedCreateWithoutChannelInput>
  }

  export type ChannelSubscriptionUpdateWithWhereUniqueWithoutChannelInput = {
    where: ChannelSubscriptionWhereUniqueInput
    data: XOR<ChannelSubscriptionUpdateWithoutChannelInput, ChannelSubscriptionUncheckedUpdateWithoutChannelInput>
  }

  export type ChannelSubscriptionUpdateManyWithWhereWithoutChannelInput = {
    where: ChannelSubscriptionScalarWhereInput
    data: XOR<ChannelSubscriptionUpdateManyMutationInput, ChannelSubscriptionUncheckedUpdateManyWithoutChannelInput>
  }

  export type InvitationLinkUpsertWithWhereUniqueWithoutChannelInput = {
    where: InvitationLinkWhereUniqueInput
    update: XOR<InvitationLinkUpdateWithoutChannelInput, InvitationLinkUncheckedUpdateWithoutChannelInput>
    create: XOR<InvitationLinkCreateWithoutChannelInput, InvitationLinkUncheckedCreateWithoutChannelInput>
  }

  export type InvitationLinkUpdateWithWhereUniqueWithoutChannelInput = {
    where: InvitationLinkWhereUniqueInput
    data: XOR<InvitationLinkUpdateWithoutChannelInput, InvitationLinkUncheckedUpdateWithoutChannelInput>
  }

  export type InvitationLinkUpdateManyWithWhereWithoutChannelInput = {
    where: InvitationLinkScalarWhereInput
    data: XOR<InvitationLinkUpdateManyMutationInput, InvitationLinkUncheckedUpdateManyWithoutChannelInput>
  }

  export type QrCodeUpsertWithWhereUniqueWithoutChannelInput = {
    where: QrCodeWhereUniqueInput
    update: XOR<QrCodeUpdateWithoutChannelInput, QrCodeUncheckedUpdateWithoutChannelInput>
    create: XOR<QrCodeCreateWithoutChannelInput, QrCodeUncheckedCreateWithoutChannelInput>
  }

  export type QrCodeUpdateWithWhereUniqueWithoutChannelInput = {
    where: QrCodeWhereUniqueInput
    data: XOR<QrCodeUpdateWithoutChannelInput, QrCodeUncheckedUpdateWithoutChannelInput>
  }

  export type QrCodeUpdateManyWithWhereWithoutChannelInput = {
    where: QrCodeScalarWhereInput
    data: XOR<QrCodeUpdateManyMutationInput, QrCodeUncheckedUpdateManyWithoutChannelInput>
  }

  export type ChannelApproverUpsertWithWhereUniqueWithoutChannelInput = {
    where: ChannelApproverWhereUniqueInput
    update: XOR<ChannelApproverUpdateWithoutChannelInput, ChannelApproverUncheckedUpdateWithoutChannelInput>
    create: XOR<ChannelApproverCreateWithoutChannelInput, ChannelApproverUncheckedCreateWithoutChannelInput>
  }

  export type ChannelApproverUpdateWithWhereUniqueWithoutChannelInput = {
    where: ChannelApproverWhereUniqueInput
    data: XOR<ChannelApproverUpdateWithoutChannelInput, ChannelApproverUncheckedUpdateWithoutChannelInput>
  }

  export type ChannelApproverUpdateManyWithWhereWithoutChannelInput = {
    where: ChannelApproverScalarWhereInput
    data: XOR<ChannelApproverUpdateManyMutationInput, ChannelApproverUncheckedUpdateManyWithoutChannelInput>
  }

  export type ChannelVerificationDocumentUpsertWithWhereUniqueWithoutChannelInput = {
    where: ChannelVerificationDocumentWhereUniqueInput
    update: XOR<ChannelVerificationDocumentUpdateWithoutChannelInput, ChannelVerificationDocumentUncheckedUpdateWithoutChannelInput>
    create: XOR<ChannelVerificationDocumentCreateWithoutChannelInput, ChannelVerificationDocumentUncheckedCreateWithoutChannelInput>
  }

  export type ChannelVerificationDocumentUpdateWithWhereUniqueWithoutChannelInput = {
    where: ChannelVerificationDocumentWhereUniqueInput
    data: XOR<ChannelVerificationDocumentUpdateWithoutChannelInput, ChannelVerificationDocumentUncheckedUpdateWithoutChannelInput>
  }

  export type ChannelVerificationDocumentUpdateManyWithWhereWithoutChannelInput = {
    where: ChannelVerificationDocumentScalarWhereInput
    data: XOR<ChannelVerificationDocumentUpdateManyMutationInput, ChannelVerificationDocumentUncheckedUpdateManyWithoutChannelInput>
  }

  export type ChannelVerificationDocumentScalarWhereInput = {
    AND?: ChannelVerificationDocumentScalarWhereInput | ChannelVerificationDocumentScalarWhereInput[]
    OR?: ChannelVerificationDocumentScalarWhereInput[]
    NOT?: ChannelVerificationDocumentScalarWhereInput | ChannelVerificationDocumentScalarWhereInput[]
    id?: StringFilter<"ChannelVerificationDocument"> | string
    channelId?: StringFilter<"ChannelVerificationDocument"> | string
    title?: StringFilter<"ChannelVerificationDocument"> | string
    docUrl?: StringFilter<"ChannelVerificationDocument"> | string
    issuer?: StringNullableFilter<"ChannelVerificationDocument"> | string | null
    issuedAt?: DateTimeNullableFilter<"ChannelVerificationDocument"> | Date | string | null
    createdAt?: DateTimeFilter<"ChannelVerificationDocument"> | Date | string
  }

  export type ChannelCategoryAssignmentUpsertWithWhereUniqueWithoutChannelInput = {
    where: ChannelCategoryAssignmentWhereUniqueInput
    update: XOR<ChannelCategoryAssignmentUpdateWithoutChannelInput, ChannelCategoryAssignmentUncheckedUpdateWithoutChannelInput>
    create: XOR<ChannelCategoryAssignmentCreateWithoutChannelInput, ChannelCategoryAssignmentUncheckedCreateWithoutChannelInput>
  }

  export type ChannelCategoryAssignmentUpdateWithWhereUniqueWithoutChannelInput = {
    where: ChannelCategoryAssignmentWhereUniqueInput
    data: XOR<ChannelCategoryAssignmentUpdateWithoutChannelInput, ChannelCategoryAssignmentUncheckedUpdateWithoutChannelInput>
  }

  export type ChannelCategoryAssignmentUpdateManyWithWhereWithoutChannelInput = {
    where: ChannelCategoryAssignmentScalarWhereInput
    data: XOR<ChannelCategoryAssignmentUpdateManyMutationInput, ChannelCategoryAssignmentUncheckedUpdateManyWithoutChannelInput>
  }

  export type ChannelCategoryAssignmentScalarWhereInput = {
    AND?: ChannelCategoryAssignmentScalarWhereInput | ChannelCategoryAssignmentScalarWhereInput[]
    OR?: ChannelCategoryAssignmentScalarWhereInput[]
    NOT?: ChannelCategoryAssignmentScalarWhereInput | ChannelCategoryAssignmentScalarWhereInput[]
    id?: StringFilter<"ChannelCategoryAssignment"> | string
    channelId?: StringFilter<"ChannelCategoryAssignment"> | string
    categoryId?: StringFilter<"ChannelCategoryAssignment"> | string
  }

  export type MessageCategoryUpsertWithWhereUniqueWithoutChannelInput = {
    where: MessageCategoryWhereUniqueInput
    update: XOR<MessageCategoryUpdateWithoutChannelInput, MessageCategoryUncheckedUpdateWithoutChannelInput>
    create: XOR<MessageCategoryCreateWithoutChannelInput, MessageCategoryUncheckedCreateWithoutChannelInput>
  }

  export type MessageCategoryUpdateWithWhereUniqueWithoutChannelInput = {
    where: MessageCategoryWhereUniqueInput
    data: XOR<MessageCategoryUpdateWithoutChannelInput, MessageCategoryUncheckedUpdateWithoutChannelInput>
  }

  export type MessageCategoryUpdateManyWithWhereWithoutChannelInput = {
    where: MessageCategoryScalarWhereInput
    data: XOR<MessageCategoryUpdateManyMutationInput, MessageCategoryUncheckedUpdateManyWithoutChannelInput>
  }

  export type ChannelVisitUpsertWithWhereUniqueWithoutChannelInput = {
    where: ChannelVisitWhereUniqueInput
    update: XOR<ChannelVisitUpdateWithoutChannelInput, ChannelVisitUncheckedUpdateWithoutChannelInput>
    create: XOR<ChannelVisitCreateWithoutChannelInput, ChannelVisitUncheckedCreateWithoutChannelInput>
  }

  export type ChannelVisitUpdateWithWhereUniqueWithoutChannelInput = {
    where: ChannelVisitWhereUniqueInput
    data: XOR<ChannelVisitUpdateWithoutChannelInput, ChannelVisitUncheckedUpdateWithoutChannelInput>
  }

  export type ChannelVisitUpdateManyWithWhereWithoutChannelInput = {
    where: ChannelVisitScalarWhereInput
    data: XOR<ChannelVisitUpdateManyMutationInput, ChannelVisitUncheckedUpdateManyWithoutChannelInput>
  }

  export type ChannelCreateWithoutMessagesInput = {
    id?: string
    title: string
    description?: string | null
    websiteUrl?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: string | null
    icon?: string
    isPublic?: boolean
    isHidden?: boolean
    searchExactOnly?: boolean
    passwordHash?: string | null
    referenceCode?: string | null
    verificationStatus?: $Enums.VerificationStatus
    approvalPolicy?: $Enums.ApprovalPolicy
    memberCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedChannelsInput
    organization: OrganizationCreateNestedOneWithoutChannelsInput
    parent?: ChannelCreateNestedOneWithoutSubchannelsInput
    subchannels?: ChannelCreateNestedManyWithoutParentInput
    subscriptions?: ChannelSubscriptionCreateNestedManyWithoutChannelInput
    invitationLinks?: InvitationLinkCreateNestedManyWithoutChannelInput
    qrCodes?: QrCodeCreateNestedManyWithoutChannelInput
    approvers?: ChannelApproverCreateNestedManyWithoutChannelInput
    verificationDocs?: ChannelVerificationDocumentCreateNestedManyWithoutChannelInput
    categories?: ChannelCategoryAssignmentCreateNestedManyWithoutChannelInput
    messageCategories?: MessageCategoryCreateNestedManyWithoutChannelInput
    visits?: ChannelVisitCreateNestedManyWithoutChannelInput
  }

  export type ChannelUncheckedCreateWithoutMessagesInput = {
    id?: string
    title: string
    description?: string | null
    websiteUrl?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: string | null
    icon?: string
    parentId?: string | null
    ownerId: string
    organizationId: string
    isPublic?: boolean
    isHidden?: boolean
    searchExactOnly?: boolean
    passwordHash?: string | null
    referenceCode?: string | null
    verificationStatus?: $Enums.VerificationStatus
    approvalPolicy?: $Enums.ApprovalPolicy
    memberCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    subchannels?: ChannelUncheckedCreateNestedManyWithoutParentInput
    subscriptions?: ChannelSubscriptionUncheckedCreateNestedManyWithoutChannelInput
    invitationLinks?: InvitationLinkUncheckedCreateNestedManyWithoutChannelInput
    qrCodes?: QrCodeUncheckedCreateNestedManyWithoutChannelInput
    approvers?: ChannelApproverUncheckedCreateNestedManyWithoutChannelInput
    verificationDocs?: ChannelVerificationDocumentUncheckedCreateNestedManyWithoutChannelInput
    categories?: ChannelCategoryAssignmentUncheckedCreateNestedManyWithoutChannelInput
    messageCategories?: MessageCategoryUncheckedCreateNestedManyWithoutChannelInput
    visits?: ChannelVisitUncheckedCreateNestedManyWithoutChannelInput
  }

  export type ChannelCreateOrConnectWithoutMessagesInput = {
    where: ChannelWhereUniqueInput
    create: XOR<ChannelCreateWithoutMessagesInput, ChannelUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutMessagesSentInput = {
    id?: string
    email: string
    username: string
    fullName?: string | null
    avatarUrl?: string | null
    passwordHash?: string | null
    deviceId?: string | null
    isGuest?: boolean
    phoneNumber?: string | null
    isPhoneVerified?: boolean
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    isAdmin?: boolean
    isCoordinator?: boolean
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedChannels?: ChannelCreateNestedManyWithoutOwnerInput
    messagesOverrideSet?: MessageCreateNestedManyWithoutOverrideSetterInput
    subscriptions?: ChannelSubscriptionCreateNestedManyWithoutUserInput
    invitationLinks?: InvitationLinkCreateNestedManyWithoutCreatorInput
    qrCodes?: QrCodeCreateNestedManyWithoutCreatorInput
    messageDeliveries?: MessageDeliveryCreateNestedManyWithoutUserInput
    messageApprovals?: MessageApprovalCreateNestedManyWithoutApproverInput
    messageRevisionsEdited?: MessageRevisionCreateNestedManyWithoutEditorInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    messagingSettings?: UserMessagingSettingCreateNestedManyWithoutUserInput
    approverAssignments?: ChannelApproverCreateNestedManyWithoutUserInput
    createdCategories?: MessageCategoryCreateNestedManyWithoutCreatorInput
    messageViews?: MessageViewCreateNestedManyWithoutUserInput
    channelVisits?: ChannelVisitCreateNestedManyWithoutUserInput
    createdForms?: FormCreateNestedManyWithoutUserInput
    organizedEvents?: EventCreateNestedManyWithoutOrganizerInput
  }

  export type UserUncheckedCreateWithoutMessagesSentInput = {
    id?: string
    email: string
    username: string
    fullName?: string | null
    avatarUrl?: string | null
    passwordHash?: string | null
    deviceId?: string | null
    isGuest?: boolean
    phoneNumber?: string | null
    isPhoneVerified?: boolean
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    isAdmin?: boolean
    isCoordinator?: boolean
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedChannels?: ChannelUncheckedCreateNestedManyWithoutOwnerInput
    messagesOverrideSet?: MessageUncheckedCreateNestedManyWithoutOverrideSetterInput
    subscriptions?: ChannelSubscriptionUncheckedCreateNestedManyWithoutUserInput
    invitationLinks?: InvitationLinkUncheckedCreateNestedManyWithoutCreatorInput
    qrCodes?: QrCodeUncheckedCreateNestedManyWithoutCreatorInput
    messageDeliveries?: MessageDeliveryUncheckedCreateNestedManyWithoutUserInput
    messageApprovals?: MessageApprovalUncheckedCreateNestedManyWithoutApproverInput
    messageRevisionsEdited?: MessageRevisionUncheckedCreateNestedManyWithoutEditorInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    messagingSettings?: UserMessagingSettingUncheckedCreateNestedManyWithoutUserInput
    approverAssignments?: ChannelApproverUncheckedCreateNestedManyWithoutUserInput
    createdCategories?: MessageCategoryUncheckedCreateNestedManyWithoutCreatorInput
    messageViews?: MessageViewUncheckedCreateNestedManyWithoutUserInput
    channelVisits?: ChannelVisitUncheckedCreateNestedManyWithoutUserInput
    createdForms?: FormUncheckedCreateNestedManyWithoutUserInput
    organizedEvents?: EventUncheckedCreateNestedManyWithoutOrganizerInput
  }

  export type UserCreateOrConnectWithoutMessagesSentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessagesSentInput, UserUncheckedCreateWithoutMessagesSentInput>
  }

  export type MessageCategoryCreateWithoutMessagesInput = {
    id?: string
    name: string
    scope?: $Enums.CategoryScope
    createdAt?: Date | string
    channel?: ChannelCreateNestedOneWithoutMessageCategoriesInput
    creator?: UserCreateNestedOneWithoutCreatedCategoriesInput
  }

  export type MessageCategoryUncheckedCreateWithoutMessagesInput = {
    id?: string
    name: string
    scope?: $Enums.CategoryScope
    channelId?: string | null
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type MessageCategoryCreateOrConnectWithoutMessagesInput = {
    where: MessageCategoryWhereUniqueInput
    create: XOR<MessageCategoryCreateWithoutMessagesInput, MessageCategoryUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutMessagesOverrideSetInput = {
    id?: string
    email: string
    username: string
    fullName?: string | null
    avatarUrl?: string | null
    passwordHash?: string | null
    deviceId?: string | null
    isGuest?: boolean
    phoneNumber?: string | null
    isPhoneVerified?: boolean
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    isAdmin?: boolean
    isCoordinator?: boolean
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedChannels?: ChannelCreateNestedManyWithoutOwnerInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    subscriptions?: ChannelSubscriptionCreateNestedManyWithoutUserInput
    invitationLinks?: InvitationLinkCreateNestedManyWithoutCreatorInput
    qrCodes?: QrCodeCreateNestedManyWithoutCreatorInput
    messageDeliveries?: MessageDeliveryCreateNestedManyWithoutUserInput
    messageApprovals?: MessageApprovalCreateNestedManyWithoutApproverInput
    messageRevisionsEdited?: MessageRevisionCreateNestedManyWithoutEditorInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    messagingSettings?: UserMessagingSettingCreateNestedManyWithoutUserInput
    approverAssignments?: ChannelApproverCreateNestedManyWithoutUserInput
    createdCategories?: MessageCategoryCreateNestedManyWithoutCreatorInput
    messageViews?: MessageViewCreateNestedManyWithoutUserInput
    channelVisits?: ChannelVisitCreateNestedManyWithoutUserInput
    createdForms?: FormCreateNestedManyWithoutUserInput
    organizedEvents?: EventCreateNestedManyWithoutOrganizerInput
  }

  export type UserUncheckedCreateWithoutMessagesOverrideSetInput = {
    id?: string
    email: string
    username: string
    fullName?: string | null
    avatarUrl?: string | null
    passwordHash?: string | null
    deviceId?: string | null
    isGuest?: boolean
    phoneNumber?: string | null
    isPhoneVerified?: boolean
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    isAdmin?: boolean
    isCoordinator?: boolean
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedChannels?: ChannelUncheckedCreateNestedManyWithoutOwnerInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    subscriptions?: ChannelSubscriptionUncheckedCreateNestedManyWithoutUserInput
    invitationLinks?: InvitationLinkUncheckedCreateNestedManyWithoutCreatorInput
    qrCodes?: QrCodeUncheckedCreateNestedManyWithoutCreatorInput
    messageDeliveries?: MessageDeliveryUncheckedCreateNestedManyWithoutUserInput
    messageApprovals?: MessageApprovalUncheckedCreateNestedManyWithoutApproverInput
    messageRevisionsEdited?: MessageRevisionUncheckedCreateNestedManyWithoutEditorInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    messagingSettings?: UserMessagingSettingUncheckedCreateNestedManyWithoutUserInput
    approverAssignments?: ChannelApproverUncheckedCreateNestedManyWithoutUserInput
    createdCategories?: MessageCategoryUncheckedCreateNestedManyWithoutCreatorInput
    messageViews?: MessageViewUncheckedCreateNestedManyWithoutUserInput
    channelVisits?: ChannelVisitUncheckedCreateNestedManyWithoutUserInput
    createdForms?: FormUncheckedCreateNestedManyWithoutUserInput
    organizedEvents?: EventUncheckedCreateNestedManyWithoutOrganizerInput
  }

  export type UserCreateOrConnectWithoutMessagesOverrideSetInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessagesOverrideSetInput, UserUncheckedCreateWithoutMessagesOverrideSetInput>
  }

  export type MessageDeliveryCreateWithoutMessageInput = {
    id?: string
    deliveryStatus?: $Enums.DeliveryStatus
    deliveryMethod?: $Enums.DeliveryMethod | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutMessageDeliveriesInput
  }

  export type MessageDeliveryUncheckedCreateWithoutMessageInput = {
    id?: string
    userId: string
    deliveryStatus?: $Enums.DeliveryStatus
    deliveryMethod?: $Enums.DeliveryMethod | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MessageDeliveryCreateOrConnectWithoutMessageInput = {
    where: MessageDeliveryWhereUniqueInput
    create: XOR<MessageDeliveryCreateWithoutMessageInput, MessageDeliveryUncheckedCreateWithoutMessageInput>
  }

  export type MessageDeliveryCreateManyMessageInputEnvelope = {
    data: MessageDeliveryCreateManyMessageInput | MessageDeliveryCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type MessageApprovalCreateWithoutMessageInput = {
    id?: string
    status?: $Enums.ApprovalStatus
    decidedAt?: Date | string | null
    approver: UserCreateNestedOneWithoutMessageApprovalsInput
  }

  export type MessageApprovalUncheckedCreateWithoutMessageInput = {
    id?: string
    approverId: string
    status?: $Enums.ApprovalStatus
    decidedAt?: Date | string | null
  }

  export type MessageApprovalCreateOrConnectWithoutMessageInput = {
    where: MessageApprovalWhereUniqueInput
    create: XOR<MessageApprovalCreateWithoutMessageInput, MessageApprovalUncheckedCreateWithoutMessageInput>
  }

  export type MessageApprovalCreateManyMessageInputEnvelope = {
    data: MessageApprovalCreateManyMessageInput | MessageApprovalCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type MessageAttachmentCreateWithoutMessageInput = {
    id?: string
    type: $Enums.AttachmentType
    url: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MessageAttachmentUncheckedCreateWithoutMessageInput = {
    id?: string
    type: $Enums.AttachmentType
    url: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MessageAttachmentCreateOrConnectWithoutMessageInput = {
    where: MessageAttachmentWhereUniqueInput
    create: XOR<MessageAttachmentCreateWithoutMessageInput, MessageAttachmentUncheckedCreateWithoutMessageInput>
  }

  export type MessageAttachmentCreateManyMessageInputEnvelope = {
    data: MessageAttachmentCreateManyMessageInput | MessageAttachmentCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type MessageRevisionCreateWithoutMessageInput = {
    id?: string
    previousContent: string
    previousCategoryId?: string | null
    previousPriority: $Enums.MessagePriority
    previousIsImmediate: boolean
    previousDeliveryMethod: $Enums.DeliveryMethod
    changedAt?: Date | string
    editor: UserCreateNestedOneWithoutMessageRevisionsEditedInput
  }

  export type MessageRevisionUncheckedCreateWithoutMessageInput = {
    id?: string
    editorId: string
    previousContent: string
    previousCategoryId?: string | null
    previousPriority: $Enums.MessagePriority
    previousIsImmediate: boolean
    previousDeliveryMethod: $Enums.DeliveryMethod
    changedAt?: Date | string
  }

  export type MessageRevisionCreateOrConnectWithoutMessageInput = {
    where: MessageRevisionWhereUniqueInput
    create: XOR<MessageRevisionCreateWithoutMessageInput, MessageRevisionUncheckedCreateWithoutMessageInput>
  }

  export type MessageRevisionCreateManyMessageInputEnvelope = {
    data: MessageRevisionCreateManyMessageInput | MessageRevisionCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type MessageViewCreateWithoutMessageInput = {
    id?: string
    viewedAt?: Date | string
    user?: UserCreateNestedOneWithoutMessageViewsInput
  }

  export type MessageViewUncheckedCreateWithoutMessageInput = {
    id?: string
    userId?: string | null
    viewedAt?: Date | string
  }

  export type MessageViewCreateOrConnectWithoutMessageInput = {
    where: MessageViewWhereUniqueInput
    create: XOR<MessageViewCreateWithoutMessageInput, MessageViewUncheckedCreateWithoutMessageInput>
  }

  export type MessageViewCreateManyMessageInputEnvelope = {
    data: MessageViewCreateManyMessageInput | MessageViewCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type ChannelUpsertWithoutMessagesInput = {
    update: XOR<ChannelUpdateWithoutMessagesInput, ChannelUncheckedUpdateWithoutMessagesInput>
    create: XOR<ChannelCreateWithoutMessagesInput, ChannelUncheckedCreateWithoutMessagesInput>
    where?: ChannelWhereInput
  }

  export type ChannelUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ChannelWhereInput
    data: XOR<ChannelUpdateWithoutMessagesInput, ChannelUncheckedUpdateWithoutMessagesInput>
  }

  export type ChannelUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    searchExactOnly?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    approvalPolicy?: EnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy
    memberCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedChannelsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutChannelsNestedInput
    parent?: ChannelUpdateOneWithoutSubchannelsNestedInput
    subchannels?: ChannelUpdateManyWithoutParentNestedInput
    subscriptions?: ChannelSubscriptionUpdateManyWithoutChannelNestedInput
    invitationLinks?: InvitationLinkUpdateManyWithoutChannelNestedInput
    qrCodes?: QrCodeUpdateManyWithoutChannelNestedInput
    approvers?: ChannelApproverUpdateManyWithoutChannelNestedInput
    verificationDocs?: ChannelVerificationDocumentUpdateManyWithoutChannelNestedInput
    categories?: ChannelCategoryAssignmentUpdateManyWithoutChannelNestedInput
    messageCategories?: MessageCategoryUpdateManyWithoutChannelNestedInput
    visits?: ChannelVisitUpdateManyWithoutChannelNestedInput
  }

  export type ChannelUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    searchExactOnly?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    approvalPolicy?: EnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy
    memberCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subchannels?: ChannelUncheckedUpdateManyWithoutParentNestedInput
    subscriptions?: ChannelSubscriptionUncheckedUpdateManyWithoutChannelNestedInput
    invitationLinks?: InvitationLinkUncheckedUpdateManyWithoutChannelNestedInput
    qrCodes?: QrCodeUncheckedUpdateManyWithoutChannelNestedInput
    approvers?: ChannelApproverUncheckedUpdateManyWithoutChannelNestedInput
    verificationDocs?: ChannelVerificationDocumentUncheckedUpdateManyWithoutChannelNestedInput
    categories?: ChannelCategoryAssignmentUncheckedUpdateManyWithoutChannelNestedInput
    messageCategories?: MessageCategoryUncheckedUpdateManyWithoutChannelNestedInput
    visits?: ChannelVisitUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type UserUpsertWithoutMessagesSentInput = {
    update: XOR<UserUpdateWithoutMessagesSentInput, UserUncheckedUpdateWithoutMessagesSentInput>
    create: XOR<UserCreateWithoutMessagesSentInput, UserUncheckedCreateWithoutMessagesSentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessagesSentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessagesSentInput, UserUncheckedUpdateWithoutMessagesSentInput>
  }

  export type UserUpdateWithoutMessagesSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isCoordinator?: BoolFieldUpdateOperationsInput | boolean
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedChannels?: ChannelUpdateManyWithoutOwnerNestedInput
    messagesOverrideSet?: MessageUpdateManyWithoutOverrideSetterNestedInput
    subscriptions?: ChannelSubscriptionUpdateManyWithoutUserNestedInput
    invitationLinks?: InvitationLinkUpdateManyWithoutCreatorNestedInput
    qrCodes?: QrCodeUpdateManyWithoutCreatorNestedInput
    messageDeliveries?: MessageDeliveryUpdateManyWithoutUserNestedInput
    messageApprovals?: MessageApprovalUpdateManyWithoutApproverNestedInput
    messageRevisionsEdited?: MessageRevisionUpdateManyWithoutEditorNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    messagingSettings?: UserMessagingSettingUpdateManyWithoutUserNestedInput
    approverAssignments?: ChannelApproverUpdateManyWithoutUserNestedInput
    createdCategories?: MessageCategoryUpdateManyWithoutCreatorNestedInput
    messageViews?: MessageViewUpdateManyWithoutUserNestedInput
    channelVisits?: ChannelVisitUpdateManyWithoutUserNestedInput
    createdForms?: FormUpdateManyWithoutUserNestedInput
    organizedEvents?: EventUpdateManyWithoutOrganizerNestedInput
  }

  export type UserUncheckedUpdateWithoutMessagesSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isCoordinator?: BoolFieldUpdateOperationsInput | boolean
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedChannels?: ChannelUncheckedUpdateManyWithoutOwnerNestedInput
    messagesOverrideSet?: MessageUncheckedUpdateManyWithoutOverrideSetterNestedInput
    subscriptions?: ChannelSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invitationLinks?: InvitationLinkUncheckedUpdateManyWithoutCreatorNestedInput
    qrCodes?: QrCodeUncheckedUpdateManyWithoutCreatorNestedInput
    messageDeliveries?: MessageDeliveryUncheckedUpdateManyWithoutUserNestedInput
    messageApprovals?: MessageApprovalUncheckedUpdateManyWithoutApproverNestedInput
    messageRevisionsEdited?: MessageRevisionUncheckedUpdateManyWithoutEditorNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    messagingSettings?: UserMessagingSettingUncheckedUpdateManyWithoutUserNestedInput
    approverAssignments?: ChannelApproverUncheckedUpdateManyWithoutUserNestedInput
    createdCategories?: MessageCategoryUncheckedUpdateManyWithoutCreatorNestedInput
    messageViews?: MessageViewUncheckedUpdateManyWithoutUserNestedInput
    channelVisits?: ChannelVisitUncheckedUpdateManyWithoutUserNestedInput
    createdForms?: FormUncheckedUpdateManyWithoutUserNestedInput
    organizedEvents?: EventUncheckedUpdateManyWithoutOrganizerNestedInput
  }

  export type MessageCategoryUpsertWithoutMessagesInput = {
    update: XOR<MessageCategoryUpdateWithoutMessagesInput, MessageCategoryUncheckedUpdateWithoutMessagesInput>
    create: XOR<MessageCategoryCreateWithoutMessagesInput, MessageCategoryUncheckedCreateWithoutMessagesInput>
    where?: MessageCategoryWhereInput
  }

  export type MessageCategoryUpdateToOneWithWhereWithoutMessagesInput = {
    where?: MessageCategoryWhereInput
    data: XOR<MessageCategoryUpdateWithoutMessagesInput, MessageCategoryUncheckedUpdateWithoutMessagesInput>
  }

  export type MessageCategoryUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    scope?: EnumCategoryScopeFieldUpdateOperationsInput | $Enums.CategoryScope
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: ChannelUpdateOneWithoutMessageCategoriesNestedInput
    creator?: UserUpdateOneWithoutCreatedCategoriesNestedInput
  }

  export type MessageCategoryUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    scope?: EnumCategoryScopeFieldUpdateOperationsInput | $Enums.CategoryScope
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutMessagesOverrideSetInput = {
    update: XOR<UserUpdateWithoutMessagesOverrideSetInput, UserUncheckedUpdateWithoutMessagesOverrideSetInput>
    create: XOR<UserCreateWithoutMessagesOverrideSetInput, UserUncheckedCreateWithoutMessagesOverrideSetInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessagesOverrideSetInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessagesOverrideSetInput, UserUncheckedUpdateWithoutMessagesOverrideSetInput>
  }

  export type UserUpdateWithoutMessagesOverrideSetInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isCoordinator?: BoolFieldUpdateOperationsInput | boolean
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedChannels?: ChannelUpdateManyWithoutOwnerNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    subscriptions?: ChannelSubscriptionUpdateManyWithoutUserNestedInput
    invitationLinks?: InvitationLinkUpdateManyWithoutCreatorNestedInput
    qrCodes?: QrCodeUpdateManyWithoutCreatorNestedInput
    messageDeliveries?: MessageDeliveryUpdateManyWithoutUserNestedInput
    messageApprovals?: MessageApprovalUpdateManyWithoutApproverNestedInput
    messageRevisionsEdited?: MessageRevisionUpdateManyWithoutEditorNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    messagingSettings?: UserMessagingSettingUpdateManyWithoutUserNestedInput
    approverAssignments?: ChannelApproverUpdateManyWithoutUserNestedInput
    createdCategories?: MessageCategoryUpdateManyWithoutCreatorNestedInput
    messageViews?: MessageViewUpdateManyWithoutUserNestedInput
    channelVisits?: ChannelVisitUpdateManyWithoutUserNestedInput
    createdForms?: FormUpdateManyWithoutUserNestedInput
    organizedEvents?: EventUpdateManyWithoutOrganizerNestedInput
  }

  export type UserUncheckedUpdateWithoutMessagesOverrideSetInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isCoordinator?: BoolFieldUpdateOperationsInput | boolean
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedChannels?: ChannelUncheckedUpdateManyWithoutOwnerNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    subscriptions?: ChannelSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invitationLinks?: InvitationLinkUncheckedUpdateManyWithoutCreatorNestedInput
    qrCodes?: QrCodeUncheckedUpdateManyWithoutCreatorNestedInput
    messageDeliveries?: MessageDeliveryUncheckedUpdateManyWithoutUserNestedInput
    messageApprovals?: MessageApprovalUncheckedUpdateManyWithoutApproverNestedInput
    messageRevisionsEdited?: MessageRevisionUncheckedUpdateManyWithoutEditorNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    messagingSettings?: UserMessagingSettingUncheckedUpdateManyWithoutUserNestedInput
    approverAssignments?: ChannelApproverUncheckedUpdateManyWithoutUserNestedInput
    createdCategories?: MessageCategoryUncheckedUpdateManyWithoutCreatorNestedInput
    messageViews?: MessageViewUncheckedUpdateManyWithoutUserNestedInput
    channelVisits?: ChannelVisitUncheckedUpdateManyWithoutUserNestedInput
    createdForms?: FormUncheckedUpdateManyWithoutUserNestedInput
    organizedEvents?: EventUncheckedUpdateManyWithoutOrganizerNestedInput
  }

  export type MessageDeliveryUpsertWithWhereUniqueWithoutMessageInput = {
    where: MessageDeliveryWhereUniqueInput
    update: XOR<MessageDeliveryUpdateWithoutMessageInput, MessageDeliveryUncheckedUpdateWithoutMessageInput>
    create: XOR<MessageDeliveryCreateWithoutMessageInput, MessageDeliveryUncheckedCreateWithoutMessageInput>
  }

  export type MessageDeliveryUpdateWithWhereUniqueWithoutMessageInput = {
    where: MessageDeliveryWhereUniqueInput
    data: XOR<MessageDeliveryUpdateWithoutMessageInput, MessageDeliveryUncheckedUpdateWithoutMessageInput>
  }

  export type MessageDeliveryUpdateManyWithWhereWithoutMessageInput = {
    where: MessageDeliveryScalarWhereInput
    data: XOR<MessageDeliveryUpdateManyMutationInput, MessageDeliveryUncheckedUpdateManyWithoutMessageInput>
  }

  export type MessageApprovalUpsertWithWhereUniqueWithoutMessageInput = {
    where: MessageApprovalWhereUniqueInput
    update: XOR<MessageApprovalUpdateWithoutMessageInput, MessageApprovalUncheckedUpdateWithoutMessageInput>
    create: XOR<MessageApprovalCreateWithoutMessageInput, MessageApprovalUncheckedCreateWithoutMessageInput>
  }

  export type MessageApprovalUpdateWithWhereUniqueWithoutMessageInput = {
    where: MessageApprovalWhereUniqueInput
    data: XOR<MessageApprovalUpdateWithoutMessageInput, MessageApprovalUncheckedUpdateWithoutMessageInput>
  }

  export type MessageApprovalUpdateManyWithWhereWithoutMessageInput = {
    where: MessageApprovalScalarWhereInput
    data: XOR<MessageApprovalUpdateManyMutationInput, MessageApprovalUncheckedUpdateManyWithoutMessageInput>
  }

  export type MessageAttachmentUpsertWithWhereUniqueWithoutMessageInput = {
    where: MessageAttachmentWhereUniqueInput
    update: XOR<MessageAttachmentUpdateWithoutMessageInput, MessageAttachmentUncheckedUpdateWithoutMessageInput>
    create: XOR<MessageAttachmentCreateWithoutMessageInput, MessageAttachmentUncheckedCreateWithoutMessageInput>
  }

  export type MessageAttachmentUpdateWithWhereUniqueWithoutMessageInput = {
    where: MessageAttachmentWhereUniqueInput
    data: XOR<MessageAttachmentUpdateWithoutMessageInput, MessageAttachmentUncheckedUpdateWithoutMessageInput>
  }

  export type MessageAttachmentUpdateManyWithWhereWithoutMessageInput = {
    where: MessageAttachmentScalarWhereInput
    data: XOR<MessageAttachmentUpdateManyMutationInput, MessageAttachmentUncheckedUpdateManyWithoutMessageInput>
  }

  export type MessageAttachmentScalarWhereInput = {
    AND?: MessageAttachmentScalarWhereInput | MessageAttachmentScalarWhereInput[]
    OR?: MessageAttachmentScalarWhereInput[]
    NOT?: MessageAttachmentScalarWhereInput | MessageAttachmentScalarWhereInput[]
    id?: StringFilter<"MessageAttachment"> | string
    messageId?: StringFilter<"MessageAttachment"> | string
    type?: EnumAttachmentTypeFilter<"MessageAttachment"> | $Enums.AttachmentType
    url?: StringFilter<"MessageAttachment"> | string
    metadata?: JsonNullableFilter<"MessageAttachment">
    createdAt?: DateTimeFilter<"MessageAttachment"> | Date | string
  }

  export type MessageRevisionUpsertWithWhereUniqueWithoutMessageInput = {
    where: MessageRevisionWhereUniqueInput
    update: XOR<MessageRevisionUpdateWithoutMessageInput, MessageRevisionUncheckedUpdateWithoutMessageInput>
    create: XOR<MessageRevisionCreateWithoutMessageInput, MessageRevisionUncheckedCreateWithoutMessageInput>
  }

  export type MessageRevisionUpdateWithWhereUniqueWithoutMessageInput = {
    where: MessageRevisionWhereUniqueInput
    data: XOR<MessageRevisionUpdateWithoutMessageInput, MessageRevisionUncheckedUpdateWithoutMessageInput>
  }

  export type MessageRevisionUpdateManyWithWhereWithoutMessageInput = {
    where: MessageRevisionScalarWhereInput
    data: XOR<MessageRevisionUpdateManyMutationInput, MessageRevisionUncheckedUpdateManyWithoutMessageInput>
  }

  export type MessageViewUpsertWithWhereUniqueWithoutMessageInput = {
    where: MessageViewWhereUniqueInput
    update: XOR<MessageViewUpdateWithoutMessageInput, MessageViewUncheckedUpdateWithoutMessageInput>
    create: XOR<MessageViewCreateWithoutMessageInput, MessageViewUncheckedCreateWithoutMessageInput>
  }

  export type MessageViewUpdateWithWhereUniqueWithoutMessageInput = {
    where: MessageViewWhereUniqueInput
    data: XOR<MessageViewUpdateWithoutMessageInput, MessageViewUncheckedUpdateWithoutMessageInput>
  }

  export type MessageViewUpdateManyWithWhereWithoutMessageInput = {
    where: MessageViewScalarWhereInput
    data: XOR<MessageViewUpdateManyMutationInput, MessageViewUncheckedUpdateManyWithoutMessageInput>
  }

  export type UserCreateWithoutSubscriptionsInput = {
    id?: string
    email: string
    username: string
    fullName?: string | null
    avatarUrl?: string | null
    passwordHash?: string | null
    deviceId?: string | null
    isGuest?: boolean
    phoneNumber?: string | null
    isPhoneVerified?: boolean
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    isAdmin?: boolean
    isCoordinator?: boolean
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedChannels?: ChannelCreateNestedManyWithoutOwnerInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesOverrideSet?: MessageCreateNestedManyWithoutOverrideSetterInput
    invitationLinks?: InvitationLinkCreateNestedManyWithoutCreatorInput
    qrCodes?: QrCodeCreateNestedManyWithoutCreatorInput
    messageDeliveries?: MessageDeliveryCreateNestedManyWithoutUserInput
    messageApprovals?: MessageApprovalCreateNestedManyWithoutApproverInput
    messageRevisionsEdited?: MessageRevisionCreateNestedManyWithoutEditorInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    messagingSettings?: UserMessagingSettingCreateNestedManyWithoutUserInput
    approverAssignments?: ChannelApproverCreateNestedManyWithoutUserInput
    createdCategories?: MessageCategoryCreateNestedManyWithoutCreatorInput
    messageViews?: MessageViewCreateNestedManyWithoutUserInput
    channelVisits?: ChannelVisitCreateNestedManyWithoutUserInput
    createdForms?: FormCreateNestedManyWithoutUserInput
    organizedEvents?: EventCreateNestedManyWithoutOrganizerInput
  }

  export type UserUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    email: string
    username: string
    fullName?: string | null
    avatarUrl?: string | null
    passwordHash?: string | null
    deviceId?: string | null
    isGuest?: boolean
    phoneNumber?: string | null
    isPhoneVerified?: boolean
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    isAdmin?: boolean
    isCoordinator?: boolean
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedChannels?: ChannelUncheckedCreateNestedManyWithoutOwnerInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesOverrideSet?: MessageUncheckedCreateNestedManyWithoutOverrideSetterInput
    invitationLinks?: InvitationLinkUncheckedCreateNestedManyWithoutCreatorInput
    qrCodes?: QrCodeUncheckedCreateNestedManyWithoutCreatorInput
    messageDeliveries?: MessageDeliveryUncheckedCreateNestedManyWithoutUserInput
    messageApprovals?: MessageApprovalUncheckedCreateNestedManyWithoutApproverInput
    messageRevisionsEdited?: MessageRevisionUncheckedCreateNestedManyWithoutEditorInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    messagingSettings?: UserMessagingSettingUncheckedCreateNestedManyWithoutUserInput
    approverAssignments?: ChannelApproverUncheckedCreateNestedManyWithoutUserInput
    createdCategories?: MessageCategoryUncheckedCreateNestedManyWithoutCreatorInput
    messageViews?: MessageViewUncheckedCreateNestedManyWithoutUserInput
    channelVisits?: ChannelVisitUncheckedCreateNestedManyWithoutUserInput
    createdForms?: FormUncheckedCreateNestedManyWithoutUserInput
    organizedEvents?: EventUncheckedCreateNestedManyWithoutOrganizerInput
  }

  export type UserCreateOrConnectWithoutSubscriptionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
  }

  export type ChannelCreateWithoutSubscriptionsInput = {
    id?: string
    title: string
    description?: string | null
    websiteUrl?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: string | null
    icon?: string
    isPublic?: boolean
    isHidden?: boolean
    searchExactOnly?: boolean
    passwordHash?: string | null
    referenceCode?: string | null
    verificationStatus?: $Enums.VerificationStatus
    approvalPolicy?: $Enums.ApprovalPolicy
    memberCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedChannelsInput
    organization: OrganizationCreateNestedOneWithoutChannelsInput
    parent?: ChannelCreateNestedOneWithoutSubchannelsInput
    subchannels?: ChannelCreateNestedManyWithoutParentInput
    messages?: MessageCreateNestedManyWithoutChannelInput
    invitationLinks?: InvitationLinkCreateNestedManyWithoutChannelInput
    qrCodes?: QrCodeCreateNestedManyWithoutChannelInput
    approvers?: ChannelApproverCreateNestedManyWithoutChannelInput
    verificationDocs?: ChannelVerificationDocumentCreateNestedManyWithoutChannelInput
    categories?: ChannelCategoryAssignmentCreateNestedManyWithoutChannelInput
    messageCategories?: MessageCategoryCreateNestedManyWithoutChannelInput
    visits?: ChannelVisitCreateNestedManyWithoutChannelInput
  }

  export type ChannelUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    title: string
    description?: string | null
    websiteUrl?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: string | null
    icon?: string
    parentId?: string | null
    ownerId: string
    organizationId: string
    isPublic?: boolean
    isHidden?: boolean
    searchExactOnly?: boolean
    passwordHash?: string | null
    referenceCode?: string | null
    verificationStatus?: $Enums.VerificationStatus
    approvalPolicy?: $Enums.ApprovalPolicy
    memberCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    subchannels?: ChannelUncheckedCreateNestedManyWithoutParentInput
    messages?: MessageUncheckedCreateNestedManyWithoutChannelInput
    invitationLinks?: InvitationLinkUncheckedCreateNestedManyWithoutChannelInput
    qrCodes?: QrCodeUncheckedCreateNestedManyWithoutChannelInput
    approvers?: ChannelApproverUncheckedCreateNestedManyWithoutChannelInput
    verificationDocs?: ChannelVerificationDocumentUncheckedCreateNestedManyWithoutChannelInput
    categories?: ChannelCategoryAssignmentUncheckedCreateNestedManyWithoutChannelInput
    messageCategories?: MessageCategoryUncheckedCreateNestedManyWithoutChannelInput
    visits?: ChannelVisitUncheckedCreateNestedManyWithoutChannelInput
  }

  export type ChannelCreateOrConnectWithoutSubscriptionsInput = {
    where: ChannelWhereUniqueInput
    create: XOR<ChannelCreateWithoutSubscriptionsInput, ChannelUncheckedCreateWithoutSubscriptionsInput>
  }

  export type UserUpsertWithoutSubscriptionsInput = {
    update: XOR<UserUpdateWithoutSubscriptionsInput, UserUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubscriptionsInput, UserUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type UserUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isCoordinator?: BoolFieldUpdateOperationsInput | boolean
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedChannels?: ChannelUpdateManyWithoutOwnerNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesOverrideSet?: MessageUpdateManyWithoutOverrideSetterNestedInput
    invitationLinks?: InvitationLinkUpdateManyWithoutCreatorNestedInput
    qrCodes?: QrCodeUpdateManyWithoutCreatorNestedInput
    messageDeliveries?: MessageDeliveryUpdateManyWithoutUserNestedInput
    messageApprovals?: MessageApprovalUpdateManyWithoutApproverNestedInput
    messageRevisionsEdited?: MessageRevisionUpdateManyWithoutEditorNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    messagingSettings?: UserMessagingSettingUpdateManyWithoutUserNestedInput
    approverAssignments?: ChannelApproverUpdateManyWithoutUserNestedInput
    createdCategories?: MessageCategoryUpdateManyWithoutCreatorNestedInput
    messageViews?: MessageViewUpdateManyWithoutUserNestedInput
    channelVisits?: ChannelVisitUpdateManyWithoutUserNestedInput
    createdForms?: FormUpdateManyWithoutUserNestedInput
    organizedEvents?: EventUpdateManyWithoutOrganizerNestedInput
  }

  export type UserUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isCoordinator?: BoolFieldUpdateOperationsInput | boolean
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedChannels?: ChannelUncheckedUpdateManyWithoutOwnerNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesOverrideSet?: MessageUncheckedUpdateManyWithoutOverrideSetterNestedInput
    invitationLinks?: InvitationLinkUncheckedUpdateManyWithoutCreatorNestedInput
    qrCodes?: QrCodeUncheckedUpdateManyWithoutCreatorNestedInput
    messageDeliveries?: MessageDeliveryUncheckedUpdateManyWithoutUserNestedInput
    messageApprovals?: MessageApprovalUncheckedUpdateManyWithoutApproverNestedInput
    messageRevisionsEdited?: MessageRevisionUncheckedUpdateManyWithoutEditorNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    messagingSettings?: UserMessagingSettingUncheckedUpdateManyWithoutUserNestedInput
    approverAssignments?: ChannelApproverUncheckedUpdateManyWithoutUserNestedInput
    createdCategories?: MessageCategoryUncheckedUpdateManyWithoutCreatorNestedInput
    messageViews?: MessageViewUncheckedUpdateManyWithoutUserNestedInput
    channelVisits?: ChannelVisitUncheckedUpdateManyWithoutUserNestedInput
    createdForms?: FormUncheckedUpdateManyWithoutUserNestedInput
    organizedEvents?: EventUncheckedUpdateManyWithoutOrganizerNestedInput
  }

  export type ChannelUpsertWithoutSubscriptionsInput = {
    update: XOR<ChannelUpdateWithoutSubscriptionsInput, ChannelUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<ChannelCreateWithoutSubscriptionsInput, ChannelUncheckedCreateWithoutSubscriptionsInput>
    where?: ChannelWhereInput
  }

  export type ChannelUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: ChannelWhereInput
    data: XOR<ChannelUpdateWithoutSubscriptionsInput, ChannelUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type ChannelUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    searchExactOnly?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    approvalPolicy?: EnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy
    memberCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedChannelsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutChannelsNestedInput
    parent?: ChannelUpdateOneWithoutSubchannelsNestedInput
    subchannels?: ChannelUpdateManyWithoutParentNestedInput
    messages?: MessageUpdateManyWithoutChannelNestedInput
    invitationLinks?: InvitationLinkUpdateManyWithoutChannelNestedInput
    qrCodes?: QrCodeUpdateManyWithoutChannelNestedInput
    approvers?: ChannelApproverUpdateManyWithoutChannelNestedInput
    verificationDocs?: ChannelVerificationDocumentUpdateManyWithoutChannelNestedInput
    categories?: ChannelCategoryAssignmentUpdateManyWithoutChannelNestedInput
    messageCategories?: MessageCategoryUpdateManyWithoutChannelNestedInput
    visits?: ChannelVisitUpdateManyWithoutChannelNestedInput
  }

  export type ChannelUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    searchExactOnly?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    approvalPolicy?: EnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy
    memberCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subchannels?: ChannelUncheckedUpdateManyWithoutParentNestedInput
    messages?: MessageUncheckedUpdateManyWithoutChannelNestedInput
    invitationLinks?: InvitationLinkUncheckedUpdateManyWithoutChannelNestedInput
    qrCodes?: QrCodeUncheckedUpdateManyWithoutChannelNestedInput
    approvers?: ChannelApproverUncheckedUpdateManyWithoutChannelNestedInput
    verificationDocs?: ChannelVerificationDocumentUncheckedUpdateManyWithoutChannelNestedInput
    categories?: ChannelCategoryAssignmentUncheckedUpdateManyWithoutChannelNestedInput
    messageCategories?: MessageCategoryUncheckedUpdateManyWithoutChannelNestedInput
    visits?: ChannelVisitUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type MessageCreateWithoutDeliveriesInput = {
    id?: string
    content: string
    durationSeconds?: number
    expiresAt?: Date | string | null
    isEmergency?: boolean
    isImmediate?: boolean
    priority?: $Enums.MessagePriority
    approvalOverride?: $Enums.ApprovalPolicy | null
    approvalOverrideSetAt?: Date | string | null
    deliveryMethod?: $Enums.DeliveryMethod
    eventAt?: Date | string | null
    publishedAt?: Date | string | null
    state?: $Enums.MessageState
    createdAt?: Date | string
    updatedAt?: Date | string
    channel: ChannelCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutMessagesSentInput
    category: MessageCategoryCreateNestedOneWithoutMessagesInput
    overrideSetter?: UserCreateNestedOneWithoutMessagesOverrideSetInput
    approvals?: MessageApprovalCreateNestedManyWithoutMessageInput
    attachments?: MessageAttachmentCreateNestedManyWithoutMessageInput
    revisions?: MessageRevisionCreateNestedManyWithoutMessageInput
    views?: MessageViewCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutDeliveriesInput = {
    id?: string
    channelId: string
    senderId: string
    categoryId: string
    content: string
    durationSeconds?: number
    expiresAt?: Date | string | null
    isEmergency?: boolean
    isImmediate?: boolean
    priority?: $Enums.MessagePriority
    approvalOverride?: $Enums.ApprovalPolicy | null
    approvalOverrideSetBy?: string | null
    approvalOverrideSetAt?: Date | string | null
    deliveryMethod?: $Enums.DeliveryMethod
    eventAt?: Date | string | null
    publishedAt?: Date | string | null
    state?: $Enums.MessageState
    createdAt?: Date | string
    updatedAt?: Date | string
    approvals?: MessageApprovalUncheckedCreateNestedManyWithoutMessageInput
    attachments?: MessageAttachmentUncheckedCreateNestedManyWithoutMessageInput
    revisions?: MessageRevisionUncheckedCreateNestedManyWithoutMessageInput
    views?: MessageViewUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutDeliveriesInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutDeliveriesInput, MessageUncheckedCreateWithoutDeliveriesInput>
  }

  export type UserCreateWithoutMessageDeliveriesInput = {
    id?: string
    email: string
    username: string
    fullName?: string | null
    avatarUrl?: string | null
    passwordHash?: string | null
    deviceId?: string | null
    isGuest?: boolean
    phoneNumber?: string | null
    isPhoneVerified?: boolean
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    isAdmin?: boolean
    isCoordinator?: boolean
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedChannels?: ChannelCreateNestedManyWithoutOwnerInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesOverrideSet?: MessageCreateNestedManyWithoutOverrideSetterInput
    subscriptions?: ChannelSubscriptionCreateNestedManyWithoutUserInput
    invitationLinks?: InvitationLinkCreateNestedManyWithoutCreatorInput
    qrCodes?: QrCodeCreateNestedManyWithoutCreatorInput
    messageApprovals?: MessageApprovalCreateNestedManyWithoutApproverInput
    messageRevisionsEdited?: MessageRevisionCreateNestedManyWithoutEditorInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    messagingSettings?: UserMessagingSettingCreateNestedManyWithoutUserInput
    approverAssignments?: ChannelApproverCreateNestedManyWithoutUserInput
    createdCategories?: MessageCategoryCreateNestedManyWithoutCreatorInput
    messageViews?: MessageViewCreateNestedManyWithoutUserInput
    channelVisits?: ChannelVisitCreateNestedManyWithoutUserInput
    createdForms?: FormCreateNestedManyWithoutUserInput
    organizedEvents?: EventCreateNestedManyWithoutOrganizerInput
  }

  export type UserUncheckedCreateWithoutMessageDeliveriesInput = {
    id?: string
    email: string
    username: string
    fullName?: string | null
    avatarUrl?: string | null
    passwordHash?: string | null
    deviceId?: string | null
    isGuest?: boolean
    phoneNumber?: string | null
    isPhoneVerified?: boolean
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    isAdmin?: boolean
    isCoordinator?: boolean
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedChannels?: ChannelUncheckedCreateNestedManyWithoutOwnerInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesOverrideSet?: MessageUncheckedCreateNestedManyWithoutOverrideSetterInput
    subscriptions?: ChannelSubscriptionUncheckedCreateNestedManyWithoutUserInput
    invitationLinks?: InvitationLinkUncheckedCreateNestedManyWithoutCreatorInput
    qrCodes?: QrCodeUncheckedCreateNestedManyWithoutCreatorInput
    messageApprovals?: MessageApprovalUncheckedCreateNestedManyWithoutApproverInput
    messageRevisionsEdited?: MessageRevisionUncheckedCreateNestedManyWithoutEditorInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    messagingSettings?: UserMessagingSettingUncheckedCreateNestedManyWithoutUserInput
    approverAssignments?: ChannelApproverUncheckedCreateNestedManyWithoutUserInput
    createdCategories?: MessageCategoryUncheckedCreateNestedManyWithoutCreatorInput
    messageViews?: MessageViewUncheckedCreateNestedManyWithoutUserInput
    channelVisits?: ChannelVisitUncheckedCreateNestedManyWithoutUserInput
    createdForms?: FormUncheckedCreateNestedManyWithoutUserInput
    organizedEvents?: EventUncheckedCreateNestedManyWithoutOrganizerInput
  }

  export type UserCreateOrConnectWithoutMessageDeliveriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessageDeliveriesInput, UserUncheckedCreateWithoutMessageDeliveriesInput>
  }

  export type MessageUpsertWithoutDeliveriesInput = {
    update: XOR<MessageUpdateWithoutDeliveriesInput, MessageUncheckedUpdateWithoutDeliveriesInput>
    create: XOR<MessageCreateWithoutDeliveriesInput, MessageUncheckedCreateWithoutDeliveriesInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutDeliveriesInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutDeliveriesInput, MessageUncheckedUpdateWithoutDeliveriesInput>
  }

  export type MessageUpdateWithoutDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    durationSeconds?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    isImmediate?: BoolFieldUpdateOperationsInput | boolean
    priority?: EnumMessagePriorityFieldUpdateOperationsInput | $Enums.MessagePriority
    approvalOverride?: NullableEnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy | null
    approvalOverrideSetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    eventAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    state?: EnumMessageStateFieldUpdateOperationsInput | $Enums.MessageState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: ChannelUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutMessagesSentNestedInput
    category?: MessageCategoryUpdateOneRequiredWithoutMessagesNestedInput
    overrideSetter?: UserUpdateOneWithoutMessagesOverrideSetNestedInput
    approvals?: MessageApprovalUpdateManyWithoutMessageNestedInput
    attachments?: MessageAttachmentUpdateManyWithoutMessageNestedInput
    revisions?: MessageRevisionUpdateManyWithoutMessageNestedInput
    views?: MessageViewUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    durationSeconds?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    isImmediate?: BoolFieldUpdateOperationsInput | boolean
    priority?: EnumMessagePriorityFieldUpdateOperationsInput | $Enums.MessagePriority
    approvalOverride?: NullableEnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy | null
    approvalOverrideSetBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvalOverrideSetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    eventAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    state?: EnumMessageStateFieldUpdateOperationsInput | $Enums.MessageState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvals?: MessageApprovalUncheckedUpdateManyWithoutMessageNestedInput
    attachments?: MessageAttachmentUncheckedUpdateManyWithoutMessageNestedInput
    revisions?: MessageRevisionUncheckedUpdateManyWithoutMessageNestedInput
    views?: MessageViewUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type UserUpsertWithoutMessageDeliveriesInput = {
    update: XOR<UserUpdateWithoutMessageDeliveriesInput, UserUncheckedUpdateWithoutMessageDeliveriesInput>
    create: XOR<UserCreateWithoutMessageDeliveriesInput, UserUncheckedCreateWithoutMessageDeliveriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessageDeliveriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessageDeliveriesInput, UserUncheckedUpdateWithoutMessageDeliveriesInput>
  }

  export type UserUpdateWithoutMessageDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isCoordinator?: BoolFieldUpdateOperationsInput | boolean
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedChannels?: ChannelUpdateManyWithoutOwnerNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesOverrideSet?: MessageUpdateManyWithoutOverrideSetterNestedInput
    subscriptions?: ChannelSubscriptionUpdateManyWithoutUserNestedInput
    invitationLinks?: InvitationLinkUpdateManyWithoutCreatorNestedInput
    qrCodes?: QrCodeUpdateManyWithoutCreatorNestedInput
    messageApprovals?: MessageApprovalUpdateManyWithoutApproverNestedInput
    messageRevisionsEdited?: MessageRevisionUpdateManyWithoutEditorNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    messagingSettings?: UserMessagingSettingUpdateManyWithoutUserNestedInput
    approverAssignments?: ChannelApproverUpdateManyWithoutUserNestedInput
    createdCategories?: MessageCategoryUpdateManyWithoutCreatorNestedInput
    messageViews?: MessageViewUpdateManyWithoutUserNestedInput
    channelVisits?: ChannelVisitUpdateManyWithoutUserNestedInput
    createdForms?: FormUpdateManyWithoutUserNestedInput
    organizedEvents?: EventUpdateManyWithoutOrganizerNestedInput
  }

  export type UserUncheckedUpdateWithoutMessageDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isCoordinator?: BoolFieldUpdateOperationsInput | boolean
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedChannels?: ChannelUncheckedUpdateManyWithoutOwnerNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesOverrideSet?: MessageUncheckedUpdateManyWithoutOverrideSetterNestedInput
    subscriptions?: ChannelSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invitationLinks?: InvitationLinkUncheckedUpdateManyWithoutCreatorNestedInput
    qrCodes?: QrCodeUncheckedUpdateManyWithoutCreatorNestedInput
    messageApprovals?: MessageApprovalUncheckedUpdateManyWithoutApproverNestedInput
    messageRevisionsEdited?: MessageRevisionUncheckedUpdateManyWithoutEditorNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    messagingSettings?: UserMessagingSettingUncheckedUpdateManyWithoutUserNestedInput
    approverAssignments?: ChannelApproverUncheckedUpdateManyWithoutUserNestedInput
    createdCategories?: MessageCategoryUncheckedUpdateManyWithoutCreatorNestedInput
    messageViews?: MessageViewUncheckedUpdateManyWithoutUserNestedInput
    channelVisits?: ChannelVisitUncheckedUpdateManyWithoutUserNestedInput
    createdForms?: FormUncheckedUpdateManyWithoutUserNestedInput
    organizedEvents?: EventUncheckedUpdateManyWithoutOrganizerNestedInput
  }

  export type ChannelCreateWithoutInvitationLinksInput = {
    id?: string
    title: string
    description?: string | null
    websiteUrl?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: string | null
    icon?: string
    isPublic?: boolean
    isHidden?: boolean
    searchExactOnly?: boolean
    passwordHash?: string | null
    referenceCode?: string | null
    verificationStatus?: $Enums.VerificationStatus
    approvalPolicy?: $Enums.ApprovalPolicy
    memberCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedChannelsInput
    organization: OrganizationCreateNestedOneWithoutChannelsInput
    parent?: ChannelCreateNestedOneWithoutSubchannelsInput
    subchannels?: ChannelCreateNestedManyWithoutParentInput
    messages?: MessageCreateNestedManyWithoutChannelInput
    subscriptions?: ChannelSubscriptionCreateNestedManyWithoutChannelInput
    qrCodes?: QrCodeCreateNestedManyWithoutChannelInput
    approvers?: ChannelApproverCreateNestedManyWithoutChannelInput
    verificationDocs?: ChannelVerificationDocumentCreateNestedManyWithoutChannelInput
    categories?: ChannelCategoryAssignmentCreateNestedManyWithoutChannelInput
    messageCategories?: MessageCategoryCreateNestedManyWithoutChannelInput
    visits?: ChannelVisitCreateNestedManyWithoutChannelInput
  }

  export type ChannelUncheckedCreateWithoutInvitationLinksInput = {
    id?: string
    title: string
    description?: string | null
    websiteUrl?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: string | null
    icon?: string
    parentId?: string | null
    ownerId: string
    organizationId: string
    isPublic?: boolean
    isHidden?: boolean
    searchExactOnly?: boolean
    passwordHash?: string | null
    referenceCode?: string | null
    verificationStatus?: $Enums.VerificationStatus
    approvalPolicy?: $Enums.ApprovalPolicy
    memberCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    subchannels?: ChannelUncheckedCreateNestedManyWithoutParentInput
    messages?: MessageUncheckedCreateNestedManyWithoutChannelInput
    subscriptions?: ChannelSubscriptionUncheckedCreateNestedManyWithoutChannelInput
    qrCodes?: QrCodeUncheckedCreateNestedManyWithoutChannelInput
    approvers?: ChannelApproverUncheckedCreateNestedManyWithoutChannelInput
    verificationDocs?: ChannelVerificationDocumentUncheckedCreateNestedManyWithoutChannelInput
    categories?: ChannelCategoryAssignmentUncheckedCreateNestedManyWithoutChannelInput
    messageCategories?: MessageCategoryUncheckedCreateNestedManyWithoutChannelInput
    visits?: ChannelVisitUncheckedCreateNestedManyWithoutChannelInput
  }

  export type ChannelCreateOrConnectWithoutInvitationLinksInput = {
    where: ChannelWhereUniqueInput
    create: XOR<ChannelCreateWithoutInvitationLinksInput, ChannelUncheckedCreateWithoutInvitationLinksInput>
  }

  export type UserCreateWithoutInvitationLinksInput = {
    id?: string
    email: string
    username: string
    fullName?: string | null
    avatarUrl?: string | null
    passwordHash?: string | null
    deviceId?: string | null
    isGuest?: boolean
    phoneNumber?: string | null
    isPhoneVerified?: boolean
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    isAdmin?: boolean
    isCoordinator?: boolean
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedChannels?: ChannelCreateNestedManyWithoutOwnerInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesOverrideSet?: MessageCreateNestedManyWithoutOverrideSetterInput
    subscriptions?: ChannelSubscriptionCreateNestedManyWithoutUserInput
    qrCodes?: QrCodeCreateNestedManyWithoutCreatorInput
    messageDeliveries?: MessageDeliveryCreateNestedManyWithoutUserInput
    messageApprovals?: MessageApprovalCreateNestedManyWithoutApproverInput
    messageRevisionsEdited?: MessageRevisionCreateNestedManyWithoutEditorInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    messagingSettings?: UserMessagingSettingCreateNestedManyWithoutUserInput
    approverAssignments?: ChannelApproverCreateNestedManyWithoutUserInput
    createdCategories?: MessageCategoryCreateNestedManyWithoutCreatorInput
    messageViews?: MessageViewCreateNestedManyWithoutUserInput
    channelVisits?: ChannelVisitCreateNestedManyWithoutUserInput
    createdForms?: FormCreateNestedManyWithoutUserInput
    organizedEvents?: EventCreateNestedManyWithoutOrganizerInput
  }

  export type UserUncheckedCreateWithoutInvitationLinksInput = {
    id?: string
    email: string
    username: string
    fullName?: string | null
    avatarUrl?: string | null
    passwordHash?: string | null
    deviceId?: string | null
    isGuest?: boolean
    phoneNumber?: string | null
    isPhoneVerified?: boolean
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    isAdmin?: boolean
    isCoordinator?: boolean
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedChannels?: ChannelUncheckedCreateNestedManyWithoutOwnerInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesOverrideSet?: MessageUncheckedCreateNestedManyWithoutOverrideSetterInput
    subscriptions?: ChannelSubscriptionUncheckedCreateNestedManyWithoutUserInput
    qrCodes?: QrCodeUncheckedCreateNestedManyWithoutCreatorInput
    messageDeliveries?: MessageDeliveryUncheckedCreateNestedManyWithoutUserInput
    messageApprovals?: MessageApprovalUncheckedCreateNestedManyWithoutApproverInput
    messageRevisionsEdited?: MessageRevisionUncheckedCreateNestedManyWithoutEditorInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    messagingSettings?: UserMessagingSettingUncheckedCreateNestedManyWithoutUserInput
    approverAssignments?: ChannelApproverUncheckedCreateNestedManyWithoutUserInput
    createdCategories?: MessageCategoryUncheckedCreateNestedManyWithoutCreatorInput
    messageViews?: MessageViewUncheckedCreateNestedManyWithoutUserInput
    channelVisits?: ChannelVisitUncheckedCreateNestedManyWithoutUserInput
    createdForms?: FormUncheckedCreateNestedManyWithoutUserInput
    organizedEvents?: EventUncheckedCreateNestedManyWithoutOrganizerInput
  }

  export type UserCreateOrConnectWithoutInvitationLinksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvitationLinksInput, UserUncheckedCreateWithoutInvitationLinksInput>
  }

  export type ChannelUpsertWithoutInvitationLinksInput = {
    update: XOR<ChannelUpdateWithoutInvitationLinksInput, ChannelUncheckedUpdateWithoutInvitationLinksInput>
    create: XOR<ChannelCreateWithoutInvitationLinksInput, ChannelUncheckedCreateWithoutInvitationLinksInput>
    where?: ChannelWhereInput
  }

  export type ChannelUpdateToOneWithWhereWithoutInvitationLinksInput = {
    where?: ChannelWhereInput
    data: XOR<ChannelUpdateWithoutInvitationLinksInput, ChannelUncheckedUpdateWithoutInvitationLinksInput>
  }

  export type ChannelUpdateWithoutInvitationLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    searchExactOnly?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    approvalPolicy?: EnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy
    memberCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedChannelsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutChannelsNestedInput
    parent?: ChannelUpdateOneWithoutSubchannelsNestedInput
    subchannels?: ChannelUpdateManyWithoutParentNestedInput
    messages?: MessageUpdateManyWithoutChannelNestedInput
    subscriptions?: ChannelSubscriptionUpdateManyWithoutChannelNestedInput
    qrCodes?: QrCodeUpdateManyWithoutChannelNestedInput
    approvers?: ChannelApproverUpdateManyWithoutChannelNestedInput
    verificationDocs?: ChannelVerificationDocumentUpdateManyWithoutChannelNestedInput
    categories?: ChannelCategoryAssignmentUpdateManyWithoutChannelNestedInput
    messageCategories?: MessageCategoryUpdateManyWithoutChannelNestedInput
    visits?: ChannelVisitUpdateManyWithoutChannelNestedInput
  }

  export type ChannelUncheckedUpdateWithoutInvitationLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    searchExactOnly?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    approvalPolicy?: EnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy
    memberCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subchannels?: ChannelUncheckedUpdateManyWithoutParentNestedInput
    messages?: MessageUncheckedUpdateManyWithoutChannelNestedInput
    subscriptions?: ChannelSubscriptionUncheckedUpdateManyWithoutChannelNestedInput
    qrCodes?: QrCodeUncheckedUpdateManyWithoutChannelNestedInput
    approvers?: ChannelApproverUncheckedUpdateManyWithoutChannelNestedInput
    verificationDocs?: ChannelVerificationDocumentUncheckedUpdateManyWithoutChannelNestedInput
    categories?: ChannelCategoryAssignmentUncheckedUpdateManyWithoutChannelNestedInput
    messageCategories?: MessageCategoryUncheckedUpdateManyWithoutChannelNestedInput
    visits?: ChannelVisitUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type UserUpsertWithoutInvitationLinksInput = {
    update: XOR<UserUpdateWithoutInvitationLinksInput, UserUncheckedUpdateWithoutInvitationLinksInput>
    create: XOR<UserCreateWithoutInvitationLinksInput, UserUncheckedCreateWithoutInvitationLinksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvitationLinksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvitationLinksInput, UserUncheckedUpdateWithoutInvitationLinksInput>
  }

  export type UserUpdateWithoutInvitationLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isCoordinator?: BoolFieldUpdateOperationsInput | boolean
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedChannels?: ChannelUpdateManyWithoutOwnerNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesOverrideSet?: MessageUpdateManyWithoutOverrideSetterNestedInput
    subscriptions?: ChannelSubscriptionUpdateManyWithoutUserNestedInput
    qrCodes?: QrCodeUpdateManyWithoutCreatorNestedInput
    messageDeliveries?: MessageDeliveryUpdateManyWithoutUserNestedInput
    messageApprovals?: MessageApprovalUpdateManyWithoutApproverNestedInput
    messageRevisionsEdited?: MessageRevisionUpdateManyWithoutEditorNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    messagingSettings?: UserMessagingSettingUpdateManyWithoutUserNestedInput
    approverAssignments?: ChannelApproverUpdateManyWithoutUserNestedInput
    createdCategories?: MessageCategoryUpdateManyWithoutCreatorNestedInput
    messageViews?: MessageViewUpdateManyWithoutUserNestedInput
    channelVisits?: ChannelVisitUpdateManyWithoutUserNestedInput
    createdForms?: FormUpdateManyWithoutUserNestedInput
    organizedEvents?: EventUpdateManyWithoutOrganizerNestedInput
  }

  export type UserUncheckedUpdateWithoutInvitationLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isCoordinator?: BoolFieldUpdateOperationsInput | boolean
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedChannels?: ChannelUncheckedUpdateManyWithoutOwnerNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesOverrideSet?: MessageUncheckedUpdateManyWithoutOverrideSetterNestedInput
    subscriptions?: ChannelSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    qrCodes?: QrCodeUncheckedUpdateManyWithoutCreatorNestedInput
    messageDeliveries?: MessageDeliveryUncheckedUpdateManyWithoutUserNestedInput
    messageApprovals?: MessageApprovalUncheckedUpdateManyWithoutApproverNestedInput
    messageRevisionsEdited?: MessageRevisionUncheckedUpdateManyWithoutEditorNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    messagingSettings?: UserMessagingSettingUncheckedUpdateManyWithoutUserNestedInput
    approverAssignments?: ChannelApproverUncheckedUpdateManyWithoutUserNestedInput
    createdCategories?: MessageCategoryUncheckedUpdateManyWithoutCreatorNestedInput
    messageViews?: MessageViewUncheckedUpdateManyWithoutUserNestedInput
    channelVisits?: ChannelVisitUncheckedUpdateManyWithoutUserNestedInput
    createdForms?: FormUncheckedUpdateManyWithoutUserNestedInput
    organizedEvents?: EventUncheckedUpdateManyWithoutOrganizerNestedInput
  }

  export type ChannelCreateWithoutQrCodesInput = {
    id?: string
    title: string
    description?: string | null
    websiteUrl?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: string | null
    icon?: string
    isPublic?: boolean
    isHidden?: boolean
    searchExactOnly?: boolean
    passwordHash?: string | null
    referenceCode?: string | null
    verificationStatus?: $Enums.VerificationStatus
    approvalPolicy?: $Enums.ApprovalPolicy
    memberCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedChannelsInput
    organization: OrganizationCreateNestedOneWithoutChannelsInput
    parent?: ChannelCreateNestedOneWithoutSubchannelsInput
    subchannels?: ChannelCreateNestedManyWithoutParentInput
    messages?: MessageCreateNestedManyWithoutChannelInput
    subscriptions?: ChannelSubscriptionCreateNestedManyWithoutChannelInput
    invitationLinks?: InvitationLinkCreateNestedManyWithoutChannelInput
    approvers?: ChannelApproverCreateNestedManyWithoutChannelInput
    verificationDocs?: ChannelVerificationDocumentCreateNestedManyWithoutChannelInput
    categories?: ChannelCategoryAssignmentCreateNestedManyWithoutChannelInput
    messageCategories?: MessageCategoryCreateNestedManyWithoutChannelInput
    visits?: ChannelVisitCreateNestedManyWithoutChannelInput
  }

  export type ChannelUncheckedCreateWithoutQrCodesInput = {
    id?: string
    title: string
    description?: string | null
    websiteUrl?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: string | null
    icon?: string
    parentId?: string | null
    ownerId: string
    organizationId: string
    isPublic?: boolean
    isHidden?: boolean
    searchExactOnly?: boolean
    passwordHash?: string | null
    referenceCode?: string | null
    verificationStatus?: $Enums.VerificationStatus
    approvalPolicy?: $Enums.ApprovalPolicy
    memberCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    subchannels?: ChannelUncheckedCreateNestedManyWithoutParentInput
    messages?: MessageUncheckedCreateNestedManyWithoutChannelInput
    subscriptions?: ChannelSubscriptionUncheckedCreateNestedManyWithoutChannelInput
    invitationLinks?: InvitationLinkUncheckedCreateNestedManyWithoutChannelInput
    approvers?: ChannelApproverUncheckedCreateNestedManyWithoutChannelInput
    verificationDocs?: ChannelVerificationDocumentUncheckedCreateNestedManyWithoutChannelInput
    categories?: ChannelCategoryAssignmentUncheckedCreateNestedManyWithoutChannelInput
    messageCategories?: MessageCategoryUncheckedCreateNestedManyWithoutChannelInput
    visits?: ChannelVisitUncheckedCreateNestedManyWithoutChannelInput
  }

  export type ChannelCreateOrConnectWithoutQrCodesInput = {
    where: ChannelWhereUniqueInput
    create: XOR<ChannelCreateWithoutQrCodesInput, ChannelUncheckedCreateWithoutQrCodesInput>
  }

  export type UserCreateWithoutQrCodesInput = {
    id?: string
    email: string
    username: string
    fullName?: string | null
    avatarUrl?: string | null
    passwordHash?: string | null
    deviceId?: string | null
    isGuest?: boolean
    phoneNumber?: string | null
    isPhoneVerified?: boolean
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    isAdmin?: boolean
    isCoordinator?: boolean
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedChannels?: ChannelCreateNestedManyWithoutOwnerInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesOverrideSet?: MessageCreateNestedManyWithoutOverrideSetterInput
    subscriptions?: ChannelSubscriptionCreateNestedManyWithoutUserInput
    invitationLinks?: InvitationLinkCreateNestedManyWithoutCreatorInput
    messageDeliveries?: MessageDeliveryCreateNestedManyWithoutUserInput
    messageApprovals?: MessageApprovalCreateNestedManyWithoutApproverInput
    messageRevisionsEdited?: MessageRevisionCreateNestedManyWithoutEditorInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    messagingSettings?: UserMessagingSettingCreateNestedManyWithoutUserInput
    approverAssignments?: ChannelApproverCreateNestedManyWithoutUserInput
    createdCategories?: MessageCategoryCreateNestedManyWithoutCreatorInput
    messageViews?: MessageViewCreateNestedManyWithoutUserInput
    channelVisits?: ChannelVisitCreateNestedManyWithoutUserInput
    createdForms?: FormCreateNestedManyWithoutUserInput
    organizedEvents?: EventCreateNestedManyWithoutOrganizerInput
  }

  export type UserUncheckedCreateWithoutQrCodesInput = {
    id?: string
    email: string
    username: string
    fullName?: string | null
    avatarUrl?: string | null
    passwordHash?: string | null
    deviceId?: string | null
    isGuest?: boolean
    phoneNumber?: string | null
    isPhoneVerified?: boolean
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    isAdmin?: boolean
    isCoordinator?: boolean
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedChannels?: ChannelUncheckedCreateNestedManyWithoutOwnerInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesOverrideSet?: MessageUncheckedCreateNestedManyWithoutOverrideSetterInput
    subscriptions?: ChannelSubscriptionUncheckedCreateNestedManyWithoutUserInput
    invitationLinks?: InvitationLinkUncheckedCreateNestedManyWithoutCreatorInput
    messageDeliveries?: MessageDeliveryUncheckedCreateNestedManyWithoutUserInput
    messageApprovals?: MessageApprovalUncheckedCreateNestedManyWithoutApproverInput
    messageRevisionsEdited?: MessageRevisionUncheckedCreateNestedManyWithoutEditorInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    messagingSettings?: UserMessagingSettingUncheckedCreateNestedManyWithoutUserInput
    approverAssignments?: ChannelApproverUncheckedCreateNestedManyWithoutUserInput
    createdCategories?: MessageCategoryUncheckedCreateNestedManyWithoutCreatorInput
    messageViews?: MessageViewUncheckedCreateNestedManyWithoutUserInput
    channelVisits?: ChannelVisitUncheckedCreateNestedManyWithoutUserInput
    createdForms?: FormUncheckedCreateNestedManyWithoutUserInput
    organizedEvents?: EventUncheckedCreateNestedManyWithoutOrganizerInput
  }

  export type UserCreateOrConnectWithoutQrCodesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQrCodesInput, UserUncheckedCreateWithoutQrCodesInput>
  }

  export type ChannelUpsertWithoutQrCodesInput = {
    update: XOR<ChannelUpdateWithoutQrCodesInput, ChannelUncheckedUpdateWithoutQrCodesInput>
    create: XOR<ChannelCreateWithoutQrCodesInput, ChannelUncheckedCreateWithoutQrCodesInput>
    where?: ChannelWhereInput
  }

  export type ChannelUpdateToOneWithWhereWithoutQrCodesInput = {
    where?: ChannelWhereInput
    data: XOR<ChannelUpdateWithoutQrCodesInput, ChannelUncheckedUpdateWithoutQrCodesInput>
  }

  export type ChannelUpdateWithoutQrCodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    searchExactOnly?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    approvalPolicy?: EnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy
    memberCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedChannelsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutChannelsNestedInput
    parent?: ChannelUpdateOneWithoutSubchannelsNestedInput
    subchannels?: ChannelUpdateManyWithoutParentNestedInput
    messages?: MessageUpdateManyWithoutChannelNestedInput
    subscriptions?: ChannelSubscriptionUpdateManyWithoutChannelNestedInput
    invitationLinks?: InvitationLinkUpdateManyWithoutChannelNestedInput
    approvers?: ChannelApproverUpdateManyWithoutChannelNestedInput
    verificationDocs?: ChannelVerificationDocumentUpdateManyWithoutChannelNestedInput
    categories?: ChannelCategoryAssignmentUpdateManyWithoutChannelNestedInput
    messageCategories?: MessageCategoryUpdateManyWithoutChannelNestedInput
    visits?: ChannelVisitUpdateManyWithoutChannelNestedInput
  }

  export type ChannelUncheckedUpdateWithoutQrCodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    searchExactOnly?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    approvalPolicy?: EnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy
    memberCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subchannels?: ChannelUncheckedUpdateManyWithoutParentNestedInput
    messages?: MessageUncheckedUpdateManyWithoutChannelNestedInput
    subscriptions?: ChannelSubscriptionUncheckedUpdateManyWithoutChannelNestedInput
    invitationLinks?: InvitationLinkUncheckedUpdateManyWithoutChannelNestedInput
    approvers?: ChannelApproverUncheckedUpdateManyWithoutChannelNestedInput
    verificationDocs?: ChannelVerificationDocumentUncheckedUpdateManyWithoutChannelNestedInput
    categories?: ChannelCategoryAssignmentUncheckedUpdateManyWithoutChannelNestedInput
    messageCategories?: MessageCategoryUncheckedUpdateManyWithoutChannelNestedInput
    visits?: ChannelVisitUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type UserUpsertWithoutQrCodesInput = {
    update: XOR<UserUpdateWithoutQrCodesInput, UserUncheckedUpdateWithoutQrCodesInput>
    create: XOR<UserCreateWithoutQrCodesInput, UserUncheckedCreateWithoutQrCodesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutQrCodesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutQrCodesInput, UserUncheckedUpdateWithoutQrCodesInput>
  }

  export type UserUpdateWithoutQrCodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isCoordinator?: BoolFieldUpdateOperationsInput | boolean
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedChannels?: ChannelUpdateManyWithoutOwnerNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesOverrideSet?: MessageUpdateManyWithoutOverrideSetterNestedInput
    subscriptions?: ChannelSubscriptionUpdateManyWithoutUserNestedInput
    invitationLinks?: InvitationLinkUpdateManyWithoutCreatorNestedInput
    messageDeliveries?: MessageDeliveryUpdateManyWithoutUserNestedInput
    messageApprovals?: MessageApprovalUpdateManyWithoutApproverNestedInput
    messageRevisionsEdited?: MessageRevisionUpdateManyWithoutEditorNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    messagingSettings?: UserMessagingSettingUpdateManyWithoutUserNestedInput
    approverAssignments?: ChannelApproverUpdateManyWithoutUserNestedInput
    createdCategories?: MessageCategoryUpdateManyWithoutCreatorNestedInput
    messageViews?: MessageViewUpdateManyWithoutUserNestedInput
    channelVisits?: ChannelVisitUpdateManyWithoutUserNestedInput
    createdForms?: FormUpdateManyWithoutUserNestedInput
    organizedEvents?: EventUpdateManyWithoutOrganizerNestedInput
  }

  export type UserUncheckedUpdateWithoutQrCodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isCoordinator?: BoolFieldUpdateOperationsInput | boolean
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedChannels?: ChannelUncheckedUpdateManyWithoutOwnerNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesOverrideSet?: MessageUncheckedUpdateManyWithoutOverrideSetterNestedInput
    subscriptions?: ChannelSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invitationLinks?: InvitationLinkUncheckedUpdateManyWithoutCreatorNestedInput
    messageDeliveries?: MessageDeliveryUncheckedUpdateManyWithoutUserNestedInput
    messageApprovals?: MessageApprovalUncheckedUpdateManyWithoutApproverNestedInput
    messageRevisionsEdited?: MessageRevisionUncheckedUpdateManyWithoutEditorNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    messagingSettings?: UserMessagingSettingUncheckedUpdateManyWithoutUserNestedInput
    approverAssignments?: ChannelApproverUncheckedUpdateManyWithoutUserNestedInput
    createdCategories?: MessageCategoryUncheckedUpdateManyWithoutCreatorNestedInput
    messageViews?: MessageViewUncheckedUpdateManyWithoutUserNestedInput
    channelVisits?: ChannelVisitUncheckedUpdateManyWithoutUserNestedInput
    createdForms?: FormUncheckedUpdateManyWithoutUserNestedInput
    organizedEvents?: EventUncheckedUpdateManyWithoutOrganizerNestedInput
  }

  export type ChannelCreateWithoutOrganizationInput = {
    id?: string
    title: string
    description?: string | null
    websiteUrl?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: string | null
    icon?: string
    isPublic?: boolean
    isHidden?: boolean
    searchExactOnly?: boolean
    passwordHash?: string | null
    referenceCode?: string | null
    verificationStatus?: $Enums.VerificationStatus
    approvalPolicy?: $Enums.ApprovalPolicy
    memberCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedChannelsInput
    parent?: ChannelCreateNestedOneWithoutSubchannelsInput
    subchannels?: ChannelCreateNestedManyWithoutParentInput
    messages?: MessageCreateNestedManyWithoutChannelInput
    subscriptions?: ChannelSubscriptionCreateNestedManyWithoutChannelInput
    invitationLinks?: InvitationLinkCreateNestedManyWithoutChannelInput
    qrCodes?: QrCodeCreateNestedManyWithoutChannelInput
    approvers?: ChannelApproverCreateNestedManyWithoutChannelInput
    verificationDocs?: ChannelVerificationDocumentCreateNestedManyWithoutChannelInput
    categories?: ChannelCategoryAssignmentCreateNestedManyWithoutChannelInput
    messageCategories?: MessageCategoryCreateNestedManyWithoutChannelInput
    visits?: ChannelVisitCreateNestedManyWithoutChannelInput
  }

  export type ChannelUncheckedCreateWithoutOrganizationInput = {
    id?: string
    title: string
    description?: string | null
    websiteUrl?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: string | null
    icon?: string
    parentId?: string | null
    ownerId: string
    isPublic?: boolean
    isHidden?: boolean
    searchExactOnly?: boolean
    passwordHash?: string | null
    referenceCode?: string | null
    verificationStatus?: $Enums.VerificationStatus
    approvalPolicy?: $Enums.ApprovalPolicy
    memberCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    subchannels?: ChannelUncheckedCreateNestedManyWithoutParentInput
    messages?: MessageUncheckedCreateNestedManyWithoutChannelInput
    subscriptions?: ChannelSubscriptionUncheckedCreateNestedManyWithoutChannelInput
    invitationLinks?: InvitationLinkUncheckedCreateNestedManyWithoutChannelInput
    qrCodes?: QrCodeUncheckedCreateNestedManyWithoutChannelInput
    approvers?: ChannelApproverUncheckedCreateNestedManyWithoutChannelInput
    verificationDocs?: ChannelVerificationDocumentUncheckedCreateNestedManyWithoutChannelInput
    categories?: ChannelCategoryAssignmentUncheckedCreateNestedManyWithoutChannelInput
    messageCategories?: MessageCategoryUncheckedCreateNestedManyWithoutChannelInput
    visits?: ChannelVisitUncheckedCreateNestedManyWithoutChannelInput
  }

  export type ChannelCreateOrConnectWithoutOrganizationInput = {
    where: ChannelWhereUniqueInput
    create: XOR<ChannelCreateWithoutOrganizationInput, ChannelUncheckedCreateWithoutOrganizationInput>
  }

  export type ChannelCreateManyOrganizationInputEnvelope = {
    data: ChannelCreateManyOrganizationInput | ChannelCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type ChannelUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: ChannelWhereUniqueInput
    update: XOR<ChannelUpdateWithoutOrganizationInput, ChannelUncheckedUpdateWithoutOrganizationInput>
    create: XOR<ChannelCreateWithoutOrganizationInput, ChannelUncheckedCreateWithoutOrganizationInput>
  }

  export type ChannelUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: ChannelWhereUniqueInput
    data: XOR<ChannelUpdateWithoutOrganizationInput, ChannelUncheckedUpdateWithoutOrganizationInput>
  }

  export type ChannelUpdateManyWithWhereWithoutOrganizationInput = {
    where: ChannelScalarWhereInput
    data: XOR<ChannelUpdateManyMutationInput, ChannelUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type ChannelCreateWithoutApproversInput = {
    id?: string
    title: string
    description?: string | null
    websiteUrl?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: string | null
    icon?: string
    isPublic?: boolean
    isHidden?: boolean
    searchExactOnly?: boolean
    passwordHash?: string | null
    referenceCode?: string | null
    verificationStatus?: $Enums.VerificationStatus
    approvalPolicy?: $Enums.ApprovalPolicy
    memberCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedChannelsInput
    organization: OrganizationCreateNestedOneWithoutChannelsInput
    parent?: ChannelCreateNestedOneWithoutSubchannelsInput
    subchannels?: ChannelCreateNestedManyWithoutParentInput
    messages?: MessageCreateNestedManyWithoutChannelInput
    subscriptions?: ChannelSubscriptionCreateNestedManyWithoutChannelInput
    invitationLinks?: InvitationLinkCreateNestedManyWithoutChannelInput
    qrCodes?: QrCodeCreateNestedManyWithoutChannelInput
    verificationDocs?: ChannelVerificationDocumentCreateNestedManyWithoutChannelInput
    categories?: ChannelCategoryAssignmentCreateNestedManyWithoutChannelInput
    messageCategories?: MessageCategoryCreateNestedManyWithoutChannelInput
    visits?: ChannelVisitCreateNestedManyWithoutChannelInput
  }

  export type ChannelUncheckedCreateWithoutApproversInput = {
    id?: string
    title: string
    description?: string | null
    websiteUrl?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: string | null
    icon?: string
    parentId?: string | null
    ownerId: string
    organizationId: string
    isPublic?: boolean
    isHidden?: boolean
    searchExactOnly?: boolean
    passwordHash?: string | null
    referenceCode?: string | null
    verificationStatus?: $Enums.VerificationStatus
    approvalPolicy?: $Enums.ApprovalPolicy
    memberCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    subchannels?: ChannelUncheckedCreateNestedManyWithoutParentInput
    messages?: MessageUncheckedCreateNestedManyWithoutChannelInput
    subscriptions?: ChannelSubscriptionUncheckedCreateNestedManyWithoutChannelInput
    invitationLinks?: InvitationLinkUncheckedCreateNestedManyWithoutChannelInput
    qrCodes?: QrCodeUncheckedCreateNestedManyWithoutChannelInput
    verificationDocs?: ChannelVerificationDocumentUncheckedCreateNestedManyWithoutChannelInput
    categories?: ChannelCategoryAssignmentUncheckedCreateNestedManyWithoutChannelInput
    messageCategories?: MessageCategoryUncheckedCreateNestedManyWithoutChannelInput
    visits?: ChannelVisitUncheckedCreateNestedManyWithoutChannelInput
  }

  export type ChannelCreateOrConnectWithoutApproversInput = {
    where: ChannelWhereUniqueInput
    create: XOR<ChannelCreateWithoutApproversInput, ChannelUncheckedCreateWithoutApproversInput>
  }

  export type UserCreateWithoutApproverAssignmentsInput = {
    id?: string
    email: string
    username: string
    fullName?: string | null
    avatarUrl?: string | null
    passwordHash?: string | null
    deviceId?: string | null
    isGuest?: boolean
    phoneNumber?: string | null
    isPhoneVerified?: boolean
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    isAdmin?: boolean
    isCoordinator?: boolean
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedChannels?: ChannelCreateNestedManyWithoutOwnerInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesOverrideSet?: MessageCreateNestedManyWithoutOverrideSetterInput
    subscriptions?: ChannelSubscriptionCreateNestedManyWithoutUserInput
    invitationLinks?: InvitationLinkCreateNestedManyWithoutCreatorInput
    qrCodes?: QrCodeCreateNestedManyWithoutCreatorInput
    messageDeliveries?: MessageDeliveryCreateNestedManyWithoutUserInput
    messageApprovals?: MessageApprovalCreateNestedManyWithoutApproverInput
    messageRevisionsEdited?: MessageRevisionCreateNestedManyWithoutEditorInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    messagingSettings?: UserMessagingSettingCreateNestedManyWithoutUserInput
    createdCategories?: MessageCategoryCreateNestedManyWithoutCreatorInput
    messageViews?: MessageViewCreateNestedManyWithoutUserInput
    channelVisits?: ChannelVisitCreateNestedManyWithoutUserInput
    createdForms?: FormCreateNestedManyWithoutUserInput
    organizedEvents?: EventCreateNestedManyWithoutOrganizerInput
  }

  export type UserUncheckedCreateWithoutApproverAssignmentsInput = {
    id?: string
    email: string
    username: string
    fullName?: string | null
    avatarUrl?: string | null
    passwordHash?: string | null
    deviceId?: string | null
    isGuest?: boolean
    phoneNumber?: string | null
    isPhoneVerified?: boolean
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    isAdmin?: boolean
    isCoordinator?: boolean
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedChannels?: ChannelUncheckedCreateNestedManyWithoutOwnerInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesOverrideSet?: MessageUncheckedCreateNestedManyWithoutOverrideSetterInput
    subscriptions?: ChannelSubscriptionUncheckedCreateNestedManyWithoutUserInput
    invitationLinks?: InvitationLinkUncheckedCreateNestedManyWithoutCreatorInput
    qrCodes?: QrCodeUncheckedCreateNestedManyWithoutCreatorInput
    messageDeliveries?: MessageDeliveryUncheckedCreateNestedManyWithoutUserInput
    messageApprovals?: MessageApprovalUncheckedCreateNestedManyWithoutApproverInput
    messageRevisionsEdited?: MessageRevisionUncheckedCreateNestedManyWithoutEditorInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    messagingSettings?: UserMessagingSettingUncheckedCreateNestedManyWithoutUserInput
    createdCategories?: MessageCategoryUncheckedCreateNestedManyWithoutCreatorInput
    messageViews?: MessageViewUncheckedCreateNestedManyWithoutUserInput
    channelVisits?: ChannelVisitUncheckedCreateNestedManyWithoutUserInput
    createdForms?: FormUncheckedCreateNestedManyWithoutUserInput
    organizedEvents?: EventUncheckedCreateNestedManyWithoutOrganizerInput
  }

  export type UserCreateOrConnectWithoutApproverAssignmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApproverAssignmentsInput, UserUncheckedCreateWithoutApproverAssignmentsInput>
  }

  export type ChannelUpsertWithoutApproversInput = {
    update: XOR<ChannelUpdateWithoutApproversInput, ChannelUncheckedUpdateWithoutApproversInput>
    create: XOR<ChannelCreateWithoutApproversInput, ChannelUncheckedCreateWithoutApproversInput>
    where?: ChannelWhereInput
  }

  export type ChannelUpdateToOneWithWhereWithoutApproversInput = {
    where?: ChannelWhereInput
    data: XOR<ChannelUpdateWithoutApproversInput, ChannelUncheckedUpdateWithoutApproversInput>
  }

  export type ChannelUpdateWithoutApproversInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    searchExactOnly?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    approvalPolicy?: EnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy
    memberCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedChannelsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutChannelsNestedInput
    parent?: ChannelUpdateOneWithoutSubchannelsNestedInput
    subchannels?: ChannelUpdateManyWithoutParentNestedInput
    messages?: MessageUpdateManyWithoutChannelNestedInput
    subscriptions?: ChannelSubscriptionUpdateManyWithoutChannelNestedInput
    invitationLinks?: InvitationLinkUpdateManyWithoutChannelNestedInput
    qrCodes?: QrCodeUpdateManyWithoutChannelNestedInput
    verificationDocs?: ChannelVerificationDocumentUpdateManyWithoutChannelNestedInput
    categories?: ChannelCategoryAssignmentUpdateManyWithoutChannelNestedInput
    messageCategories?: MessageCategoryUpdateManyWithoutChannelNestedInput
    visits?: ChannelVisitUpdateManyWithoutChannelNestedInput
  }

  export type ChannelUncheckedUpdateWithoutApproversInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    searchExactOnly?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    approvalPolicy?: EnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy
    memberCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subchannels?: ChannelUncheckedUpdateManyWithoutParentNestedInput
    messages?: MessageUncheckedUpdateManyWithoutChannelNestedInput
    subscriptions?: ChannelSubscriptionUncheckedUpdateManyWithoutChannelNestedInput
    invitationLinks?: InvitationLinkUncheckedUpdateManyWithoutChannelNestedInput
    qrCodes?: QrCodeUncheckedUpdateManyWithoutChannelNestedInput
    verificationDocs?: ChannelVerificationDocumentUncheckedUpdateManyWithoutChannelNestedInput
    categories?: ChannelCategoryAssignmentUncheckedUpdateManyWithoutChannelNestedInput
    messageCategories?: MessageCategoryUncheckedUpdateManyWithoutChannelNestedInput
    visits?: ChannelVisitUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type UserUpsertWithoutApproverAssignmentsInput = {
    update: XOR<UserUpdateWithoutApproverAssignmentsInput, UserUncheckedUpdateWithoutApproverAssignmentsInput>
    create: XOR<UserCreateWithoutApproverAssignmentsInput, UserUncheckedCreateWithoutApproverAssignmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApproverAssignmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApproverAssignmentsInput, UserUncheckedUpdateWithoutApproverAssignmentsInput>
  }

  export type UserUpdateWithoutApproverAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isCoordinator?: BoolFieldUpdateOperationsInput | boolean
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedChannels?: ChannelUpdateManyWithoutOwnerNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesOverrideSet?: MessageUpdateManyWithoutOverrideSetterNestedInput
    subscriptions?: ChannelSubscriptionUpdateManyWithoutUserNestedInput
    invitationLinks?: InvitationLinkUpdateManyWithoutCreatorNestedInput
    qrCodes?: QrCodeUpdateManyWithoutCreatorNestedInput
    messageDeliveries?: MessageDeliveryUpdateManyWithoutUserNestedInput
    messageApprovals?: MessageApprovalUpdateManyWithoutApproverNestedInput
    messageRevisionsEdited?: MessageRevisionUpdateManyWithoutEditorNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    messagingSettings?: UserMessagingSettingUpdateManyWithoutUserNestedInput
    createdCategories?: MessageCategoryUpdateManyWithoutCreatorNestedInput
    messageViews?: MessageViewUpdateManyWithoutUserNestedInput
    channelVisits?: ChannelVisitUpdateManyWithoutUserNestedInput
    createdForms?: FormUpdateManyWithoutUserNestedInput
    organizedEvents?: EventUpdateManyWithoutOrganizerNestedInput
  }

  export type UserUncheckedUpdateWithoutApproverAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isCoordinator?: BoolFieldUpdateOperationsInput | boolean
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedChannels?: ChannelUncheckedUpdateManyWithoutOwnerNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesOverrideSet?: MessageUncheckedUpdateManyWithoutOverrideSetterNestedInput
    subscriptions?: ChannelSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invitationLinks?: InvitationLinkUncheckedUpdateManyWithoutCreatorNestedInput
    qrCodes?: QrCodeUncheckedUpdateManyWithoutCreatorNestedInput
    messageDeliveries?: MessageDeliveryUncheckedUpdateManyWithoutUserNestedInput
    messageApprovals?: MessageApprovalUncheckedUpdateManyWithoutApproverNestedInput
    messageRevisionsEdited?: MessageRevisionUncheckedUpdateManyWithoutEditorNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    messagingSettings?: UserMessagingSettingUncheckedUpdateManyWithoutUserNestedInput
    createdCategories?: MessageCategoryUncheckedUpdateManyWithoutCreatorNestedInput
    messageViews?: MessageViewUncheckedUpdateManyWithoutUserNestedInput
    channelVisits?: ChannelVisitUncheckedUpdateManyWithoutUserNestedInput
    createdForms?: FormUncheckedUpdateManyWithoutUserNestedInput
    organizedEvents?: EventUncheckedUpdateManyWithoutOrganizerNestedInput
  }

  export type MessageCreateWithoutApprovalsInput = {
    id?: string
    content: string
    durationSeconds?: number
    expiresAt?: Date | string | null
    isEmergency?: boolean
    isImmediate?: boolean
    priority?: $Enums.MessagePriority
    approvalOverride?: $Enums.ApprovalPolicy | null
    approvalOverrideSetAt?: Date | string | null
    deliveryMethod?: $Enums.DeliveryMethod
    eventAt?: Date | string | null
    publishedAt?: Date | string | null
    state?: $Enums.MessageState
    createdAt?: Date | string
    updatedAt?: Date | string
    channel: ChannelCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutMessagesSentInput
    category: MessageCategoryCreateNestedOneWithoutMessagesInput
    overrideSetter?: UserCreateNestedOneWithoutMessagesOverrideSetInput
    deliveries?: MessageDeliveryCreateNestedManyWithoutMessageInput
    attachments?: MessageAttachmentCreateNestedManyWithoutMessageInput
    revisions?: MessageRevisionCreateNestedManyWithoutMessageInput
    views?: MessageViewCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutApprovalsInput = {
    id?: string
    channelId: string
    senderId: string
    categoryId: string
    content: string
    durationSeconds?: number
    expiresAt?: Date | string | null
    isEmergency?: boolean
    isImmediate?: boolean
    priority?: $Enums.MessagePriority
    approvalOverride?: $Enums.ApprovalPolicy | null
    approvalOverrideSetBy?: string | null
    approvalOverrideSetAt?: Date | string | null
    deliveryMethod?: $Enums.DeliveryMethod
    eventAt?: Date | string | null
    publishedAt?: Date | string | null
    state?: $Enums.MessageState
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveries?: MessageDeliveryUncheckedCreateNestedManyWithoutMessageInput
    attachments?: MessageAttachmentUncheckedCreateNestedManyWithoutMessageInput
    revisions?: MessageRevisionUncheckedCreateNestedManyWithoutMessageInput
    views?: MessageViewUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutApprovalsInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutApprovalsInput, MessageUncheckedCreateWithoutApprovalsInput>
  }

  export type UserCreateWithoutMessageApprovalsInput = {
    id?: string
    email: string
    username: string
    fullName?: string | null
    avatarUrl?: string | null
    passwordHash?: string | null
    deviceId?: string | null
    isGuest?: boolean
    phoneNumber?: string | null
    isPhoneVerified?: boolean
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    isAdmin?: boolean
    isCoordinator?: boolean
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedChannels?: ChannelCreateNestedManyWithoutOwnerInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesOverrideSet?: MessageCreateNestedManyWithoutOverrideSetterInput
    subscriptions?: ChannelSubscriptionCreateNestedManyWithoutUserInput
    invitationLinks?: InvitationLinkCreateNestedManyWithoutCreatorInput
    qrCodes?: QrCodeCreateNestedManyWithoutCreatorInput
    messageDeliveries?: MessageDeliveryCreateNestedManyWithoutUserInput
    messageRevisionsEdited?: MessageRevisionCreateNestedManyWithoutEditorInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    messagingSettings?: UserMessagingSettingCreateNestedManyWithoutUserInput
    approverAssignments?: ChannelApproverCreateNestedManyWithoutUserInput
    createdCategories?: MessageCategoryCreateNestedManyWithoutCreatorInput
    messageViews?: MessageViewCreateNestedManyWithoutUserInput
    channelVisits?: ChannelVisitCreateNestedManyWithoutUserInput
    createdForms?: FormCreateNestedManyWithoutUserInput
    organizedEvents?: EventCreateNestedManyWithoutOrganizerInput
  }

  export type UserUncheckedCreateWithoutMessageApprovalsInput = {
    id?: string
    email: string
    username: string
    fullName?: string | null
    avatarUrl?: string | null
    passwordHash?: string | null
    deviceId?: string | null
    isGuest?: boolean
    phoneNumber?: string | null
    isPhoneVerified?: boolean
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    isAdmin?: boolean
    isCoordinator?: boolean
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedChannels?: ChannelUncheckedCreateNestedManyWithoutOwnerInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesOverrideSet?: MessageUncheckedCreateNestedManyWithoutOverrideSetterInput
    subscriptions?: ChannelSubscriptionUncheckedCreateNestedManyWithoutUserInput
    invitationLinks?: InvitationLinkUncheckedCreateNestedManyWithoutCreatorInput
    qrCodes?: QrCodeUncheckedCreateNestedManyWithoutCreatorInput
    messageDeliveries?: MessageDeliveryUncheckedCreateNestedManyWithoutUserInput
    messageRevisionsEdited?: MessageRevisionUncheckedCreateNestedManyWithoutEditorInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    messagingSettings?: UserMessagingSettingUncheckedCreateNestedManyWithoutUserInput
    approverAssignments?: ChannelApproverUncheckedCreateNestedManyWithoutUserInput
    createdCategories?: MessageCategoryUncheckedCreateNestedManyWithoutCreatorInput
    messageViews?: MessageViewUncheckedCreateNestedManyWithoutUserInput
    channelVisits?: ChannelVisitUncheckedCreateNestedManyWithoutUserInput
    createdForms?: FormUncheckedCreateNestedManyWithoutUserInput
    organizedEvents?: EventUncheckedCreateNestedManyWithoutOrganizerInput
  }

  export type UserCreateOrConnectWithoutMessageApprovalsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessageApprovalsInput, UserUncheckedCreateWithoutMessageApprovalsInput>
  }

  export type MessageUpsertWithoutApprovalsInput = {
    update: XOR<MessageUpdateWithoutApprovalsInput, MessageUncheckedUpdateWithoutApprovalsInput>
    create: XOR<MessageCreateWithoutApprovalsInput, MessageUncheckedCreateWithoutApprovalsInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutApprovalsInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutApprovalsInput, MessageUncheckedUpdateWithoutApprovalsInput>
  }

  export type MessageUpdateWithoutApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    durationSeconds?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    isImmediate?: BoolFieldUpdateOperationsInput | boolean
    priority?: EnumMessagePriorityFieldUpdateOperationsInput | $Enums.MessagePriority
    approvalOverride?: NullableEnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy | null
    approvalOverrideSetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    eventAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    state?: EnumMessageStateFieldUpdateOperationsInput | $Enums.MessageState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: ChannelUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutMessagesSentNestedInput
    category?: MessageCategoryUpdateOneRequiredWithoutMessagesNestedInput
    overrideSetter?: UserUpdateOneWithoutMessagesOverrideSetNestedInput
    deliveries?: MessageDeliveryUpdateManyWithoutMessageNestedInput
    attachments?: MessageAttachmentUpdateManyWithoutMessageNestedInput
    revisions?: MessageRevisionUpdateManyWithoutMessageNestedInput
    views?: MessageViewUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    durationSeconds?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    isImmediate?: BoolFieldUpdateOperationsInput | boolean
    priority?: EnumMessagePriorityFieldUpdateOperationsInput | $Enums.MessagePriority
    approvalOverride?: NullableEnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy | null
    approvalOverrideSetBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvalOverrideSetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    eventAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    state?: EnumMessageStateFieldUpdateOperationsInput | $Enums.MessageState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: MessageDeliveryUncheckedUpdateManyWithoutMessageNestedInput
    attachments?: MessageAttachmentUncheckedUpdateManyWithoutMessageNestedInput
    revisions?: MessageRevisionUncheckedUpdateManyWithoutMessageNestedInput
    views?: MessageViewUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type UserUpsertWithoutMessageApprovalsInput = {
    update: XOR<UserUpdateWithoutMessageApprovalsInput, UserUncheckedUpdateWithoutMessageApprovalsInput>
    create: XOR<UserCreateWithoutMessageApprovalsInput, UserUncheckedCreateWithoutMessageApprovalsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessageApprovalsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessageApprovalsInput, UserUncheckedUpdateWithoutMessageApprovalsInput>
  }

  export type UserUpdateWithoutMessageApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isCoordinator?: BoolFieldUpdateOperationsInput | boolean
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedChannels?: ChannelUpdateManyWithoutOwnerNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesOverrideSet?: MessageUpdateManyWithoutOverrideSetterNestedInput
    subscriptions?: ChannelSubscriptionUpdateManyWithoutUserNestedInput
    invitationLinks?: InvitationLinkUpdateManyWithoutCreatorNestedInput
    qrCodes?: QrCodeUpdateManyWithoutCreatorNestedInput
    messageDeliveries?: MessageDeliveryUpdateManyWithoutUserNestedInput
    messageRevisionsEdited?: MessageRevisionUpdateManyWithoutEditorNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    messagingSettings?: UserMessagingSettingUpdateManyWithoutUserNestedInput
    approverAssignments?: ChannelApproverUpdateManyWithoutUserNestedInput
    createdCategories?: MessageCategoryUpdateManyWithoutCreatorNestedInput
    messageViews?: MessageViewUpdateManyWithoutUserNestedInput
    channelVisits?: ChannelVisitUpdateManyWithoutUserNestedInput
    createdForms?: FormUpdateManyWithoutUserNestedInput
    organizedEvents?: EventUpdateManyWithoutOrganizerNestedInput
  }

  export type UserUncheckedUpdateWithoutMessageApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isCoordinator?: BoolFieldUpdateOperationsInput | boolean
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedChannels?: ChannelUncheckedUpdateManyWithoutOwnerNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesOverrideSet?: MessageUncheckedUpdateManyWithoutOverrideSetterNestedInput
    subscriptions?: ChannelSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invitationLinks?: InvitationLinkUncheckedUpdateManyWithoutCreatorNestedInput
    qrCodes?: QrCodeUncheckedUpdateManyWithoutCreatorNestedInput
    messageDeliveries?: MessageDeliveryUncheckedUpdateManyWithoutUserNestedInput
    messageRevisionsEdited?: MessageRevisionUncheckedUpdateManyWithoutEditorNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    messagingSettings?: UserMessagingSettingUncheckedUpdateManyWithoutUserNestedInput
    approverAssignments?: ChannelApproverUncheckedUpdateManyWithoutUserNestedInput
    createdCategories?: MessageCategoryUncheckedUpdateManyWithoutCreatorNestedInput
    messageViews?: MessageViewUncheckedUpdateManyWithoutUserNestedInput
    channelVisits?: ChannelVisitUncheckedUpdateManyWithoutUserNestedInput
    createdForms?: FormUncheckedUpdateManyWithoutUserNestedInput
    organizedEvents?: EventUncheckedUpdateManyWithoutOrganizerNestedInput
  }

  export type ChannelCreateWithoutMessageCategoriesInput = {
    id?: string
    title: string
    description?: string | null
    websiteUrl?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: string | null
    icon?: string
    isPublic?: boolean
    isHidden?: boolean
    searchExactOnly?: boolean
    passwordHash?: string | null
    referenceCode?: string | null
    verificationStatus?: $Enums.VerificationStatus
    approvalPolicy?: $Enums.ApprovalPolicy
    memberCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedChannelsInput
    organization: OrganizationCreateNestedOneWithoutChannelsInput
    parent?: ChannelCreateNestedOneWithoutSubchannelsInput
    subchannels?: ChannelCreateNestedManyWithoutParentInput
    messages?: MessageCreateNestedManyWithoutChannelInput
    subscriptions?: ChannelSubscriptionCreateNestedManyWithoutChannelInput
    invitationLinks?: InvitationLinkCreateNestedManyWithoutChannelInput
    qrCodes?: QrCodeCreateNestedManyWithoutChannelInput
    approvers?: ChannelApproverCreateNestedManyWithoutChannelInput
    verificationDocs?: ChannelVerificationDocumentCreateNestedManyWithoutChannelInput
    categories?: ChannelCategoryAssignmentCreateNestedManyWithoutChannelInput
    visits?: ChannelVisitCreateNestedManyWithoutChannelInput
  }

  export type ChannelUncheckedCreateWithoutMessageCategoriesInput = {
    id?: string
    title: string
    description?: string | null
    websiteUrl?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: string | null
    icon?: string
    parentId?: string | null
    ownerId: string
    organizationId: string
    isPublic?: boolean
    isHidden?: boolean
    searchExactOnly?: boolean
    passwordHash?: string | null
    referenceCode?: string | null
    verificationStatus?: $Enums.VerificationStatus
    approvalPolicy?: $Enums.ApprovalPolicy
    memberCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    subchannels?: ChannelUncheckedCreateNestedManyWithoutParentInput
    messages?: MessageUncheckedCreateNestedManyWithoutChannelInput
    subscriptions?: ChannelSubscriptionUncheckedCreateNestedManyWithoutChannelInput
    invitationLinks?: InvitationLinkUncheckedCreateNestedManyWithoutChannelInput
    qrCodes?: QrCodeUncheckedCreateNestedManyWithoutChannelInput
    approvers?: ChannelApproverUncheckedCreateNestedManyWithoutChannelInput
    verificationDocs?: ChannelVerificationDocumentUncheckedCreateNestedManyWithoutChannelInput
    categories?: ChannelCategoryAssignmentUncheckedCreateNestedManyWithoutChannelInput
    visits?: ChannelVisitUncheckedCreateNestedManyWithoutChannelInput
  }

  export type ChannelCreateOrConnectWithoutMessageCategoriesInput = {
    where: ChannelWhereUniqueInput
    create: XOR<ChannelCreateWithoutMessageCategoriesInput, ChannelUncheckedCreateWithoutMessageCategoriesInput>
  }

  export type UserCreateWithoutCreatedCategoriesInput = {
    id?: string
    email: string
    username: string
    fullName?: string | null
    avatarUrl?: string | null
    passwordHash?: string | null
    deviceId?: string | null
    isGuest?: boolean
    phoneNumber?: string | null
    isPhoneVerified?: boolean
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    isAdmin?: boolean
    isCoordinator?: boolean
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedChannels?: ChannelCreateNestedManyWithoutOwnerInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesOverrideSet?: MessageCreateNestedManyWithoutOverrideSetterInput
    subscriptions?: ChannelSubscriptionCreateNestedManyWithoutUserInput
    invitationLinks?: InvitationLinkCreateNestedManyWithoutCreatorInput
    qrCodes?: QrCodeCreateNestedManyWithoutCreatorInput
    messageDeliveries?: MessageDeliveryCreateNestedManyWithoutUserInput
    messageApprovals?: MessageApprovalCreateNestedManyWithoutApproverInput
    messageRevisionsEdited?: MessageRevisionCreateNestedManyWithoutEditorInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    messagingSettings?: UserMessagingSettingCreateNestedManyWithoutUserInput
    approverAssignments?: ChannelApproverCreateNestedManyWithoutUserInput
    messageViews?: MessageViewCreateNestedManyWithoutUserInput
    channelVisits?: ChannelVisitCreateNestedManyWithoutUserInput
    createdForms?: FormCreateNestedManyWithoutUserInput
    organizedEvents?: EventCreateNestedManyWithoutOrganizerInput
  }

  export type UserUncheckedCreateWithoutCreatedCategoriesInput = {
    id?: string
    email: string
    username: string
    fullName?: string | null
    avatarUrl?: string | null
    passwordHash?: string | null
    deviceId?: string | null
    isGuest?: boolean
    phoneNumber?: string | null
    isPhoneVerified?: boolean
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    isAdmin?: boolean
    isCoordinator?: boolean
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedChannels?: ChannelUncheckedCreateNestedManyWithoutOwnerInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesOverrideSet?: MessageUncheckedCreateNestedManyWithoutOverrideSetterInput
    subscriptions?: ChannelSubscriptionUncheckedCreateNestedManyWithoutUserInput
    invitationLinks?: InvitationLinkUncheckedCreateNestedManyWithoutCreatorInput
    qrCodes?: QrCodeUncheckedCreateNestedManyWithoutCreatorInput
    messageDeliveries?: MessageDeliveryUncheckedCreateNestedManyWithoutUserInput
    messageApprovals?: MessageApprovalUncheckedCreateNestedManyWithoutApproverInput
    messageRevisionsEdited?: MessageRevisionUncheckedCreateNestedManyWithoutEditorInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    messagingSettings?: UserMessagingSettingUncheckedCreateNestedManyWithoutUserInput
    approverAssignments?: ChannelApproverUncheckedCreateNestedManyWithoutUserInput
    messageViews?: MessageViewUncheckedCreateNestedManyWithoutUserInput
    channelVisits?: ChannelVisitUncheckedCreateNestedManyWithoutUserInput
    createdForms?: FormUncheckedCreateNestedManyWithoutUserInput
    organizedEvents?: EventUncheckedCreateNestedManyWithoutOrganizerInput
  }

  export type UserCreateOrConnectWithoutCreatedCategoriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedCategoriesInput, UserUncheckedCreateWithoutCreatedCategoriesInput>
  }

  export type MessageCreateWithoutCategoryInput = {
    id?: string
    content: string
    durationSeconds?: number
    expiresAt?: Date | string | null
    isEmergency?: boolean
    isImmediate?: boolean
    priority?: $Enums.MessagePriority
    approvalOverride?: $Enums.ApprovalPolicy | null
    approvalOverrideSetAt?: Date | string | null
    deliveryMethod?: $Enums.DeliveryMethod
    eventAt?: Date | string | null
    publishedAt?: Date | string | null
    state?: $Enums.MessageState
    createdAt?: Date | string
    updatedAt?: Date | string
    channel: ChannelCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutMessagesSentInput
    overrideSetter?: UserCreateNestedOneWithoutMessagesOverrideSetInput
    deliveries?: MessageDeliveryCreateNestedManyWithoutMessageInput
    approvals?: MessageApprovalCreateNestedManyWithoutMessageInput
    attachments?: MessageAttachmentCreateNestedManyWithoutMessageInput
    revisions?: MessageRevisionCreateNestedManyWithoutMessageInput
    views?: MessageViewCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutCategoryInput = {
    id?: string
    channelId: string
    senderId: string
    content: string
    durationSeconds?: number
    expiresAt?: Date | string | null
    isEmergency?: boolean
    isImmediate?: boolean
    priority?: $Enums.MessagePriority
    approvalOverride?: $Enums.ApprovalPolicy | null
    approvalOverrideSetBy?: string | null
    approvalOverrideSetAt?: Date | string | null
    deliveryMethod?: $Enums.DeliveryMethod
    eventAt?: Date | string | null
    publishedAt?: Date | string | null
    state?: $Enums.MessageState
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveries?: MessageDeliveryUncheckedCreateNestedManyWithoutMessageInput
    approvals?: MessageApprovalUncheckedCreateNestedManyWithoutMessageInput
    attachments?: MessageAttachmentUncheckedCreateNestedManyWithoutMessageInput
    revisions?: MessageRevisionUncheckedCreateNestedManyWithoutMessageInput
    views?: MessageViewUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutCategoryInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutCategoryInput, MessageUncheckedCreateWithoutCategoryInput>
  }

  export type MessageCreateManyCategoryInputEnvelope = {
    data: MessageCreateManyCategoryInput | MessageCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ChannelUpsertWithoutMessageCategoriesInput = {
    update: XOR<ChannelUpdateWithoutMessageCategoriesInput, ChannelUncheckedUpdateWithoutMessageCategoriesInput>
    create: XOR<ChannelCreateWithoutMessageCategoriesInput, ChannelUncheckedCreateWithoutMessageCategoriesInput>
    where?: ChannelWhereInput
  }

  export type ChannelUpdateToOneWithWhereWithoutMessageCategoriesInput = {
    where?: ChannelWhereInput
    data: XOR<ChannelUpdateWithoutMessageCategoriesInput, ChannelUncheckedUpdateWithoutMessageCategoriesInput>
  }

  export type ChannelUpdateWithoutMessageCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    searchExactOnly?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    approvalPolicy?: EnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy
    memberCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedChannelsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutChannelsNestedInput
    parent?: ChannelUpdateOneWithoutSubchannelsNestedInput
    subchannels?: ChannelUpdateManyWithoutParentNestedInput
    messages?: MessageUpdateManyWithoutChannelNestedInput
    subscriptions?: ChannelSubscriptionUpdateManyWithoutChannelNestedInput
    invitationLinks?: InvitationLinkUpdateManyWithoutChannelNestedInput
    qrCodes?: QrCodeUpdateManyWithoutChannelNestedInput
    approvers?: ChannelApproverUpdateManyWithoutChannelNestedInput
    verificationDocs?: ChannelVerificationDocumentUpdateManyWithoutChannelNestedInput
    categories?: ChannelCategoryAssignmentUpdateManyWithoutChannelNestedInput
    visits?: ChannelVisitUpdateManyWithoutChannelNestedInput
  }

  export type ChannelUncheckedUpdateWithoutMessageCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    searchExactOnly?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    approvalPolicy?: EnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy
    memberCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subchannels?: ChannelUncheckedUpdateManyWithoutParentNestedInput
    messages?: MessageUncheckedUpdateManyWithoutChannelNestedInput
    subscriptions?: ChannelSubscriptionUncheckedUpdateManyWithoutChannelNestedInput
    invitationLinks?: InvitationLinkUncheckedUpdateManyWithoutChannelNestedInput
    qrCodes?: QrCodeUncheckedUpdateManyWithoutChannelNestedInput
    approvers?: ChannelApproverUncheckedUpdateManyWithoutChannelNestedInput
    verificationDocs?: ChannelVerificationDocumentUncheckedUpdateManyWithoutChannelNestedInput
    categories?: ChannelCategoryAssignmentUncheckedUpdateManyWithoutChannelNestedInput
    visits?: ChannelVisitUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type UserUpsertWithoutCreatedCategoriesInput = {
    update: XOR<UserUpdateWithoutCreatedCategoriesInput, UserUncheckedUpdateWithoutCreatedCategoriesInput>
    create: XOR<UserCreateWithoutCreatedCategoriesInput, UserUncheckedCreateWithoutCreatedCategoriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedCategoriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedCategoriesInput, UserUncheckedUpdateWithoutCreatedCategoriesInput>
  }

  export type UserUpdateWithoutCreatedCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isCoordinator?: BoolFieldUpdateOperationsInput | boolean
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedChannels?: ChannelUpdateManyWithoutOwnerNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesOverrideSet?: MessageUpdateManyWithoutOverrideSetterNestedInput
    subscriptions?: ChannelSubscriptionUpdateManyWithoutUserNestedInput
    invitationLinks?: InvitationLinkUpdateManyWithoutCreatorNestedInput
    qrCodes?: QrCodeUpdateManyWithoutCreatorNestedInput
    messageDeliveries?: MessageDeliveryUpdateManyWithoutUserNestedInput
    messageApprovals?: MessageApprovalUpdateManyWithoutApproverNestedInput
    messageRevisionsEdited?: MessageRevisionUpdateManyWithoutEditorNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    messagingSettings?: UserMessagingSettingUpdateManyWithoutUserNestedInput
    approverAssignments?: ChannelApproverUpdateManyWithoutUserNestedInput
    messageViews?: MessageViewUpdateManyWithoutUserNestedInput
    channelVisits?: ChannelVisitUpdateManyWithoutUserNestedInput
    createdForms?: FormUpdateManyWithoutUserNestedInput
    organizedEvents?: EventUpdateManyWithoutOrganizerNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isCoordinator?: BoolFieldUpdateOperationsInput | boolean
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedChannels?: ChannelUncheckedUpdateManyWithoutOwnerNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesOverrideSet?: MessageUncheckedUpdateManyWithoutOverrideSetterNestedInput
    subscriptions?: ChannelSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invitationLinks?: InvitationLinkUncheckedUpdateManyWithoutCreatorNestedInput
    qrCodes?: QrCodeUncheckedUpdateManyWithoutCreatorNestedInput
    messageDeliveries?: MessageDeliveryUncheckedUpdateManyWithoutUserNestedInput
    messageApprovals?: MessageApprovalUncheckedUpdateManyWithoutApproverNestedInput
    messageRevisionsEdited?: MessageRevisionUncheckedUpdateManyWithoutEditorNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    messagingSettings?: UserMessagingSettingUncheckedUpdateManyWithoutUserNestedInput
    approverAssignments?: ChannelApproverUncheckedUpdateManyWithoutUserNestedInput
    messageViews?: MessageViewUncheckedUpdateManyWithoutUserNestedInput
    channelVisits?: ChannelVisitUncheckedUpdateManyWithoutUserNestedInput
    createdForms?: FormUncheckedUpdateManyWithoutUserNestedInput
    organizedEvents?: EventUncheckedUpdateManyWithoutOrganizerNestedInput
  }

  export type MessageUpsertWithWhereUniqueWithoutCategoryInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutCategoryInput, MessageUncheckedUpdateWithoutCategoryInput>
    create: XOR<MessageCreateWithoutCategoryInput, MessageUncheckedCreateWithoutCategoryInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutCategoryInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutCategoryInput, MessageUncheckedUpdateWithoutCategoryInput>
  }

  export type MessageUpdateManyWithWhereWithoutCategoryInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutCategoryInput>
  }

  export type MessageCreateWithoutAttachmentsInput = {
    id?: string
    content: string
    durationSeconds?: number
    expiresAt?: Date | string | null
    isEmergency?: boolean
    isImmediate?: boolean
    priority?: $Enums.MessagePriority
    approvalOverride?: $Enums.ApprovalPolicy | null
    approvalOverrideSetAt?: Date | string | null
    deliveryMethod?: $Enums.DeliveryMethod
    eventAt?: Date | string | null
    publishedAt?: Date | string | null
    state?: $Enums.MessageState
    createdAt?: Date | string
    updatedAt?: Date | string
    channel: ChannelCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutMessagesSentInput
    category: MessageCategoryCreateNestedOneWithoutMessagesInput
    overrideSetter?: UserCreateNestedOneWithoutMessagesOverrideSetInput
    deliveries?: MessageDeliveryCreateNestedManyWithoutMessageInput
    approvals?: MessageApprovalCreateNestedManyWithoutMessageInput
    revisions?: MessageRevisionCreateNestedManyWithoutMessageInput
    views?: MessageViewCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    channelId: string
    senderId: string
    categoryId: string
    content: string
    durationSeconds?: number
    expiresAt?: Date | string | null
    isEmergency?: boolean
    isImmediate?: boolean
    priority?: $Enums.MessagePriority
    approvalOverride?: $Enums.ApprovalPolicy | null
    approvalOverrideSetBy?: string | null
    approvalOverrideSetAt?: Date | string | null
    deliveryMethod?: $Enums.DeliveryMethod
    eventAt?: Date | string | null
    publishedAt?: Date | string | null
    state?: $Enums.MessageState
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveries?: MessageDeliveryUncheckedCreateNestedManyWithoutMessageInput
    approvals?: MessageApprovalUncheckedCreateNestedManyWithoutMessageInput
    revisions?: MessageRevisionUncheckedCreateNestedManyWithoutMessageInput
    views?: MessageViewUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutAttachmentsInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutAttachmentsInput, MessageUncheckedCreateWithoutAttachmentsInput>
  }

  export type MessageUpsertWithoutAttachmentsInput = {
    update: XOR<MessageUpdateWithoutAttachmentsInput, MessageUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<MessageCreateWithoutAttachmentsInput, MessageUncheckedCreateWithoutAttachmentsInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutAttachmentsInput, MessageUncheckedUpdateWithoutAttachmentsInput>
  }

  export type MessageUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    durationSeconds?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    isImmediate?: BoolFieldUpdateOperationsInput | boolean
    priority?: EnumMessagePriorityFieldUpdateOperationsInput | $Enums.MessagePriority
    approvalOverride?: NullableEnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy | null
    approvalOverrideSetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    eventAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    state?: EnumMessageStateFieldUpdateOperationsInput | $Enums.MessageState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: ChannelUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutMessagesSentNestedInput
    category?: MessageCategoryUpdateOneRequiredWithoutMessagesNestedInput
    overrideSetter?: UserUpdateOneWithoutMessagesOverrideSetNestedInput
    deliveries?: MessageDeliveryUpdateManyWithoutMessageNestedInput
    approvals?: MessageApprovalUpdateManyWithoutMessageNestedInput
    revisions?: MessageRevisionUpdateManyWithoutMessageNestedInput
    views?: MessageViewUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    durationSeconds?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    isImmediate?: BoolFieldUpdateOperationsInput | boolean
    priority?: EnumMessagePriorityFieldUpdateOperationsInput | $Enums.MessagePriority
    approvalOverride?: NullableEnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy | null
    approvalOverrideSetBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvalOverrideSetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    eventAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    state?: EnumMessageStateFieldUpdateOperationsInput | $Enums.MessageState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: MessageDeliveryUncheckedUpdateManyWithoutMessageNestedInput
    approvals?: MessageApprovalUncheckedUpdateManyWithoutMessageNestedInput
    revisions?: MessageRevisionUncheckedUpdateManyWithoutMessageNestedInput
    views?: MessageViewUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageCreateWithoutRevisionsInput = {
    id?: string
    content: string
    durationSeconds?: number
    expiresAt?: Date | string | null
    isEmergency?: boolean
    isImmediate?: boolean
    priority?: $Enums.MessagePriority
    approvalOverride?: $Enums.ApprovalPolicy | null
    approvalOverrideSetAt?: Date | string | null
    deliveryMethod?: $Enums.DeliveryMethod
    eventAt?: Date | string | null
    publishedAt?: Date | string | null
    state?: $Enums.MessageState
    createdAt?: Date | string
    updatedAt?: Date | string
    channel: ChannelCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutMessagesSentInput
    category: MessageCategoryCreateNestedOneWithoutMessagesInput
    overrideSetter?: UserCreateNestedOneWithoutMessagesOverrideSetInput
    deliveries?: MessageDeliveryCreateNestedManyWithoutMessageInput
    approvals?: MessageApprovalCreateNestedManyWithoutMessageInput
    attachments?: MessageAttachmentCreateNestedManyWithoutMessageInput
    views?: MessageViewCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutRevisionsInput = {
    id?: string
    channelId: string
    senderId: string
    categoryId: string
    content: string
    durationSeconds?: number
    expiresAt?: Date | string | null
    isEmergency?: boolean
    isImmediate?: boolean
    priority?: $Enums.MessagePriority
    approvalOverride?: $Enums.ApprovalPolicy | null
    approvalOverrideSetBy?: string | null
    approvalOverrideSetAt?: Date | string | null
    deliveryMethod?: $Enums.DeliveryMethod
    eventAt?: Date | string | null
    publishedAt?: Date | string | null
    state?: $Enums.MessageState
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveries?: MessageDeliveryUncheckedCreateNestedManyWithoutMessageInput
    approvals?: MessageApprovalUncheckedCreateNestedManyWithoutMessageInput
    attachments?: MessageAttachmentUncheckedCreateNestedManyWithoutMessageInput
    views?: MessageViewUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutRevisionsInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutRevisionsInput, MessageUncheckedCreateWithoutRevisionsInput>
  }

  export type UserCreateWithoutMessageRevisionsEditedInput = {
    id?: string
    email: string
    username: string
    fullName?: string | null
    avatarUrl?: string | null
    passwordHash?: string | null
    deviceId?: string | null
    isGuest?: boolean
    phoneNumber?: string | null
    isPhoneVerified?: boolean
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    isAdmin?: boolean
    isCoordinator?: boolean
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedChannels?: ChannelCreateNestedManyWithoutOwnerInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesOverrideSet?: MessageCreateNestedManyWithoutOverrideSetterInput
    subscriptions?: ChannelSubscriptionCreateNestedManyWithoutUserInput
    invitationLinks?: InvitationLinkCreateNestedManyWithoutCreatorInput
    qrCodes?: QrCodeCreateNestedManyWithoutCreatorInput
    messageDeliveries?: MessageDeliveryCreateNestedManyWithoutUserInput
    messageApprovals?: MessageApprovalCreateNestedManyWithoutApproverInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    messagingSettings?: UserMessagingSettingCreateNestedManyWithoutUserInput
    approverAssignments?: ChannelApproverCreateNestedManyWithoutUserInput
    createdCategories?: MessageCategoryCreateNestedManyWithoutCreatorInput
    messageViews?: MessageViewCreateNestedManyWithoutUserInput
    channelVisits?: ChannelVisitCreateNestedManyWithoutUserInput
    createdForms?: FormCreateNestedManyWithoutUserInput
    organizedEvents?: EventCreateNestedManyWithoutOrganizerInput
  }

  export type UserUncheckedCreateWithoutMessageRevisionsEditedInput = {
    id?: string
    email: string
    username: string
    fullName?: string | null
    avatarUrl?: string | null
    passwordHash?: string | null
    deviceId?: string | null
    isGuest?: boolean
    phoneNumber?: string | null
    isPhoneVerified?: boolean
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    isAdmin?: boolean
    isCoordinator?: boolean
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedChannels?: ChannelUncheckedCreateNestedManyWithoutOwnerInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesOverrideSet?: MessageUncheckedCreateNestedManyWithoutOverrideSetterInput
    subscriptions?: ChannelSubscriptionUncheckedCreateNestedManyWithoutUserInput
    invitationLinks?: InvitationLinkUncheckedCreateNestedManyWithoutCreatorInput
    qrCodes?: QrCodeUncheckedCreateNestedManyWithoutCreatorInput
    messageDeliveries?: MessageDeliveryUncheckedCreateNestedManyWithoutUserInput
    messageApprovals?: MessageApprovalUncheckedCreateNestedManyWithoutApproverInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    messagingSettings?: UserMessagingSettingUncheckedCreateNestedManyWithoutUserInput
    approverAssignments?: ChannelApproverUncheckedCreateNestedManyWithoutUserInput
    createdCategories?: MessageCategoryUncheckedCreateNestedManyWithoutCreatorInput
    messageViews?: MessageViewUncheckedCreateNestedManyWithoutUserInput
    channelVisits?: ChannelVisitUncheckedCreateNestedManyWithoutUserInput
    createdForms?: FormUncheckedCreateNestedManyWithoutUserInput
    organizedEvents?: EventUncheckedCreateNestedManyWithoutOrganizerInput
  }

  export type UserCreateOrConnectWithoutMessageRevisionsEditedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessageRevisionsEditedInput, UserUncheckedCreateWithoutMessageRevisionsEditedInput>
  }

  export type MessageUpsertWithoutRevisionsInput = {
    update: XOR<MessageUpdateWithoutRevisionsInput, MessageUncheckedUpdateWithoutRevisionsInput>
    create: XOR<MessageCreateWithoutRevisionsInput, MessageUncheckedCreateWithoutRevisionsInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutRevisionsInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutRevisionsInput, MessageUncheckedUpdateWithoutRevisionsInput>
  }

  export type MessageUpdateWithoutRevisionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    durationSeconds?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    isImmediate?: BoolFieldUpdateOperationsInput | boolean
    priority?: EnumMessagePriorityFieldUpdateOperationsInput | $Enums.MessagePriority
    approvalOverride?: NullableEnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy | null
    approvalOverrideSetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    eventAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    state?: EnumMessageStateFieldUpdateOperationsInput | $Enums.MessageState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: ChannelUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutMessagesSentNestedInput
    category?: MessageCategoryUpdateOneRequiredWithoutMessagesNestedInput
    overrideSetter?: UserUpdateOneWithoutMessagesOverrideSetNestedInput
    deliveries?: MessageDeliveryUpdateManyWithoutMessageNestedInput
    approvals?: MessageApprovalUpdateManyWithoutMessageNestedInput
    attachments?: MessageAttachmentUpdateManyWithoutMessageNestedInput
    views?: MessageViewUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutRevisionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    durationSeconds?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    isImmediate?: BoolFieldUpdateOperationsInput | boolean
    priority?: EnumMessagePriorityFieldUpdateOperationsInput | $Enums.MessagePriority
    approvalOverride?: NullableEnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy | null
    approvalOverrideSetBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvalOverrideSetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    eventAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    state?: EnumMessageStateFieldUpdateOperationsInput | $Enums.MessageState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: MessageDeliveryUncheckedUpdateManyWithoutMessageNestedInput
    approvals?: MessageApprovalUncheckedUpdateManyWithoutMessageNestedInput
    attachments?: MessageAttachmentUncheckedUpdateManyWithoutMessageNestedInput
    views?: MessageViewUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type UserUpsertWithoutMessageRevisionsEditedInput = {
    update: XOR<UserUpdateWithoutMessageRevisionsEditedInput, UserUncheckedUpdateWithoutMessageRevisionsEditedInput>
    create: XOR<UserCreateWithoutMessageRevisionsEditedInput, UserUncheckedCreateWithoutMessageRevisionsEditedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessageRevisionsEditedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessageRevisionsEditedInput, UserUncheckedUpdateWithoutMessageRevisionsEditedInput>
  }

  export type UserUpdateWithoutMessageRevisionsEditedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isCoordinator?: BoolFieldUpdateOperationsInput | boolean
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedChannels?: ChannelUpdateManyWithoutOwnerNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesOverrideSet?: MessageUpdateManyWithoutOverrideSetterNestedInput
    subscriptions?: ChannelSubscriptionUpdateManyWithoutUserNestedInput
    invitationLinks?: InvitationLinkUpdateManyWithoutCreatorNestedInput
    qrCodes?: QrCodeUpdateManyWithoutCreatorNestedInput
    messageDeliveries?: MessageDeliveryUpdateManyWithoutUserNestedInput
    messageApprovals?: MessageApprovalUpdateManyWithoutApproverNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    messagingSettings?: UserMessagingSettingUpdateManyWithoutUserNestedInput
    approverAssignments?: ChannelApproverUpdateManyWithoutUserNestedInput
    createdCategories?: MessageCategoryUpdateManyWithoutCreatorNestedInput
    messageViews?: MessageViewUpdateManyWithoutUserNestedInput
    channelVisits?: ChannelVisitUpdateManyWithoutUserNestedInput
    createdForms?: FormUpdateManyWithoutUserNestedInput
    organizedEvents?: EventUpdateManyWithoutOrganizerNestedInput
  }

  export type UserUncheckedUpdateWithoutMessageRevisionsEditedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isCoordinator?: BoolFieldUpdateOperationsInput | boolean
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedChannels?: ChannelUncheckedUpdateManyWithoutOwnerNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesOverrideSet?: MessageUncheckedUpdateManyWithoutOverrideSetterNestedInput
    subscriptions?: ChannelSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invitationLinks?: InvitationLinkUncheckedUpdateManyWithoutCreatorNestedInput
    qrCodes?: QrCodeUncheckedUpdateManyWithoutCreatorNestedInput
    messageDeliveries?: MessageDeliveryUncheckedUpdateManyWithoutUserNestedInput
    messageApprovals?: MessageApprovalUncheckedUpdateManyWithoutApproverNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    messagingSettings?: UserMessagingSettingUncheckedUpdateManyWithoutUserNestedInput
    approverAssignments?: ChannelApproverUncheckedUpdateManyWithoutUserNestedInput
    createdCategories?: MessageCategoryUncheckedUpdateManyWithoutCreatorNestedInput
    messageViews?: MessageViewUncheckedUpdateManyWithoutUserNestedInput
    channelVisits?: ChannelVisitUncheckedUpdateManyWithoutUserNestedInput
    createdForms?: FormUncheckedUpdateManyWithoutUserNestedInput
    organizedEvents?: EventUncheckedUpdateManyWithoutOrganizerNestedInput
  }

  export type ChannelCreateWithoutVerificationDocsInput = {
    id?: string
    title: string
    description?: string | null
    websiteUrl?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: string | null
    icon?: string
    isPublic?: boolean
    isHidden?: boolean
    searchExactOnly?: boolean
    passwordHash?: string | null
    referenceCode?: string | null
    verificationStatus?: $Enums.VerificationStatus
    approvalPolicy?: $Enums.ApprovalPolicy
    memberCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedChannelsInput
    organization: OrganizationCreateNestedOneWithoutChannelsInput
    parent?: ChannelCreateNestedOneWithoutSubchannelsInput
    subchannels?: ChannelCreateNestedManyWithoutParentInput
    messages?: MessageCreateNestedManyWithoutChannelInput
    subscriptions?: ChannelSubscriptionCreateNestedManyWithoutChannelInput
    invitationLinks?: InvitationLinkCreateNestedManyWithoutChannelInput
    qrCodes?: QrCodeCreateNestedManyWithoutChannelInput
    approvers?: ChannelApproverCreateNestedManyWithoutChannelInput
    categories?: ChannelCategoryAssignmentCreateNestedManyWithoutChannelInput
    messageCategories?: MessageCategoryCreateNestedManyWithoutChannelInput
    visits?: ChannelVisitCreateNestedManyWithoutChannelInput
  }

  export type ChannelUncheckedCreateWithoutVerificationDocsInput = {
    id?: string
    title: string
    description?: string | null
    websiteUrl?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: string | null
    icon?: string
    parentId?: string | null
    ownerId: string
    organizationId: string
    isPublic?: boolean
    isHidden?: boolean
    searchExactOnly?: boolean
    passwordHash?: string | null
    referenceCode?: string | null
    verificationStatus?: $Enums.VerificationStatus
    approvalPolicy?: $Enums.ApprovalPolicy
    memberCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    subchannels?: ChannelUncheckedCreateNestedManyWithoutParentInput
    messages?: MessageUncheckedCreateNestedManyWithoutChannelInput
    subscriptions?: ChannelSubscriptionUncheckedCreateNestedManyWithoutChannelInput
    invitationLinks?: InvitationLinkUncheckedCreateNestedManyWithoutChannelInput
    qrCodes?: QrCodeUncheckedCreateNestedManyWithoutChannelInput
    approvers?: ChannelApproverUncheckedCreateNestedManyWithoutChannelInput
    categories?: ChannelCategoryAssignmentUncheckedCreateNestedManyWithoutChannelInput
    messageCategories?: MessageCategoryUncheckedCreateNestedManyWithoutChannelInput
    visits?: ChannelVisitUncheckedCreateNestedManyWithoutChannelInput
  }

  export type ChannelCreateOrConnectWithoutVerificationDocsInput = {
    where: ChannelWhereUniqueInput
    create: XOR<ChannelCreateWithoutVerificationDocsInput, ChannelUncheckedCreateWithoutVerificationDocsInput>
  }

  export type ChannelUpsertWithoutVerificationDocsInput = {
    update: XOR<ChannelUpdateWithoutVerificationDocsInput, ChannelUncheckedUpdateWithoutVerificationDocsInput>
    create: XOR<ChannelCreateWithoutVerificationDocsInput, ChannelUncheckedCreateWithoutVerificationDocsInput>
    where?: ChannelWhereInput
  }

  export type ChannelUpdateToOneWithWhereWithoutVerificationDocsInput = {
    where?: ChannelWhereInput
    data: XOR<ChannelUpdateWithoutVerificationDocsInput, ChannelUncheckedUpdateWithoutVerificationDocsInput>
  }

  export type ChannelUpdateWithoutVerificationDocsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    searchExactOnly?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    approvalPolicy?: EnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy
    memberCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedChannelsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutChannelsNestedInput
    parent?: ChannelUpdateOneWithoutSubchannelsNestedInput
    subchannels?: ChannelUpdateManyWithoutParentNestedInput
    messages?: MessageUpdateManyWithoutChannelNestedInput
    subscriptions?: ChannelSubscriptionUpdateManyWithoutChannelNestedInput
    invitationLinks?: InvitationLinkUpdateManyWithoutChannelNestedInput
    qrCodes?: QrCodeUpdateManyWithoutChannelNestedInput
    approvers?: ChannelApproverUpdateManyWithoutChannelNestedInput
    categories?: ChannelCategoryAssignmentUpdateManyWithoutChannelNestedInput
    messageCategories?: MessageCategoryUpdateManyWithoutChannelNestedInput
    visits?: ChannelVisitUpdateManyWithoutChannelNestedInput
  }

  export type ChannelUncheckedUpdateWithoutVerificationDocsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    searchExactOnly?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    approvalPolicy?: EnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy
    memberCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subchannels?: ChannelUncheckedUpdateManyWithoutParentNestedInput
    messages?: MessageUncheckedUpdateManyWithoutChannelNestedInput
    subscriptions?: ChannelSubscriptionUncheckedUpdateManyWithoutChannelNestedInput
    invitationLinks?: InvitationLinkUncheckedUpdateManyWithoutChannelNestedInput
    qrCodes?: QrCodeUncheckedUpdateManyWithoutChannelNestedInput
    approvers?: ChannelApproverUncheckedUpdateManyWithoutChannelNestedInput
    categories?: ChannelCategoryAssignmentUncheckedUpdateManyWithoutChannelNestedInput
    messageCategories?: MessageCategoryUncheckedUpdateManyWithoutChannelNestedInput
    visits?: ChannelVisitUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type UserCreateWithoutProfileInput = {
    id?: string
    email: string
    username: string
    fullName?: string | null
    avatarUrl?: string | null
    passwordHash?: string | null
    deviceId?: string | null
    isGuest?: boolean
    phoneNumber?: string | null
    isPhoneVerified?: boolean
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    isAdmin?: boolean
    isCoordinator?: boolean
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedChannels?: ChannelCreateNestedManyWithoutOwnerInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesOverrideSet?: MessageCreateNestedManyWithoutOverrideSetterInput
    subscriptions?: ChannelSubscriptionCreateNestedManyWithoutUserInput
    invitationLinks?: InvitationLinkCreateNestedManyWithoutCreatorInput
    qrCodes?: QrCodeCreateNestedManyWithoutCreatorInput
    messageDeliveries?: MessageDeliveryCreateNestedManyWithoutUserInput
    messageApprovals?: MessageApprovalCreateNestedManyWithoutApproverInput
    messageRevisionsEdited?: MessageRevisionCreateNestedManyWithoutEditorInput
    messagingSettings?: UserMessagingSettingCreateNestedManyWithoutUserInput
    approverAssignments?: ChannelApproverCreateNestedManyWithoutUserInput
    createdCategories?: MessageCategoryCreateNestedManyWithoutCreatorInput
    messageViews?: MessageViewCreateNestedManyWithoutUserInput
    channelVisits?: ChannelVisitCreateNestedManyWithoutUserInput
    createdForms?: FormCreateNestedManyWithoutUserInput
    organizedEvents?: EventCreateNestedManyWithoutOrganizerInput
  }

  export type UserUncheckedCreateWithoutProfileInput = {
    id?: string
    email: string
    username: string
    fullName?: string | null
    avatarUrl?: string | null
    passwordHash?: string | null
    deviceId?: string | null
    isGuest?: boolean
    phoneNumber?: string | null
    isPhoneVerified?: boolean
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    isAdmin?: boolean
    isCoordinator?: boolean
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedChannels?: ChannelUncheckedCreateNestedManyWithoutOwnerInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesOverrideSet?: MessageUncheckedCreateNestedManyWithoutOverrideSetterInput
    subscriptions?: ChannelSubscriptionUncheckedCreateNestedManyWithoutUserInput
    invitationLinks?: InvitationLinkUncheckedCreateNestedManyWithoutCreatorInput
    qrCodes?: QrCodeUncheckedCreateNestedManyWithoutCreatorInput
    messageDeliveries?: MessageDeliveryUncheckedCreateNestedManyWithoutUserInput
    messageApprovals?: MessageApprovalUncheckedCreateNestedManyWithoutApproverInput
    messageRevisionsEdited?: MessageRevisionUncheckedCreateNestedManyWithoutEditorInput
    messagingSettings?: UserMessagingSettingUncheckedCreateNestedManyWithoutUserInput
    approverAssignments?: ChannelApproverUncheckedCreateNestedManyWithoutUserInput
    createdCategories?: MessageCategoryUncheckedCreateNestedManyWithoutCreatorInput
    messageViews?: MessageViewUncheckedCreateNestedManyWithoutUserInput
    channelVisits?: ChannelVisitUncheckedCreateNestedManyWithoutUserInput
    createdForms?: FormUncheckedCreateNestedManyWithoutUserInput
    organizedEvents?: EventUncheckedCreateNestedManyWithoutOrganizerInput
  }

  export type UserCreateOrConnectWithoutProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type UserUpsertWithoutProfileInput = {
    update: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isCoordinator?: BoolFieldUpdateOperationsInput | boolean
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedChannels?: ChannelUpdateManyWithoutOwnerNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesOverrideSet?: MessageUpdateManyWithoutOverrideSetterNestedInput
    subscriptions?: ChannelSubscriptionUpdateManyWithoutUserNestedInput
    invitationLinks?: InvitationLinkUpdateManyWithoutCreatorNestedInput
    qrCodes?: QrCodeUpdateManyWithoutCreatorNestedInput
    messageDeliveries?: MessageDeliveryUpdateManyWithoutUserNestedInput
    messageApprovals?: MessageApprovalUpdateManyWithoutApproverNestedInput
    messageRevisionsEdited?: MessageRevisionUpdateManyWithoutEditorNestedInput
    messagingSettings?: UserMessagingSettingUpdateManyWithoutUserNestedInput
    approverAssignments?: ChannelApproverUpdateManyWithoutUserNestedInput
    createdCategories?: MessageCategoryUpdateManyWithoutCreatorNestedInput
    messageViews?: MessageViewUpdateManyWithoutUserNestedInput
    channelVisits?: ChannelVisitUpdateManyWithoutUserNestedInput
    createdForms?: FormUpdateManyWithoutUserNestedInput
    organizedEvents?: EventUpdateManyWithoutOrganizerNestedInput
  }

  export type UserUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isCoordinator?: BoolFieldUpdateOperationsInput | boolean
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedChannels?: ChannelUncheckedUpdateManyWithoutOwnerNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesOverrideSet?: MessageUncheckedUpdateManyWithoutOverrideSetterNestedInput
    subscriptions?: ChannelSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invitationLinks?: InvitationLinkUncheckedUpdateManyWithoutCreatorNestedInput
    qrCodes?: QrCodeUncheckedUpdateManyWithoutCreatorNestedInput
    messageDeliveries?: MessageDeliveryUncheckedUpdateManyWithoutUserNestedInput
    messageApprovals?: MessageApprovalUncheckedUpdateManyWithoutApproverNestedInput
    messageRevisionsEdited?: MessageRevisionUncheckedUpdateManyWithoutEditorNestedInput
    messagingSettings?: UserMessagingSettingUncheckedUpdateManyWithoutUserNestedInput
    approverAssignments?: ChannelApproverUncheckedUpdateManyWithoutUserNestedInput
    createdCategories?: MessageCategoryUncheckedUpdateManyWithoutCreatorNestedInput
    messageViews?: MessageViewUncheckedUpdateManyWithoutUserNestedInput
    channelVisits?: ChannelVisitUncheckedUpdateManyWithoutUserNestedInput
    createdForms?: FormUncheckedUpdateManyWithoutUserNestedInput
    organizedEvents?: EventUncheckedUpdateManyWithoutOrganizerNestedInput
  }

  export type UserCreateWithoutMessagingSettingsInput = {
    id?: string
    email: string
    username: string
    fullName?: string | null
    avatarUrl?: string | null
    passwordHash?: string | null
    deviceId?: string | null
    isGuest?: boolean
    phoneNumber?: string | null
    isPhoneVerified?: boolean
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    isAdmin?: boolean
    isCoordinator?: boolean
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedChannels?: ChannelCreateNestedManyWithoutOwnerInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesOverrideSet?: MessageCreateNestedManyWithoutOverrideSetterInput
    subscriptions?: ChannelSubscriptionCreateNestedManyWithoutUserInput
    invitationLinks?: InvitationLinkCreateNestedManyWithoutCreatorInput
    qrCodes?: QrCodeCreateNestedManyWithoutCreatorInput
    messageDeliveries?: MessageDeliveryCreateNestedManyWithoutUserInput
    messageApprovals?: MessageApprovalCreateNestedManyWithoutApproverInput
    messageRevisionsEdited?: MessageRevisionCreateNestedManyWithoutEditorInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    approverAssignments?: ChannelApproverCreateNestedManyWithoutUserInput
    createdCategories?: MessageCategoryCreateNestedManyWithoutCreatorInput
    messageViews?: MessageViewCreateNestedManyWithoutUserInput
    channelVisits?: ChannelVisitCreateNestedManyWithoutUserInput
    createdForms?: FormCreateNestedManyWithoutUserInput
    organizedEvents?: EventCreateNestedManyWithoutOrganizerInput
  }

  export type UserUncheckedCreateWithoutMessagingSettingsInput = {
    id?: string
    email: string
    username: string
    fullName?: string | null
    avatarUrl?: string | null
    passwordHash?: string | null
    deviceId?: string | null
    isGuest?: boolean
    phoneNumber?: string | null
    isPhoneVerified?: boolean
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    isAdmin?: boolean
    isCoordinator?: boolean
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedChannels?: ChannelUncheckedCreateNestedManyWithoutOwnerInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesOverrideSet?: MessageUncheckedCreateNestedManyWithoutOverrideSetterInput
    subscriptions?: ChannelSubscriptionUncheckedCreateNestedManyWithoutUserInput
    invitationLinks?: InvitationLinkUncheckedCreateNestedManyWithoutCreatorInput
    qrCodes?: QrCodeUncheckedCreateNestedManyWithoutCreatorInput
    messageDeliveries?: MessageDeliveryUncheckedCreateNestedManyWithoutUserInput
    messageApprovals?: MessageApprovalUncheckedCreateNestedManyWithoutApproverInput
    messageRevisionsEdited?: MessageRevisionUncheckedCreateNestedManyWithoutEditorInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    approverAssignments?: ChannelApproverUncheckedCreateNestedManyWithoutUserInput
    createdCategories?: MessageCategoryUncheckedCreateNestedManyWithoutCreatorInput
    messageViews?: MessageViewUncheckedCreateNestedManyWithoutUserInput
    channelVisits?: ChannelVisitUncheckedCreateNestedManyWithoutUserInput
    createdForms?: FormUncheckedCreateNestedManyWithoutUserInput
    organizedEvents?: EventUncheckedCreateNestedManyWithoutOrganizerInput
  }

  export type UserCreateOrConnectWithoutMessagingSettingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessagingSettingsInput, UserUncheckedCreateWithoutMessagingSettingsInput>
  }

  export type UserUpsertWithoutMessagingSettingsInput = {
    update: XOR<UserUpdateWithoutMessagingSettingsInput, UserUncheckedUpdateWithoutMessagingSettingsInput>
    create: XOR<UserCreateWithoutMessagingSettingsInput, UserUncheckedCreateWithoutMessagingSettingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessagingSettingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessagingSettingsInput, UserUncheckedUpdateWithoutMessagingSettingsInput>
  }

  export type UserUpdateWithoutMessagingSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isCoordinator?: BoolFieldUpdateOperationsInput | boolean
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedChannels?: ChannelUpdateManyWithoutOwnerNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesOverrideSet?: MessageUpdateManyWithoutOverrideSetterNestedInput
    subscriptions?: ChannelSubscriptionUpdateManyWithoutUserNestedInput
    invitationLinks?: InvitationLinkUpdateManyWithoutCreatorNestedInput
    qrCodes?: QrCodeUpdateManyWithoutCreatorNestedInput
    messageDeliveries?: MessageDeliveryUpdateManyWithoutUserNestedInput
    messageApprovals?: MessageApprovalUpdateManyWithoutApproverNestedInput
    messageRevisionsEdited?: MessageRevisionUpdateManyWithoutEditorNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    approverAssignments?: ChannelApproverUpdateManyWithoutUserNestedInput
    createdCategories?: MessageCategoryUpdateManyWithoutCreatorNestedInput
    messageViews?: MessageViewUpdateManyWithoutUserNestedInput
    channelVisits?: ChannelVisitUpdateManyWithoutUserNestedInput
    createdForms?: FormUpdateManyWithoutUserNestedInput
    organizedEvents?: EventUpdateManyWithoutOrganizerNestedInput
  }

  export type UserUncheckedUpdateWithoutMessagingSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isCoordinator?: BoolFieldUpdateOperationsInput | boolean
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedChannels?: ChannelUncheckedUpdateManyWithoutOwnerNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesOverrideSet?: MessageUncheckedUpdateManyWithoutOverrideSetterNestedInput
    subscriptions?: ChannelSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invitationLinks?: InvitationLinkUncheckedUpdateManyWithoutCreatorNestedInput
    qrCodes?: QrCodeUncheckedUpdateManyWithoutCreatorNestedInput
    messageDeliveries?: MessageDeliveryUncheckedUpdateManyWithoutUserNestedInput
    messageApprovals?: MessageApprovalUncheckedUpdateManyWithoutApproverNestedInput
    messageRevisionsEdited?: MessageRevisionUncheckedUpdateManyWithoutEditorNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    approverAssignments?: ChannelApproverUncheckedUpdateManyWithoutUserNestedInput
    createdCategories?: MessageCategoryUncheckedUpdateManyWithoutCreatorNestedInput
    messageViews?: MessageViewUncheckedUpdateManyWithoutUserNestedInput
    channelVisits?: ChannelVisitUncheckedUpdateManyWithoutUserNestedInput
    createdForms?: FormUncheckedUpdateManyWithoutUserNestedInput
    organizedEvents?: EventUncheckedUpdateManyWithoutOrganizerNestedInput
  }

  export type ChannelCategoryAssignmentCreateWithoutCategoryInput = {
    id?: string
    channel: ChannelCreateNestedOneWithoutCategoriesInput
  }

  export type ChannelCategoryAssignmentUncheckedCreateWithoutCategoryInput = {
    id?: string
    channelId: string
  }

  export type ChannelCategoryAssignmentCreateOrConnectWithoutCategoryInput = {
    where: ChannelCategoryAssignmentWhereUniqueInput
    create: XOR<ChannelCategoryAssignmentCreateWithoutCategoryInput, ChannelCategoryAssignmentUncheckedCreateWithoutCategoryInput>
  }

  export type ChannelCategoryAssignmentCreateManyCategoryInputEnvelope = {
    data: ChannelCategoryAssignmentCreateManyCategoryInput | ChannelCategoryAssignmentCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ChannelCategoryAssignmentUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ChannelCategoryAssignmentWhereUniqueInput
    update: XOR<ChannelCategoryAssignmentUpdateWithoutCategoryInput, ChannelCategoryAssignmentUncheckedUpdateWithoutCategoryInput>
    create: XOR<ChannelCategoryAssignmentCreateWithoutCategoryInput, ChannelCategoryAssignmentUncheckedCreateWithoutCategoryInput>
  }

  export type ChannelCategoryAssignmentUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ChannelCategoryAssignmentWhereUniqueInput
    data: XOR<ChannelCategoryAssignmentUpdateWithoutCategoryInput, ChannelCategoryAssignmentUncheckedUpdateWithoutCategoryInput>
  }

  export type ChannelCategoryAssignmentUpdateManyWithWhereWithoutCategoryInput = {
    where: ChannelCategoryAssignmentScalarWhereInput
    data: XOR<ChannelCategoryAssignmentUpdateManyMutationInput, ChannelCategoryAssignmentUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ChannelCreateWithoutCategoriesInput = {
    id?: string
    title: string
    description?: string | null
    websiteUrl?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: string | null
    icon?: string
    isPublic?: boolean
    isHidden?: boolean
    searchExactOnly?: boolean
    passwordHash?: string | null
    referenceCode?: string | null
    verificationStatus?: $Enums.VerificationStatus
    approvalPolicy?: $Enums.ApprovalPolicy
    memberCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedChannelsInput
    organization: OrganizationCreateNestedOneWithoutChannelsInput
    parent?: ChannelCreateNestedOneWithoutSubchannelsInput
    subchannels?: ChannelCreateNestedManyWithoutParentInput
    messages?: MessageCreateNestedManyWithoutChannelInput
    subscriptions?: ChannelSubscriptionCreateNestedManyWithoutChannelInput
    invitationLinks?: InvitationLinkCreateNestedManyWithoutChannelInput
    qrCodes?: QrCodeCreateNestedManyWithoutChannelInput
    approvers?: ChannelApproverCreateNestedManyWithoutChannelInput
    verificationDocs?: ChannelVerificationDocumentCreateNestedManyWithoutChannelInput
    messageCategories?: MessageCategoryCreateNestedManyWithoutChannelInput
    visits?: ChannelVisitCreateNestedManyWithoutChannelInput
  }

  export type ChannelUncheckedCreateWithoutCategoriesInput = {
    id?: string
    title: string
    description?: string | null
    websiteUrl?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: string | null
    icon?: string
    parentId?: string | null
    ownerId: string
    organizationId: string
    isPublic?: boolean
    isHidden?: boolean
    searchExactOnly?: boolean
    passwordHash?: string | null
    referenceCode?: string | null
    verificationStatus?: $Enums.VerificationStatus
    approvalPolicy?: $Enums.ApprovalPolicy
    memberCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    subchannels?: ChannelUncheckedCreateNestedManyWithoutParentInput
    messages?: MessageUncheckedCreateNestedManyWithoutChannelInput
    subscriptions?: ChannelSubscriptionUncheckedCreateNestedManyWithoutChannelInput
    invitationLinks?: InvitationLinkUncheckedCreateNestedManyWithoutChannelInput
    qrCodes?: QrCodeUncheckedCreateNestedManyWithoutChannelInput
    approvers?: ChannelApproverUncheckedCreateNestedManyWithoutChannelInput
    verificationDocs?: ChannelVerificationDocumentUncheckedCreateNestedManyWithoutChannelInput
    messageCategories?: MessageCategoryUncheckedCreateNestedManyWithoutChannelInput
    visits?: ChannelVisitUncheckedCreateNestedManyWithoutChannelInput
  }

  export type ChannelCreateOrConnectWithoutCategoriesInput = {
    where: ChannelWhereUniqueInput
    create: XOR<ChannelCreateWithoutCategoriesInput, ChannelUncheckedCreateWithoutCategoriesInput>
  }

  export type ChannelCategoryCreateWithoutAssignmentsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
  }

  export type ChannelCategoryUncheckedCreateWithoutAssignmentsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
  }

  export type ChannelCategoryCreateOrConnectWithoutAssignmentsInput = {
    where: ChannelCategoryWhereUniqueInput
    create: XOR<ChannelCategoryCreateWithoutAssignmentsInput, ChannelCategoryUncheckedCreateWithoutAssignmentsInput>
  }

  export type ChannelUpsertWithoutCategoriesInput = {
    update: XOR<ChannelUpdateWithoutCategoriesInput, ChannelUncheckedUpdateWithoutCategoriesInput>
    create: XOR<ChannelCreateWithoutCategoriesInput, ChannelUncheckedCreateWithoutCategoriesInput>
    where?: ChannelWhereInput
  }

  export type ChannelUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: ChannelWhereInput
    data: XOR<ChannelUpdateWithoutCategoriesInput, ChannelUncheckedUpdateWithoutCategoriesInput>
  }

  export type ChannelUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    searchExactOnly?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    approvalPolicy?: EnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy
    memberCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedChannelsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutChannelsNestedInput
    parent?: ChannelUpdateOneWithoutSubchannelsNestedInput
    subchannels?: ChannelUpdateManyWithoutParentNestedInput
    messages?: MessageUpdateManyWithoutChannelNestedInput
    subscriptions?: ChannelSubscriptionUpdateManyWithoutChannelNestedInput
    invitationLinks?: InvitationLinkUpdateManyWithoutChannelNestedInput
    qrCodes?: QrCodeUpdateManyWithoutChannelNestedInput
    approvers?: ChannelApproverUpdateManyWithoutChannelNestedInput
    verificationDocs?: ChannelVerificationDocumentUpdateManyWithoutChannelNestedInput
    messageCategories?: MessageCategoryUpdateManyWithoutChannelNestedInput
    visits?: ChannelVisitUpdateManyWithoutChannelNestedInput
  }

  export type ChannelUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    searchExactOnly?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    approvalPolicy?: EnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy
    memberCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subchannels?: ChannelUncheckedUpdateManyWithoutParentNestedInput
    messages?: MessageUncheckedUpdateManyWithoutChannelNestedInput
    subscriptions?: ChannelSubscriptionUncheckedUpdateManyWithoutChannelNestedInput
    invitationLinks?: InvitationLinkUncheckedUpdateManyWithoutChannelNestedInput
    qrCodes?: QrCodeUncheckedUpdateManyWithoutChannelNestedInput
    approvers?: ChannelApproverUncheckedUpdateManyWithoutChannelNestedInput
    verificationDocs?: ChannelVerificationDocumentUncheckedUpdateManyWithoutChannelNestedInput
    messageCategories?: MessageCategoryUncheckedUpdateManyWithoutChannelNestedInput
    visits?: ChannelVisitUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type ChannelCategoryUpsertWithoutAssignmentsInput = {
    update: XOR<ChannelCategoryUpdateWithoutAssignmentsInput, ChannelCategoryUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<ChannelCategoryCreateWithoutAssignmentsInput, ChannelCategoryUncheckedCreateWithoutAssignmentsInput>
    where?: ChannelCategoryWhereInput
  }

  export type ChannelCategoryUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: ChannelCategoryWhereInput
    data: XOR<ChannelCategoryUpdateWithoutAssignmentsInput, ChannelCategoryUncheckedUpdateWithoutAssignmentsInput>
  }

  export type ChannelCategoryUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelCategoryUncheckedUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateWithoutViewsInput = {
    id?: string
    content: string
    durationSeconds?: number
    expiresAt?: Date | string | null
    isEmergency?: boolean
    isImmediate?: boolean
    priority?: $Enums.MessagePriority
    approvalOverride?: $Enums.ApprovalPolicy | null
    approvalOverrideSetAt?: Date | string | null
    deliveryMethod?: $Enums.DeliveryMethod
    eventAt?: Date | string | null
    publishedAt?: Date | string | null
    state?: $Enums.MessageState
    createdAt?: Date | string
    updatedAt?: Date | string
    channel: ChannelCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutMessagesSentInput
    category: MessageCategoryCreateNestedOneWithoutMessagesInput
    overrideSetter?: UserCreateNestedOneWithoutMessagesOverrideSetInput
    deliveries?: MessageDeliveryCreateNestedManyWithoutMessageInput
    approvals?: MessageApprovalCreateNestedManyWithoutMessageInput
    attachments?: MessageAttachmentCreateNestedManyWithoutMessageInput
    revisions?: MessageRevisionCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutViewsInput = {
    id?: string
    channelId: string
    senderId: string
    categoryId: string
    content: string
    durationSeconds?: number
    expiresAt?: Date | string | null
    isEmergency?: boolean
    isImmediate?: boolean
    priority?: $Enums.MessagePriority
    approvalOverride?: $Enums.ApprovalPolicy | null
    approvalOverrideSetBy?: string | null
    approvalOverrideSetAt?: Date | string | null
    deliveryMethod?: $Enums.DeliveryMethod
    eventAt?: Date | string | null
    publishedAt?: Date | string | null
    state?: $Enums.MessageState
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveries?: MessageDeliveryUncheckedCreateNestedManyWithoutMessageInput
    approvals?: MessageApprovalUncheckedCreateNestedManyWithoutMessageInput
    attachments?: MessageAttachmentUncheckedCreateNestedManyWithoutMessageInput
    revisions?: MessageRevisionUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutViewsInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutViewsInput, MessageUncheckedCreateWithoutViewsInput>
  }

  export type UserCreateWithoutMessageViewsInput = {
    id?: string
    email: string
    username: string
    fullName?: string | null
    avatarUrl?: string | null
    passwordHash?: string | null
    deviceId?: string | null
    isGuest?: boolean
    phoneNumber?: string | null
    isPhoneVerified?: boolean
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    isAdmin?: boolean
    isCoordinator?: boolean
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedChannels?: ChannelCreateNestedManyWithoutOwnerInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesOverrideSet?: MessageCreateNestedManyWithoutOverrideSetterInput
    subscriptions?: ChannelSubscriptionCreateNestedManyWithoutUserInput
    invitationLinks?: InvitationLinkCreateNestedManyWithoutCreatorInput
    qrCodes?: QrCodeCreateNestedManyWithoutCreatorInput
    messageDeliveries?: MessageDeliveryCreateNestedManyWithoutUserInput
    messageApprovals?: MessageApprovalCreateNestedManyWithoutApproverInput
    messageRevisionsEdited?: MessageRevisionCreateNestedManyWithoutEditorInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    messagingSettings?: UserMessagingSettingCreateNestedManyWithoutUserInput
    approverAssignments?: ChannelApproverCreateNestedManyWithoutUserInput
    createdCategories?: MessageCategoryCreateNestedManyWithoutCreatorInput
    channelVisits?: ChannelVisitCreateNestedManyWithoutUserInput
    createdForms?: FormCreateNestedManyWithoutUserInput
    organizedEvents?: EventCreateNestedManyWithoutOrganizerInput
  }

  export type UserUncheckedCreateWithoutMessageViewsInput = {
    id?: string
    email: string
    username: string
    fullName?: string | null
    avatarUrl?: string | null
    passwordHash?: string | null
    deviceId?: string | null
    isGuest?: boolean
    phoneNumber?: string | null
    isPhoneVerified?: boolean
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    isAdmin?: boolean
    isCoordinator?: boolean
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedChannels?: ChannelUncheckedCreateNestedManyWithoutOwnerInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesOverrideSet?: MessageUncheckedCreateNestedManyWithoutOverrideSetterInput
    subscriptions?: ChannelSubscriptionUncheckedCreateNestedManyWithoutUserInput
    invitationLinks?: InvitationLinkUncheckedCreateNestedManyWithoutCreatorInput
    qrCodes?: QrCodeUncheckedCreateNestedManyWithoutCreatorInput
    messageDeliveries?: MessageDeliveryUncheckedCreateNestedManyWithoutUserInput
    messageApprovals?: MessageApprovalUncheckedCreateNestedManyWithoutApproverInput
    messageRevisionsEdited?: MessageRevisionUncheckedCreateNestedManyWithoutEditorInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    messagingSettings?: UserMessagingSettingUncheckedCreateNestedManyWithoutUserInput
    approverAssignments?: ChannelApproverUncheckedCreateNestedManyWithoutUserInput
    createdCategories?: MessageCategoryUncheckedCreateNestedManyWithoutCreatorInput
    channelVisits?: ChannelVisitUncheckedCreateNestedManyWithoutUserInput
    createdForms?: FormUncheckedCreateNestedManyWithoutUserInput
    organizedEvents?: EventUncheckedCreateNestedManyWithoutOrganizerInput
  }

  export type UserCreateOrConnectWithoutMessageViewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessageViewsInput, UserUncheckedCreateWithoutMessageViewsInput>
  }

  export type MessageUpsertWithoutViewsInput = {
    update: XOR<MessageUpdateWithoutViewsInput, MessageUncheckedUpdateWithoutViewsInput>
    create: XOR<MessageCreateWithoutViewsInput, MessageUncheckedCreateWithoutViewsInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutViewsInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutViewsInput, MessageUncheckedUpdateWithoutViewsInput>
  }

  export type MessageUpdateWithoutViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    durationSeconds?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    isImmediate?: BoolFieldUpdateOperationsInput | boolean
    priority?: EnumMessagePriorityFieldUpdateOperationsInput | $Enums.MessagePriority
    approvalOverride?: NullableEnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy | null
    approvalOverrideSetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    eventAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    state?: EnumMessageStateFieldUpdateOperationsInput | $Enums.MessageState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: ChannelUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutMessagesSentNestedInput
    category?: MessageCategoryUpdateOneRequiredWithoutMessagesNestedInput
    overrideSetter?: UserUpdateOneWithoutMessagesOverrideSetNestedInput
    deliveries?: MessageDeliveryUpdateManyWithoutMessageNestedInput
    approvals?: MessageApprovalUpdateManyWithoutMessageNestedInput
    attachments?: MessageAttachmentUpdateManyWithoutMessageNestedInput
    revisions?: MessageRevisionUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    durationSeconds?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    isImmediate?: BoolFieldUpdateOperationsInput | boolean
    priority?: EnumMessagePriorityFieldUpdateOperationsInput | $Enums.MessagePriority
    approvalOverride?: NullableEnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy | null
    approvalOverrideSetBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvalOverrideSetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    eventAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    state?: EnumMessageStateFieldUpdateOperationsInput | $Enums.MessageState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: MessageDeliveryUncheckedUpdateManyWithoutMessageNestedInput
    approvals?: MessageApprovalUncheckedUpdateManyWithoutMessageNestedInput
    attachments?: MessageAttachmentUncheckedUpdateManyWithoutMessageNestedInput
    revisions?: MessageRevisionUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type UserUpsertWithoutMessageViewsInput = {
    update: XOR<UserUpdateWithoutMessageViewsInput, UserUncheckedUpdateWithoutMessageViewsInput>
    create: XOR<UserCreateWithoutMessageViewsInput, UserUncheckedCreateWithoutMessageViewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessageViewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessageViewsInput, UserUncheckedUpdateWithoutMessageViewsInput>
  }

  export type UserUpdateWithoutMessageViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isCoordinator?: BoolFieldUpdateOperationsInput | boolean
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedChannels?: ChannelUpdateManyWithoutOwnerNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesOverrideSet?: MessageUpdateManyWithoutOverrideSetterNestedInput
    subscriptions?: ChannelSubscriptionUpdateManyWithoutUserNestedInput
    invitationLinks?: InvitationLinkUpdateManyWithoutCreatorNestedInput
    qrCodes?: QrCodeUpdateManyWithoutCreatorNestedInput
    messageDeliveries?: MessageDeliveryUpdateManyWithoutUserNestedInput
    messageApprovals?: MessageApprovalUpdateManyWithoutApproverNestedInput
    messageRevisionsEdited?: MessageRevisionUpdateManyWithoutEditorNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    messagingSettings?: UserMessagingSettingUpdateManyWithoutUserNestedInput
    approverAssignments?: ChannelApproverUpdateManyWithoutUserNestedInput
    createdCategories?: MessageCategoryUpdateManyWithoutCreatorNestedInput
    channelVisits?: ChannelVisitUpdateManyWithoutUserNestedInput
    createdForms?: FormUpdateManyWithoutUserNestedInput
    organizedEvents?: EventUpdateManyWithoutOrganizerNestedInput
  }

  export type UserUncheckedUpdateWithoutMessageViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isCoordinator?: BoolFieldUpdateOperationsInput | boolean
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedChannels?: ChannelUncheckedUpdateManyWithoutOwnerNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesOverrideSet?: MessageUncheckedUpdateManyWithoutOverrideSetterNestedInput
    subscriptions?: ChannelSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invitationLinks?: InvitationLinkUncheckedUpdateManyWithoutCreatorNestedInput
    qrCodes?: QrCodeUncheckedUpdateManyWithoutCreatorNestedInput
    messageDeliveries?: MessageDeliveryUncheckedUpdateManyWithoutUserNestedInput
    messageApprovals?: MessageApprovalUncheckedUpdateManyWithoutApproverNestedInput
    messageRevisionsEdited?: MessageRevisionUncheckedUpdateManyWithoutEditorNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    messagingSettings?: UserMessagingSettingUncheckedUpdateManyWithoutUserNestedInput
    approverAssignments?: ChannelApproverUncheckedUpdateManyWithoutUserNestedInput
    createdCategories?: MessageCategoryUncheckedUpdateManyWithoutCreatorNestedInput
    channelVisits?: ChannelVisitUncheckedUpdateManyWithoutUserNestedInput
    createdForms?: FormUncheckedUpdateManyWithoutUserNestedInput
    organizedEvents?: EventUncheckedUpdateManyWithoutOrganizerNestedInput
  }

  export type ChannelCreateWithoutVisitsInput = {
    id?: string
    title: string
    description?: string | null
    websiteUrl?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: string | null
    icon?: string
    isPublic?: boolean
    isHidden?: boolean
    searchExactOnly?: boolean
    passwordHash?: string | null
    referenceCode?: string | null
    verificationStatus?: $Enums.VerificationStatus
    approvalPolicy?: $Enums.ApprovalPolicy
    memberCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedChannelsInput
    organization: OrganizationCreateNestedOneWithoutChannelsInput
    parent?: ChannelCreateNestedOneWithoutSubchannelsInput
    subchannels?: ChannelCreateNestedManyWithoutParentInput
    messages?: MessageCreateNestedManyWithoutChannelInput
    subscriptions?: ChannelSubscriptionCreateNestedManyWithoutChannelInput
    invitationLinks?: InvitationLinkCreateNestedManyWithoutChannelInput
    qrCodes?: QrCodeCreateNestedManyWithoutChannelInput
    approvers?: ChannelApproverCreateNestedManyWithoutChannelInput
    verificationDocs?: ChannelVerificationDocumentCreateNestedManyWithoutChannelInput
    categories?: ChannelCategoryAssignmentCreateNestedManyWithoutChannelInput
    messageCategories?: MessageCategoryCreateNestedManyWithoutChannelInput
  }

  export type ChannelUncheckedCreateWithoutVisitsInput = {
    id?: string
    title: string
    description?: string | null
    websiteUrl?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: string | null
    icon?: string
    parentId?: string | null
    ownerId: string
    organizationId: string
    isPublic?: boolean
    isHidden?: boolean
    searchExactOnly?: boolean
    passwordHash?: string | null
    referenceCode?: string | null
    verificationStatus?: $Enums.VerificationStatus
    approvalPolicy?: $Enums.ApprovalPolicy
    memberCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    subchannels?: ChannelUncheckedCreateNestedManyWithoutParentInput
    messages?: MessageUncheckedCreateNestedManyWithoutChannelInput
    subscriptions?: ChannelSubscriptionUncheckedCreateNestedManyWithoutChannelInput
    invitationLinks?: InvitationLinkUncheckedCreateNestedManyWithoutChannelInput
    qrCodes?: QrCodeUncheckedCreateNestedManyWithoutChannelInput
    approvers?: ChannelApproverUncheckedCreateNestedManyWithoutChannelInput
    verificationDocs?: ChannelVerificationDocumentUncheckedCreateNestedManyWithoutChannelInput
    categories?: ChannelCategoryAssignmentUncheckedCreateNestedManyWithoutChannelInput
    messageCategories?: MessageCategoryUncheckedCreateNestedManyWithoutChannelInput
  }

  export type ChannelCreateOrConnectWithoutVisitsInput = {
    where: ChannelWhereUniqueInput
    create: XOR<ChannelCreateWithoutVisitsInput, ChannelUncheckedCreateWithoutVisitsInput>
  }

  export type UserCreateWithoutChannelVisitsInput = {
    id?: string
    email: string
    username: string
    fullName?: string | null
    avatarUrl?: string | null
    passwordHash?: string | null
    deviceId?: string | null
    isGuest?: boolean
    phoneNumber?: string | null
    isPhoneVerified?: boolean
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    isAdmin?: boolean
    isCoordinator?: boolean
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedChannels?: ChannelCreateNestedManyWithoutOwnerInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesOverrideSet?: MessageCreateNestedManyWithoutOverrideSetterInput
    subscriptions?: ChannelSubscriptionCreateNestedManyWithoutUserInput
    invitationLinks?: InvitationLinkCreateNestedManyWithoutCreatorInput
    qrCodes?: QrCodeCreateNestedManyWithoutCreatorInput
    messageDeliveries?: MessageDeliveryCreateNestedManyWithoutUserInput
    messageApprovals?: MessageApprovalCreateNestedManyWithoutApproverInput
    messageRevisionsEdited?: MessageRevisionCreateNestedManyWithoutEditorInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    messagingSettings?: UserMessagingSettingCreateNestedManyWithoutUserInput
    approverAssignments?: ChannelApproverCreateNestedManyWithoutUserInput
    createdCategories?: MessageCategoryCreateNestedManyWithoutCreatorInput
    messageViews?: MessageViewCreateNestedManyWithoutUserInput
    createdForms?: FormCreateNestedManyWithoutUserInput
    organizedEvents?: EventCreateNestedManyWithoutOrganizerInput
  }

  export type UserUncheckedCreateWithoutChannelVisitsInput = {
    id?: string
    email: string
    username: string
    fullName?: string | null
    avatarUrl?: string | null
    passwordHash?: string | null
    deviceId?: string | null
    isGuest?: boolean
    phoneNumber?: string | null
    isPhoneVerified?: boolean
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    isAdmin?: boolean
    isCoordinator?: boolean
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedChannels?: ChannelUncheckedCreateNestedManyWithoutOwnerInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesOverrideSet?: MessageUncheckedCreateNestedManyWithoutOverrideSetterInput
    subscriptions?: ChannelSubscriptionUncheckedCreateNestedManyWithoutUserInput
    invitationLinks?: InvitationLinkUncheckedCreateNestedManyWithoutCreatorInput
    qrCodes?: QrCodeUncheckedCreateNestedManyWithoutCreatorInput
    messageDeliveries?: MessageDeliveryUncheckedCreateNestedManyWithoutUserInput
    messageApprovals?: MessageApprovalUncheckedCreateNestedManyWithoutApproverInput
    messageRevisionsEdited?: MessageRevisionUncheckedCreateNestedManyWithoutEditorInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    messagingSettings?: UserMessagingSettingUncheckedCreateNestedManyWithoutUserInput
    approverAssignments?: ChannelApproverUncheckedCreateNestedManyWithoutUserInput
    createdCategories?: MessageCategoryUncheckedCreateNestedManyWithoutCreatorInput
    messageViews?: MessageViewUncheckedCreateNestedManyWithoutUserInput
    createdForms?: FormUncheckedCreateNestedManyWithoutUserInput
    organizedEvents?: EventUncheckedCreateNestedManyWithoutOrganizerInput
  }

  export type UserCreateOrConnectWithoutChannelVisitsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChannelVisitsInput, UserUncheckedCreateWithoutChannelVisitsInput>
  }

  export type ChannelUpsertWithoutVisitsInput = {
    update: XOR<ChannelUpdateWithoutVisitsInput, ChannelUncheckedUpdateWithoutVisitsInput>
    create: XOR<ChannelCreateWithoutVisitsInput, ChannelUncheckedCreateWithoutVisitsInput>
    where?: ChannelWhereInput
  }

  export type ChannelUpdateToOneWithWhereWithoutVisitsInput = {
    where?: ChannelWhereInput
    data: XOR<ChannelUpdateWithoutVisitsInput, ChannelUncheckedUpdateWithoutVisitsInput>
  }

  export type ChannelUpdateWithoutVisitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    searchExactOnly?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    approvalPolicy?: EnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy
    memberCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedChannelsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutChannelsNestedInput
    parent?: ChannelUpdateOneWithoutSubchannelsNestedInput
    subchannels?: ChannelUpdateManyWithoutParentNestedInput
    messages?: MessageUpdateManyWithoutChannelNestedInput
    subscriptions?: ChannelSubscriptionUpdateManyWithoutChannelNestedInput
    invitationLinks?: InvitationLinkUpdateManyWithoutChannelNestedInput
    qrCodes?: QrCodeUpdateManyWithoutChannelNestedInput
    approvers?: ChannelApproverUpdateManyWithoutChannelNestedInput
    verificationDocs?: ChannelVerificationDocumentUpdateManyWithoutChannelNestedInput
    categories?: ChannelCategoryAssignmentUpdateManyWithoutChannelNestedInput
    messageCategories?: MessageCategoryUpdateManyWithoutChannelNestedInput
  }

  export type ChannelUncheckedUpdateWithoutVisitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    searchExactOnly?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    approvalPolicy?: EnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy
    memberCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subchannels?: ChannelUncheckedUpdateManyWithoutParentNestedInput
    messages?: MessageUncheckedUpdateManyWithoutChannelNestedInput
    subscriptions?: ChannelSubscriptionUncheckedUpdateManyWithoutChannelNestedInput
    invitationLinks?: InvitationLinkUncheckedUpdateManyWithoutChannelNestedInput
    qrCodes?: QrCodeUncheckedUpdateManyWithoutChannelNestedInput
    approvers?: ChannelApproverUncheckedUpdateManyWithoutChannelNestedInput
    verificationDocs?: ChannelVerificationDocumentUncheckedUpdateManyWithoutChannelNestedInput
    categories?: ChannelCategoryAssignmentUncheckedUpdateManyWithoutChannelNestedInput
    messageCategories?: MessageCategoryUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type UserUpsertWithoutChannelVisitsInput = {
    update: XOR<UserUpdateWithoutChannelVisitsInput, UserUncheckedUpdateWithoutChannelVisitsInput>
    create: XOR<UserCreateWithoutChannelVisitsInput, UserUncheckedCreateWithoutChannelVisitsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChannelVisitsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChannelVisitsInput, UserUncheckedUpdateWithoutChannelVisitsInput>
  }

  export type UserUpdateWithoutChannelVisitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isCoordinator?: BoolFieldUpdateOperationsInput | boolean
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedChannels?: ChannelUpdateManyWithoutOwnerNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesOverrideSet?: MessageUpdateManyWithoutOverrideSetterNestedInput
    subscriptions?: ChannelSubscriptionUpdateManyWithoutUserNestedInput
    invitationLinks?: InvitationLinkUpdateManyWithoutCreatorNestedInput
    qrCodes?: QrCodeUpdateManyWithoutCreatorNestedInput
    messageDeliveries?: MessageDeliveryUpdateManyWithoutUserNestedInput
    messageApprovals?: MessageApprovalUpdateManyWithoutApproverNestedInput
    messageRevisionsEdited?: MessageRevisionUpdateManyWithoutEditorNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    messagingSettings?: UserMessagingSettingUpdateManyWithoutUserNestedInput
    approverAssignments?: ChannelApproverUpdateManyWithoutUserNestedInput
    createdCategories?: MessageCategoryUpdateManyWithoutCreatorNestedInput
    messageViews?: MessageViewUpdateManyWithoutUserNestedInput
    createdForms?: FormUpdateManyWithoutUserNestedInput
    organizedEvents?: EventUpdateManyWithoutOrganizerNestedInput
  }

  export type UserUncheckedUpdateWithoutChannelVisitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isCoordinator?: BoolFieldUpdateOperationsInput | boolean
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedChannels?: ChannelUncheckedUpdateManyWithoutOwnerNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesOverrideSet?: MessageUncheckedUpdateManyWithoutOverrideSetterNestedInput
    subscriptions?: ChannelSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invitationLinks?: InvitationLinkUncheckedUpdateManyWithoutCreatorNestedInput
    qrCodes?: QrCodeUncheckedUpdateManyWithoutCreatorNestedInput
    messageDeliveries?: MessageDeliveryUncheckedUpdateManyWithoutUserNestedInput
    messageApprovals?: MessageApprovalUncheckedUpdateManyWithoutApproverNestedInput
    messageRevisionsEdited?: MessageRevisionUncheckedUpdateManyWithoutEditorNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    messagingSettings?: UserMessagingSettingUncheckedUpdateManyWithoutUserNestedInput
    approverAssignments?: ChannelApproverUncheckedUpdateManyWithoutUserNestedInput
    createdCategories?: MessageCategoryUncheckedUpdateManyWithoutCreatorNestedInput
    messageViews?: MessageViewUncheckedUpdateManyWithoutUserNestedInput
    createdForms?: FormUncheckedUpdateManyWithoutUserNestedInput
    organizedEvents?: EventUncheckedUpdateManyWithoutOrganizerNestedInput
  }

  export type UserCreateWithoutCreatedFormsInput = {
    id?: string
    email: string
    username: string
    fullName?: string | null
    avatarUrl?: string | null
    passwordHash?: string | null
    deviceId?: string | null
    isGuest?: boolean
    phoneNumber?: string | null
    isPhoneVerified?: boolean
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    isAdmin?: boolean
    isCoordinator?: boolean
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedChannels?: ChannelCreateNestedManyWithoutOwnerInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesOverrideSet?: MessageCreateNestedManyWithoutOverrideSetterInput
    subscriptions?: ChannelSubscriptionCreateNestedManyWithoutUserInput
    invitationLinks?: InvitationLinkCreateNestedManyWithoutCreatorInput
    qrCodes?: QrCodeCreateNestedManyWithoutCreatorInput
    messageDeliveries?: MessageDeliveryCreateNestedManyWithoutUserInput
    messageApprovals?: MessageApprovalCreateNestedManyWithoutApproverInput
    messageRevisionsEdited?: MessageRevisionCreateNestedManyWithoutEditorInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    messagingSettings?: UserMessagingSettingCreateNestedManyWithoutUserInput
    approverAssignments?: ChannelApproverCreateNestedManyWithoutUserInput
    createdCategories?: MessageCategoryCreateNestedManyWithoutCreatorInput
    messageViews?: MessageViewCreateNestedManyWithoutUserInput
    channelVisits?: ChannelVisitCreateNestedManyWithoutUserInput
    organizedEvents?: EventCreateNestedManyWithoutOrganizerInput
  }

  export type UserUncheckedCreateWithoutCreatedFormsInput = {
    id?: string
    email: string
    username: string
    fullName?: string | null
    avatarUrl?: string | null
    passwordHash?: string | null
    deviceId?: string | null
    isGuest?: boolean
    phoneNumber?: string | null
    isPhoneVerified?: boolean
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    isAdmin?: boolean
    isCoordinator?: boolean
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedChannels?: ChannelUncheckedCreateNestedManyWithoutOwnerInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesOverrideSet?: MessageUncheckedCreateNestedManyWithoutOverrideSetterInput
    subscriptions?: ChannelSubscriptionUncheckedCreateNestedManyWithoutUserInput
    invitationLinks?: InvitationLinkUncheckedCreateNestedManyWithoutCreatorInput
    qrCodes?: QrCodeUncheckedCreateNestedManyWithoutCreatorInput
    messageDeliveries?: MessageDeliveryUncheckedCreateNestedManyWithoutUserInput
    messageApprovals?: MessageApprovalUncheckedCreateNestedManyWithoutApproverInput
    messageRevisionsEdited?: MessageRevisionUncheckedCreateNestedManyWithoutEditorInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    messagingSettings?: UserMessagingSettingUncheckedCreateNestedManyWithoutUserInput
    approverAssignments?: ChannelApproverUncheckedCreateNestedManyWithoutUserInput
    createdCategories?: MessageCategoryUncheckedCreateNestedManyWithoutCreatorInput
    messageViews?: MessageViewUncheckedCreateNestedManyWithoutUserInput
    channelVisits?: ChannelVisitUncheckedCreateNestedManyWithoutUserInput
    organizedEvents?: EventUncheckedCreateNestedManyWithoutOrganizerInput
  }

  export type UserCreateOrConnectWithoutCreatedFormsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedFormsInput, UserUncheckedCreateWithoutCreatedFormsInput>
  }

  export type FormFieldCreateWithoutFormInput = {
    id?: string
    type: string
    label: string
    placeholder?: string | null
    required?: boolean
    isHidden?: boolean
    options?: NullableJsonNullValueInput | InputJsonValue
    order?: number
    createdAt?: Date | string
  }

  export type FormFieldUncheckedCreateWithoutFormInput = {
    id?: string
    type: string
    label: string
    placeholder?: string | null
    required?: boolean
    isHidden?: boolean
    options?: NullableJsonNullValueInput | InputJsonValue
    order?: number
    createdAt?: Date | string
  }

  export type FormFieldCreateOrConnectWithoutFormInput = {
    where: FormFieldWhereUniqueInput
    create: XOR<FormFieldCreateWithoutFormInput, FormFieldUncheckedCreateWithoutFormInput>
  }

  export type FormFieldCreateManyFormInputEnvelope = {
    data: FormFieldCreateManyFormInput | FormFieldCreateManyFormInput[]
    skipDuplicates?: boolean
  }

  export type FormSubmissionCreateWithoutFormInput = {
    id?: string
    data: JsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    country?: string | null
    city?: string | null
    userAgent?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type FormSubmissionUncheckedCreateWithoutFormInput = {
    id?: string
    data: JsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    country?: string | null
    city?: string | null
    userAgent?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type FormSubmissionCreateOrConnectWithoutFormInput = {
    where: FormSubmissionWhereUniqueInput
    create: XOR<FormSubmissionCreateWithoutFormInput, FormSubmissionUncheckedCreateWithoutFormInput>
  }

  export type FormSubmissionCreateManyFormInputEnvelope = {
    data: FormSubmissionCreateManyFormInput | FormSubmissionCreateManyFormInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCreatedFormsInput = {
    update: XOR<UserUpdateWithoutCreatedFormsInput, UserUncheckedUpdateWithoutCreatedFormsInput>
    create: XOR<UserCreateWithoutCreatedFormsInput, UserUncheckedCreateWithoutCreatedFormsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedFormsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedFormsInput, UserUncheckedUpdateWithoutCreatedFormsInput>
  }

  export type UserUpdateWithoutCreatedFormsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isCoordinator?: BoolFieldUpdateOperationsInput | boolean
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedChannels?: ChannelUpdateManyWithoutOwnerNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesOverrideSet?: MessageUpdateManyWithoutOverrideSetterNestedInput
    subscriptions?: ChannelSubscriptionUpdateManyWithoutUserNestedInput
    invitationLinks?: InvitationLinkUpdateManyWithoutCreatorNestedInput
    qrCodes?: QrCodeUpdateManyWithoutCreatorNestedInput
    messageDeliveries?: MessageDeliveryUpdateManyWithoutUserNestedInput
    messageApprovals?: MessageApprovalUpdateManyWithoutApproverNestedInput
    messageRevisionsEdited?: MessageRevisionUpdateManyWithoutEditorNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    messagingSettings?: UserMessagingSettingUpdateManyWithoutUserNestedInput
    approverAssignments?: ChannelApproverUpdateManyWithoutUserNestedInput
    createdCategories?: MessageCategoryUpdateManyWithoutCreatorNestedInput
    messageViews?: MessageViewUpdateManyWithoutUserNestedInput
    channelVisits?: ChannelVisitUpdateManyWithoutUserNestedInput
    organizedEvents?: EventUpdateManyWithoutOrganizerNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedFormsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isCoordinator?: BoolFieldUpdateOperationsInput | boolean
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedChannels?: ChannelUncheckedUpdateManyWithoutOwnerNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesOverrideSet?: MessageUncheckedUpdateManyWithoutOverrideSetterNestedInput
    subscriptions?: ChannelSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invitationLinks?: InvitationLinkUncheckedUpdateManyWithoutCreatorNestedInput
    qrCodes?: QrCodeUncheckedUpdateManyWithoutCreatorNestedInput
    messageDeliveries?: MessageDeliveryUncheckedUpdateManyWithoutUserNestedInput
    messageApprovals?: MessageApprovalUncheckedUpdateManyWithoutApproverNestedInput
    messageRevisionsEdited?: MessageRevisionUncheckedUpdateManyWithoutEditorNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    messagingSettings?: UserMessagingSettingUncheckedUpdateManyWithoutUserNestedInput
    approverAssignments?: ChannelApproverUncheckedUpdateManyWithoutUserNestedInput
    createdCategories?: MessageCategoryUncheckedUpdateManyWithoutCreatorNestedInput
    messageViews?: MessageViewUncheckedUpdateManyWithoutUserNestedInput
    channelVisits?: ChannelVisitUncheckedUpdateManyWithoutUserNestedInput
    organizedEvents?: EventUncheckedUpdateManyWithoutOrganizerNestedInput
  }

  export type FormFieldUpsertWithWhereUniqueWithoutFormInput = {
    where: FormFieldWhereUniqueInput
    update: XOR<FormFieldUpdateWithoutFormInput, FormFieldUncheckedUpdateWithoutFormInput>
    create: XOR<FormFieldCreateWithoutFormInput, FormFieldUncheckedCreateWithoutFormInput>
  }

  export type FormFieldUpdateWithWhereUniqueWithoutFormInput = {
    where: FormFieldWhereUniqueInput
    data: XOR<FormFieldUpdateWithoutFormInput, FormFieldUncheckedUpdateWithoutFormInput>
  }

  export type FormFieldUpdateManyWithWhereWithoutFormInput = {
    where: FormFieldScalarWhereInput
    data: XOR<FormFieldUpdateManyMutationInput, FormFieldUncheckedUpdateManyWithoutFormInput>
  }

  export type FormFieldScalarWhereInput = {
    AND?: FormFieldScalarWhereInput | FormFieldScalarWhereInput[]
    OR?: FormFieldScalarWhereInput[]
    NOT?: FormFieldScalarWhereInput | FormFieldScalarWhereInput[]
    id?: StringFilter<"FormField"> | string
    formId?: StringFilter<"FormField"> | string
    type?: StringFilter<"FormField"> | string
    label?: StringFilter<"FormField"> | string
    placeholder?: StringNullableFilter<"FormField"> | string | null
    required?: BoolFilter<"FormField"> | boolean
    isHidden?: BoolFilter<"FormField"> | boolean
    options?: JsonNullableFilter<"FormField">
    order?: IntFilter<"FormField"> | number
    createdAt?: DateTimeFilter<"FormField"> | Date | string
  }

  export type FormSubmissionUpsertWithWhereUniqueWithoutFormInput = {
    where: FormSubmissionWhereUniqueInput
    update: XOR<FormSubmissionUpdateWithoutFormInput, FormSubmissionUncheckedUpdateWithoutFormInput>
    create: XOR<FormSubmissionCreateWithoutFormInput, FormSubmissionUncheckedCreateWithoutFormInput>
  }

  export type FormSubmissionUpdateWithWhereUniqueWithoutFormInput = {
    where: FormSubmissionWhereUniqueInput
    data: XOR<FormSubmissionUpdateWithoutFormInput, FormSubmissionUncheckedUpdateWithoutFormInput>
  }

  export type FormSubmissionUpdateManyWithWhereWithoutFormInput = {
    where: FormSubmissionScalarWhereInput
    data: XOR<FormSubmissionUpdateManyMutationInput, FormSubmissionUncheckedUpdateManyWithoutFormInput>
  }

  export type FormSubmissionScalarWhereInput = {
    AND?: FormSubmissionScalarWhereInput | FormSubmissionScalarWhereInput[]
    OR?: FormSubmissionScalarWhereInput[]
    NOT?: FormSubmissionScalarWhereInput | FormSubmissionScalarWhereInput[]
    id?: StringFilter<"FormSubmission"> | string
    formId?: StringFilter<"FormSubmission"> | string
    data?: JsonFilter<"FormSubmission">
    ipAddress?: StringNullableFilter<"FormSubmission"> | string | null
    country?: StringNullableFilter<"FormSubmission"> | string | null
    city?: StringNullableFilter<"FormSubmission"> | string | null
    userAgent?: StringNullableFilter<"FormSubmission"> | string | null
    deviceInfo?: JsonNullableFilter<"FormSubmission">
    createdAt?: DateTimeFilter<"FormSubmission"> | Date | string
  }

  export type FormCreateWithoutFieldsInput = {
    id?: string
    title: string
    description?: string | null
    slug: string
    headerContent?: string | null
    footerContent?: string | null
    successMessage?: string | null
    isActive?: boolean
    isPublished?: boolean
    wasPublished?: boolean
    isDeleted?: boolean
    collectUserInfo?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCreatedFormsInput
    submissions?: FormSubmissionCreateNestedManyWithoutFormInput
  }

  export type FormUncheckedCreateWithoutFieldsInput = {
    id?: string
    title: string
    description?: string | null
    slug: string
    headerContent?: string | null
    footerContent?: string | null
    successMessage?: string | null
    isActive?: boolean
    isPublished?: boolean
    wasPublished?: boolean
    isDeleted?: boolean
    collectUserInfo?: boolean
    expiresAt?: Date | string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    submissions?: FormSubmissionUncheckedCreateNestedManyWithoutFormInput
  }

  export type FormCreateOrConnectWithoutFieldsInput = {
    where: FormWhereUniqueInput
    create: XOR<FormCreateWithoutFieldsInput, FormUncheckedCreateWithoutFieldsInput>
  }

  export type FormUpsertWithoutFieldsInput = {
    update: XOR<FormUpdateWithoutFieldsInput, FormUncheckedUpdateWithoutFieldsInput>
    create: XOR<FormCreateWithoutFieldsInput, FormUncheckedCreateWithoutFieldsInput>
    where?: FormWhereInput
  }

  export type FormUpdateToOneWithWhereWithoutFieldsInput = {
    where?: FormWhereInput
    data: XOR<FormUpdateWithoutFieldsInput, FormUncheckedUpdateWithoutFieldsInput>
  }

  export type FormUpdateWithoutFieldsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    headerContent?: NullableStringFieldUpdateOperationsInput | string | null
    footerContent?: NullableStringFieldUpdateOperationsInput | string | null
    successMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    wasPublished?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    collectUserInfo?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCreatedFormsNestedInput
    submissions?: FormSubmissionUpdateManyWithoutFormNestedInput
  }

  export type FormUncheckedUpdateWithoutFieldsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    headerContent?: NullableStringFieldUpdateOperationsInput | string | null
    footerContent?: NullableStringFieldUpdateOperationsInput | string | null
    successMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    wasPublished?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    collectUserInfo?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submissions?: FormSubmissionUncheckedUpdateManyWithoutFormNestedInput
  }

  export type FormCreateWithoutSubmissionsInput = {
    id?: string
    title: string
    description?: string | null
    slug: string
    headerContent?: string | null
    footerContent?: string | null
    successMessage?: string | null
    isActive?: boolean
    isPublished?: boolean
    wasPublished?: boolean
    isDeleted?: boolean
    collectUserInfo?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCreatedFormsInput
    fields?: FormFieldCreateNestedManyWithoutFormInput
  }

  export type FormUncheckedCreateWithoutSubmissionsInput = {
    id?: string
    title: string
    description?: string | null
    slug: string
    headerContent?: string | null
    footerContent?: string | null
    successMessage?: string | null
    isActive?: boolean
    isPublished?: boolean
    wasPublished?: boolean
    isDeleted?: boolean
    collectUserInfo?: boolean
    expiresAt?: Date | string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fields?: FormFieldUncheckedCreateNestedManyWithoutFormInput
  }

  export type FormCreateOrConnectWithoutSubmissionsInput = {
    where: FormWhereUniqueInput
    create: XOR<FormCreateWithoutSubmissionsInput, FormUncheckedCreateWithoutSubmissionsInput>
  }

  export type FormUpsertWithoutSubmissionsInput = {
    update: XOR<FormUpdateWithoutSubmissionsInput, FormUncheckedUpdateWithoutSubmissionsInput>
    create: XOR<FormCreateWithoutSubmissionsInput, FormUncheckedCreateWithoutSubmissionsInput>
    where?: FormWhereInput
  }

  export type FormUpdateToOneWithWhereWithoutSubmissionsInput = {
    where?: FormWhereInput
    data: XOR<FormUpdateWithoutSubmissionsInput, FormUncheckedUpdateWithoutSubmissionsInput>
  }

  export type FormUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    headerContent?: NullableStringFieldUpdateOperationsInput | string | null
    footerContent?: NullableStringFieldUpdateOperationsInput | string | null
    successMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    wasPublished?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    collectUserInfo?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCreatedFormsNestedInput
    fields?: FormFieldUpdateManyWithoutFormNestedInput
  }

  export type FormUncheckedUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    headerContent?: NullableStringFieldUpdateOperationsInput | string | null
    footerContent?: NullableStringFieldUpdateOperationsInput | string | null
    successMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    wasPublished?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    collectUserInfo?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fields?: FormFieldUncheckedUpdateManyWithoutFormNestedInput
  }

  export type UserCreateWithoutOrganizedEventsInput = {
    id?: string
    email: string
    username: string
    fullName?: string | null
    avatarUrl?: string | null
    passwordHash?: string | null
    deviceId?: string | null
    isGuest?: boolean
    phoneNumber?: string | null
    isPhoneVerified?: boolean
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    isAdmin?: boolean
    isCoordinator?: boolean
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedChannels?: ChannelCreateNestedManyWithoutOwnerInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesOverrideSet?: MessageCreateNestedManyWithoutOverrideSetterInput
    subscriptions?: ChannelSubscriptionCreateNestedManyWithoutUserInput
    invitationLinks?: InvitationLinkCreateNestedManyWithoutCreatorInput
    qrCodes?: QrCodeCreateNestedManyWithoutCreatorInput
    messageDeliveries?: MessageDeliveryCreateNestedManyWithoutUserInput
    messageApprovals?: MessageApprovalCreateNestedManyWithoutApproverInput
    messageRevisionsEdited?: MessageRevisionCreateNestedManyWithoutEditorInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    messagingSettings?: UserMessagingSettingCreateNestedManyWithoutUserInput
    approverAssignments?: ChannelApproverCreateNestedManyWithoutUserInput
    createdCategories?: MessageCategoryCreateNestedManyWithoutCreatorInput
    messageViews?: MessageViewCreateNestedManyWithoutUserInput
    channelVisits?: ChannelVisitCreateNestedManyWithoutUserInput
    createdForms?: FormCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrganizedEventsInput = {
    id?: string
    email: string
    username: string
    fullName?: string | null
    avatarUrl?: string | null
    passwordHash?: string | null
    deviceId?: string | null
    isGuest?: boolean
    phoneNumber?: string | null
    isPhoneVerified?: boolean
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    isAdmin?: boolean
    isCoordinator?: boolean
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedChannels?: ChannelUncheckedCreateNestedManyWithoutOwnerInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesOverrideSet?: MessageUncheckedCreateNestedManyWithoutOverrideSetterInput
    subscriptions?: ChannelSubscriptionUncheckedCreateNestedManyWithoutUserInput
    invitationLinks?: InvitationLinkUncheckedCreateNestedManyWithoutCreatorInput
    qrCodes?: QrCodeUncheckedCreateNestedManyWithoutCreatorInput
    messageDeliveries?: MessageDeliveryUncheckedCreateNestedManyWithoutUserInput
    messageApprovals?: MessageApprovalUncheckedCreateNestedManyWithoutApproverInput
    messageRevisionsEdited?: MessageRevisionUncheckedCreateNestedManyWithoutEditorInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    messagingSettings?: UserMessagingSettingUncheckedCreateNestedManyWithoutUserInput
    approverAssignments?: ChannelApproverUncheckedCreateNestedManyWithoutUserInput
    createdCategories?: MessageCategoryUncheckedCreateNestedManyWithoutCreatorInput
    messageViews?: MessageViewUncheckedCreateNestedManyWithoutUserInput
    channelVisits?: ChannelVisitUncheckedCreateNestedManyWithoutUserInput
    createdForms?: FormUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrganizedEventsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrganizedEventsInput, UserUncheckedCreateWithoutOrganizedEventsInput>
  }

  export type EventZoneCreateWithoutEventInput = {
    id?: string
    name: string
    color: string
    price: number
    rows: number
    cols: number
    capacity?: number | null
    type?: $Enums.ZoneType
    layout?: NullableJsonNullValueInput | InputJsonValue
    seatGap?: number | null
    startNumber?: number
    numberingDirection?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    seats?: EventSeatCreateNestedManyWithoutZoneInput
    tickets?: TicketCreateNestedManyWithoutZoneInput
  }

  export type EventZoneUncheckedCreateWithoutEventInput = {
    id?: string
    name: string
    color: string
    price: number
    rows: number
    cols: number
    capacity?: number | null
    type?: $Enums.ZoneType
    layout?: NullableJsonNullValueInput | InputJsonValue
    seatGap?: number | null
    startNumber?: number
    numberingDirection?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    seats?: EventSeatUncheckedCreateNestedManyWithoutZoneInput
    tickets?: TicketUncheckedCreateNestedManyWithoutZoneInput
  }

  export type EventZoneCreateOrConnectWithoutEventInput = {
    where: EventZoneWhereUniqueInput
    create: XOR<EventZoneCreateWithoutEventInput, EventZoneUncheckedCreateWithoutEventInput>
  }

  export type EventZoneCreateManyEventInputEnvelope = {
    data: EventZoneCreateManyEventInput | EventZoneCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type EventSeatCreateWithoutEventInput = {
    id?: string
    rowLabel: string
    colLabel: string
    status?: $Enums.SeatStatus
    type?: $Enums.SeatType
    price?: number | null
    x?: number | null
    y?: number | null
    holderName?: string | null
    ticketCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    zone: EventZoneCreateNestedOneWithoutSeatsInput
    tickets?: TicketCreateNestedManyWithoutSeatInput
  }

  export type EventSeatUncheckedCreateWithoutEventInput = {
    id?: string
    zoneId: string
    rowLabel: string
    colLabel: string
    status?: $Enums.SeatStatus
    type?: $Enums.SeatType
    price?: number | null
    x?: number | null
    y?: number | null
    holderName?: string | null
    ticketCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: TicketUncheckedCreateNestedManyWithoutSeatInput
  }

  export type EventSeatCreateOrConnectWithoutEventInput = {
    where: EventSeatWhereUniqueInput
    create: XOR<EventSeatCreateWithoutEventInput, EventSeatUncheckedCreateWithoutEventInput>
  }

  export type EventSeatCreateManyEventInputEnvelope = {
    data: EventSeatCreateManyEventInput | EventSeatCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type TicketCreateWithoutEventInput = {
    id?: string
    customerName: string
    customerEmail: string
    price: number
    status?: $Enums.TicketStatus
    purchaseDate?: Date | string
    qrCode?: string | null
    zone: EventZoneCreateNestedOneWithoutTicketsInput
    seat?: EventSeatCreateNestedOneWithoutTicketsInput
  }

  export type TicketUncheckedCreateWithoutEventInput = {
    id?: string
    zoneId: string
    seatId?: string | null
    customerName: string
    customerEmail: string
    price: number
    status?: $Enums.TicketStatus
    purchaseDate?: Date | string
    qrCode?: string | null
  }

  export type TicketCreateOrConnectWithoutEventInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutEventInput, TicketUncheckedCreateWithoutEventInput>
  }

  export type TicketCreateManyEventInputEnvelope = {
    data: TicketCreateManyEventInput | TicketCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutOrganizedEventsInput = {
    update: XOR<UserUpdateWithoutOrganizedEventsInput, UserUncheckedUpdateWithoutOrganizedEventsInput>
    create: XOR<UserCreateWithoutOrganizedEventsInput, UserUncheckedCreateWithoutOrganizedEventsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrganizedEventsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrganizedEventsInput, UserUncheckedUpdateWithoutOrganizedEventsInput>
  }

  export type UserUpdateWithoutOrganizedEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isCoordinator?: BoolFieldUpdateOperationsInput | boolean
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedChannels?: ChannelUpdateManyWithoutOwnerNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesOverrideSet?: MessageUpdateManyWithoutOverrideSetterNestedInput
    subscriptions?: ChannelSubscriptionUpdateManyWithoutUserNestedInput
    invitationLinks?: InvitationLinkUpdateManyWithoutCreatorNestedInput
    qrCodes?: QrCodeUpdateManyWithoutCreatorNestedInput
    messageDeliveries?: MessageDeliveryUpdateManyWithoutUserNestedInput
    messageApprovals?: MessageApprovalUpdateManyWithoutApproverNestedInput
    messageRevisionsEdited?: MessageRevisionUpdateManyWithoutEditorNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    messagingSettings?: UserMessagingSettingUpdateManyWithoutUserNestedInput
    approverAssignments?: ChannelApproverUpdateManyWithoutUserNestedInput
    createdCategories?: MessageCategoryUpdateManyWithoutCreatorNestedInput
    messageViews?: MessageViewUpdateManyWithoutUserNestedInput
    channelVisits?: ChannelVisitUpdateManyWithoutUserNestedInput
    createdForms?: FormUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrganizedEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isCoordinator?: BoolFieldUpdateOperationsInput | boolean
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedChannels?: ChannelUncheckedUpdateManyWithoutOwnerNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesOverrideSet?: MessageUncheckedUpdateManyWithoutOverrideSetterNestedInput
    subscriptions?: ChannelSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invitationLinks?: InvitationLinkUncheckedUpdateManyWithoutCreatorNestedInput
    qrCodes?: QrCodeUncheckedUpdateManyWithoutCreatorNestedInput
    messageDeliveries?: MessageDeliveryUncheckedUpdateManyWithoutUserNestedInput
    messageApprovals?: MessageApprovalUncheckedUpdateManyWithoutApproverNestedInput
    messageRevisionsEdited?: MessageRevisionUncheckedUpdateManyWithoutEditorNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    messagingSettings?: UserMessagingSettingUncheckedUpdateManyWithoutUserNestedInput
    approverAssignments?: ChannelApproverUncheckedUpdateManyWithoutUserNestedInput
    createdCategories?: MessageCategoryUncheckedUpdateManyWithoutCreatorNestedInput
    messageViews?: MessageViewUncheckedUpdateManyWithoutUserNestedInput
    channelVisits?: ChannelVisitUncheckedUpdateManyWithoutUserNestedInput
    createdForms?: FormUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EventZoneUpsertWithWhereUniqueWithoutEventInput = {
    where: EventZoneWhereUniqueInput
    update: XOR<EventZoneUpdateWithoutEventInput, EventZoneUncheckedUpdateWithoutEventInput>
    create: XOR<EventZoneCreateWithoutEventInput, EventZoneUncheckedCreateWithoutEventInput>
  }

  export type EventZoneUpdateWithWhereUniqueWithoutEventInput = {
    where: EventZoneWhereUniqueInput
    data: XOR<EventZoneUpdateWithoutEventInput, EventZoneUncheckedUpdateWithoutEventInput>
  }

  export type EventZoneUpdateManyWithWhereWithoutEventInput = {
    where: EventZoneScalarWhereInput
    data: XOR<EventZoneUpdateManyMutationInput, EventZoneUncheckedUpdateManyWithoutEventInput>
  }

  export type EventZoneScalarWhereInput = {
    AND?: EventZoneScalarWhereInput | EventZoneScalarWhereInput[]
    OR?: EventZoneScalarWhereInput[]
    NOT?: EventZoneScalarWhereInput | EventZoneScalarWhereInput[]
    id?: StringFilter<"EventZone"> | string
    eventId?: StringFilter<"EventZone"> | string
    name?: StringFilter<"EventZone"> | string
    color?: StringFilter<"EventZone"> | string
    price?: FloatFilter<"EventZone"> | number
    rows?: IntFilter<"EventZone"> | number
    cols?: IntFilter<"EventZone"> | number
    capacity?: IntNullableFilter<"EventZone"> | number | null
    type?: EnumZoneTypeFilter<"EventZone"> | $Enums.ZoneType
    layout?: JsonNullableFilter<"EventZone">
    seatGap?: IntNullableFilter<"EventZone"> | number | null
    startNumber?: IntFilter<"EventZone"> | number
    numberingDirection?: StringFilter<"EventZone"> | string
    createdAt?: DateTimeFilter<"EventZone"> | Date | string
    updatedAt?: DateTimeFilter<"EventZone"> | Date | string
  }

  export type EventSeatUpsertWithWhereUniqueWithoutEventInput = {
    where: EventSeatWhereUniqueInput
    update: XOR<EventSeatUpdateWithoutEventInput, EventSeatUncheckedUpdateWithoutEventInput>
    create: XOR<EventSeatCreateWithoutEventInput, EventSeatUncheckedCreateWithoutEventInput>
  }

  export type EventSeatUpdateWithWhereUniqueWithoutEventInput = {
    where: EventSeatWhereUniqueInput
    data: XOR<EventSeatUpdateWithoutEventInput, EventSeatUncheckedUpdateWithoutEventInput>
  }

  export type EventSeatUpdateManyWithWhereWithoutEventInput = {
    where: EventSeatScalarWhereInput
    data: XOR<EventSeatUpdateManyMutationInput, EventSeatUncheckedUpdateManyWithoutEventInput>
  }

  export type EventSeatScalarWhereInput = {
    AND?: EventSeatScalarWhereInput | EventSeatScalarWhereInput[]
    OR?: EventSeatScalarWhereInput[]
    NOT?: EventSeatScalarWhereInput | EventSeatScalarWhereInput[]
    id?: StringFilter<"EventSeat"> | string
    eventId?: StringFilter<"EventSeat"> | string
    zoneId?: StringFilter<"EventSeat"> | string
    rowLabel?: StringFilter<"EventSeat"> | string
    colLabel?: StringFilter<"EventSeat"> | string
    status?: EnumSeatStatusFilter<"EventSeat"> | $Enums.SeatStatus
    type?: EnumSeatTypeFilter<"EventSeat"> | $Enums.SeatType
    price?: FloatNullableFilter<"EventSeat"> | number | null
    x?: IntNullableFilter<"EventSeat"> | number | null
    y?: IntNullableFilter<"EventSeat"> | number | null
    holderName?: StringNullableFilter<"EventSeat"> | string | null
    ticketCode?: StringNullableFilter<"EventSeat"> | string | null
    createdAt?: DateTimeFilter<"EventSeat"> | Date | string
    updatedAt?: DateTimeFilter<"EventSeat"> | Date | string
  }

  export type TicketUpsertWithWhereUniqueWithoutEventInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutEventInput, TicketUncheckedUpdateWithoutEventInput>
    create: XOR<TicketCreateWithoutEventInput, TicketUncheckedCreateWithoutEventInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutEventInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutEventInput, TicketUncheckedUpdateWithoutEventInput>
  }

  export type TicketUpdateManyWithWhereWithoutEventInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutEventInput>
  }

  export type TicketScalarWhereInput = {
    AND?: TicketScalarWhereInput | TicketScalarWhereInput[]
    OR?: TicketScalarWhereInput[]
    NOT?: TicketScalarWhereInput | TicketScalarWhereInput[]
    id?: StringFilter<"Ticket"> | string
    eventId?: StringFilter<"Ticket"> | string
    zoneId?: StringFilter<"Ticket"> | string
    seatId?: StringNullableFilter<"Ticket"> | string | null
    customerName?: StringFilter<"Ticket"> | string
    customerEmail?: StringFilter<"Ticket"> | string
    price?: FloatFilter<"Ticket"> | number
    status?: EnumTicketStatusFilter<"Ticket"> | $Enums.TicketStatus
    purchaseDate?: DateTimeFilter<"Ticket"> | Date | string
    qrCode?: StringNullableFilter<"Ticket"> | string | null
  }

  export type EventCreateWithoutZonesInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    location: string
    imageUrl?: string | null
    status?: $Enums.EventStatus
    categories?: NullableJsonNullValueInput | InputJsonValue
    paymentInfo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organizer: UserCreateNestedOneWithoutOrganizedEventsInput
    seats?: EventSeatCreateNestedManyWithoutEventInput
    tickets?: TicketCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutZonesInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    location: string
    imageUrl?: string | null
    status?: $Enums.EventStatus
    categories?: NullableJsonNullValueInput | InputJsonValue
    paymentInfo?: string | null
    organizerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    seats?: EventSeatUncheckedCreateNestedManyWithoutEventInput
    tickets?: TicketUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutZonesInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutZonesInput, EventUncheckedCreateWithoutZonesInput>
  }

  export type EventSeatCreateWithoutZoneInput = {
    id?: string
    rowLabel: string
    colLabel: string
    status?: $Enums.SeatStatus
    type?: $Enums.SeatType
    price?: number | null
    x?: number | null
    y?: number | null
    holderName?: string | null
    ticketCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    event: EventCreateNestedOneWithoutSeatsInput
    tickets?: TicketCreateNestedManyWithoutSeatInput
  }

  export type EventSeatUncheckedCreateWithoutZoneInput = {
    id?: string
    eventId: string
    rowLabel: string
    colLabel: string
    status?: $Enums.SeatStatus
    type?: $Enums.SeatType
    price?: number | null
    x?: number | null
    y?: number | null
    holderName?: string | null
    ticketCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: TicketUncheckedCreateNestedManyWithoutSeatInput
  }

  export type EventSeatCreateOrConnectWithoutZoneInput = {
    where: EventSeatWhereUniqueInput
    create: XOR<EventSeatCreateWithoutZoneInput, EventSeatUncheckedCreateWithoutZoneInput>
  }

  export type EventSeatCreateManyZoneInputEnvelope = {
    data: EventSeatCreateManyZoneInput | EventSeatCreateManyZoneInput[]
    skipDuplicates?: boolean
  }

  export type TicketCreateWithoutZoneInput = {
    id?: string
    customerName: string
    customerEmail: string
    price: number
    status?: $Enums.TicketStatus
    purchaseDate?: Date | string
    qrCode?: string | null
    event: EventCreateNestedOneWithoutTicketsInput
    seat?: EventSeatCreateNestedOneWithoutTicketsInput
  }

  export type TicketUncheckedCreateWithoutZoneInput = {
    id?: string
    eventId: string
    seatId?: string | null
    customerName: string
    customerEmail: string
    price: number
    status?: $Enums.TicketStatus
    purchaseDate?: Date | string
    qrCode?: string | null
  }

  export type TicketCreateOrConnectWithoutZoneInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutZoneInput, TicketUncheckedCreateWithoutZoneInput>
  }

  export type TicketCreateManyZoneInputEnvelope = {
    data: TicketCreateManyZoneInput | TicketCreateManyZoneInput[]
    skipDuplicates?: boolean
  }

  export type EventUpsertWithoutZonesInput = {
    update: XOR<EventUpdateWithoutZonesInput, EventUncheckedUpdateWithoutZonesInput>
    create: XOR<EventCreateWithoutZonesInput, EventUncheckedCreateWithoutZonesInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutZonesInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutZonesInput, EventUncheckedUpdateWithoutZonesInput>
  }

  export type EventUpdateWithoutZonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    categories?: NullableJsonNullValueInput | InputJsonValue
    paymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizer?: UserUpdateOneRequiredWithoutOrganizedEventsNestedInput
    seats?: EventSeatUpdateManyWithoutEventNestedInput
    tickets?: TicketUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutZonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    categories?: NullableJsonNullValueInput | InputJsonValue
    paymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    organizerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seats?: EventSeatUncheckedUpdateManyWithoutEventNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventSeatUpsertWithWhereUniqueWithoutZoneInput = {
    where: EventSeatWhereUniqueInput
    update: XOR<EventSeatUpdateWithoutZoneInput, EventSeatUncheckedUpdateWithoutZoneInput>
    create: XOR<EventSeatCreateWithoutZoneInput, EventSeatUncheckedCreateWithoutZoneInput>
  }

  export type EventSeatUpdateWithWhereUniqueWithoutZoneInput = {
    where: EventSeatWhereUniqueInput
    data: XOR<EventSeatUpdateWithoutZoneInput, EventSeatUncheckedUpdateWithoutZoneInput>
  }

  export type EventSeatUpdateManyWithWhereWithoutZoneInput = {
    where: EventSeatScalarWhereInput
    data: XOR<EventSeatUpdateManyMutationInput, EventSeatUncheckedUpdateManyWithoutZoneInput>
  }

  export type TicketUpsertWithWhereUniqueWithoutZoneInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutZoneInput, TicketUncheckedUpdateWithoutZoneInput>
    create: XOR<TicketCreateWithoutZoneInput, TicketUncheckedCreateWithoutZoneInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutZoneInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutZoneInput, TicketUncheckedUpdateWithoutZoneInput>
  }

  export type TicketUpdateManyWithWhereWithoutZoneInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutZoneInput>
  }

  export type EventCreateWithoutSeatsInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    location: string
    imageUrl?: string | null
    status?: $Enums.EventStatus
    categories?: NullableJsonNullValueInput | InputJsonValue
    paymentInfo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organizer: UserCreateNestedOneWithoutOrganizedEventsInput
    zones?: EventZoneCreateNestedManyWithoutEventInput
    tickets?: TicketCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutSeatsInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    location: string
    imageUrl?: string | null
    status?: $Enums.EventStatus
    categories?: NullableJsonNullValueInput | InputJsonValue
    paymentInfo?: string | null
    organizerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    zones?: EventZoneUncheckedCreateNestedManyWithoutEventInput
    tickets?: TicketUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutSeatsInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutSeatsInput, EventUncheckedCreateWithoutSeatsInput>
  }

  export type EventZoneCreateWithoutSeatsInput = {
    id?: string
    name: string
    color: string
    price: number
    rows: number
    cols: number
    capacity?: number | null
    type?: $Enums.ZoneType
    layout?: NullableJsonNullValueInput | InputJsonValue
    seatGap?: number | null
    startNumber?: number
    numberingDirection?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    event: EventCreateNestedOneWithoutZonesInput
    tickets?: TicketCreateNestedManyWithoutZoneInput
  }

  export type EventZoneUncheckedCreateWithoutSeatsInput = {
    id?: string
    eventId: string
    name: string
    color: string
    price: number
    rows: number
    cols: number
    capacity?: number | null
    type?: $Enums.ZoneType
    layout?: NullableJsonNullValueInput | InputJsonValue
    seatGap?: number | null
    startNumber?: number
    numberingDirection?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: TicketUncheckedCreateNestedManyWithoutZoneInput
  }

  export type EventZoneCreateOrConnectWithoutSeatsInput = {
    where: EventZoneWhereUniqueInput
    create: XOR<EventZoneCreateWithoutSeatsInput, EventZoneUncheckedCreateWithoutSeatsInput>
  }

  export type TicketCreateWithoutSeatInput = {
    id?: string
    customerName: string
    customerEmail: string
    price: number
    status?: $Enums.TicketStatus
    purchaseDate?: Date | string
    qrCode?: string | null
    event: EventCreateNestedOneWithoutTicketsInput
    zone: EventZoneCreateNestedOneWithoutTicketsInput
  }

  export type TicketUncheckedCreateWithoutSeatInput = {
    id?: string
    eventId: string
    zoneId: string
    customerName: string
    customerEmail: string
    price: number
    status?: $Enums.TicketStatus
    purchaseDate?: Date | string
    qrCode?: string | null
  }

  export type TicketCreateOrConnectWithoutSeatInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutSeatInput, TicketUncheckedCreateWithoutSeatInput>
  }

  export type TicketCreateManySeatInputEnvelope = {
    data: TicketCreateManySeatInput | TicketCreateManySeatInput[]
    skipDuplicates?: boolean
  }

  export type EventUpsertWithoutSeatsInput = {
    update: XOR<EventUpdateWithoutSeatsInput, EventUncheckedUpdateWithoutSeatsInput>
    create: XOR<EventCreateWithoutSeatsInput, EventUncheckedCreateWithoutSeatsInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutSeatsInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutSeatsInput, EventUncheckedUpdateWithoutSeatsInput>
  }

  export type EventUpdateWithoutSeatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    categories?: NullableJsonNullValueInput | InputJsonValue
    paymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizer?: UserUpdateOneRequiredWithoutOrganizedEventsNestedInput
    zones?: EventZoneUpdateManyWithoutEventNestedInput
    tickets?: TicketUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutSeatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    categories?: NullableJsonNullValueInput | InputJsonValue
    paymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    organizerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zones?: EventZoneUncheckedUpdateManyWithoutEventNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventZoneUpsertWithoutSeatsInput = {
    update: XOR<EventZoneUpdateWithoutSeatsInput, EventZoneUncheckedUpdateWithoutSeatsInput>
    create: XOR<EventZoneCreateWithoutSeatsInput, EventZoneUncheckedCreateWithoutSeatsInput>
    where?: EventZoneWhereInput
  }

  export type EventZoneUpdateToOneWithWhereWithoutSeatsInput = {
    where?: EventZoneWhereInput
    data: XOR<EventZoneUpdateWithoutSeatsInput, EventZoneUncheckedUpdateWithoutSeatsInput>
  }

  export type EventZoneUpdateWithoutSeatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    rows?: IntFieldUpdateOperationsInput | number
    cols?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumZoneTypeFieldUpdateOperationsInput | $Enums.ZoneType
    layout?: NullableJsonNullValueInput | InputJsonValue
    seatGap?: NullableIntFieldUpdateOperationsInput | number | null
    startNumber?: IntFieldUpdateOperationsInput | number
    numberingDirection?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutZonesNestedInput
    tickets?: TicketUpdateManyWithoutZoneNestedInput
  }

  export type EventZoneUncheckedUpdateWithoutSeatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    rows?: IntFieldUpdateOperationsInput | number
    cols?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumZoneTypeFieldUpdateOperationsInput | $Enums.ZoneType
    layout?: NullableJsonNullValueInput | InputJsonValue
    seatGap?: NullableIntFieldUpdateOperationsInput | number | null
    startNumber?: IntFieldUpdateOperationsInput | number
    numberingDirection?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type TicketUpsertWithWhereUniqueWithoutSeatInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutSeatInput, TicketUncheckedUpdateWithoutSeatInput>
    create: XOR<TicketCreateWithoutSeatInput, TicketUncheckedCreateWithoutSeatInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutSeatInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutSeatInput, TicketUncheckedUpdateWithoutSeatInput>
  }

  export type TicketUpdateManyWithWhereWithoutSeatInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutSeatInput>
  }

  export type EventCreateWithoutTicketsInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    location: string
    imageUrl?: string | null
    status?: $Enums.EventStatus
    categories?: NullableJsonNullValueInput | InputJsonValue
    paymentInfo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organizer: UserCreateNestedOneWithoutOrganizedEventsInput
    zones?: EventZoneCreateNestedManyWithoutEventInput
    seats?: EventSeatCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutTicketsInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    location: string
    imageUrl?: string | null
    status?: $Enums.EventStatus
    categories?: NullableJsonNullValueInput | InputJsonValue
    paymentInfo?: string | null
    organizerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    zones?: EventZoneUncheckedCreateNestedManyWithoutEventInput
    seats?: EventSeatUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutTicketsInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutTicketsInput, EventUncheckedCreateWithoutTicketsInput>
  }

  export type EventZoneCreateWithoutTicketsInput = {
    id?: string
    name: string
    color: string
    price: number
    rows: number
    cols: number
    capacity?: number | null
    type?: $Enums.ZoneType
    layout?: NullableJsonNullValueInput | InputJsonValue
    seatGap?: number | null
    startNumber?: number
    numberingDirection?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    event: EventCreateNestedOneWithoutZonesInput
    seats?: EventSeatCreateNestedManyWithoutZoneInput
  }

  export type EventZoneUncheckedCreateWithoutTicketsInput = {
    id?: string
    eventId: string
    name: string
    color: string
    price: number
    rows: number
    cols: number
    capacity?: number | null
    type?: $Enums.ZoneType
    layout?: NullableJsonNullValueInput | InputJsonValue
    seatGap?: number | null
    startNumber?: number
    numberingDirection?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    seats?: EventSeatUncheckedCreateNestedManyWithoutZoneInput
  }

  export type EventZoneCreateOrConnectWithoutTicketsInput = {
    where: EventZoneWhereUniqueInput
    create: XOR<EventZoneCreateWithoutTicketsInput, EventZoneUncheckedCreateWithoutTicketsInput>
  }

  export type EventSeatCreateWithoutTicketsInput = {
    id?: string
    rowLabel: string
    colLabel: string
    status?: $Enums.SeatStatus
    type?: $Enums.SeatType
    price?: number | null
    x?: number | null
    y?: number | null
    holderName?: string | null
    ticketCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    event: EventCreateNestedOneWithoutSeatsInput
    zone: EventZoneCreateNestedOneWithoutSeatsInput
  }

  export type EventSeatUncheckedCreateWithoutTicketsInput = {
    id?: string
    eventId: string
    zoneId: string
    rowLabel: string
    colLabel: string
    status?: $Enums.SeatStatus
    type?: $Enums.SeatType
    price?: number | null
    x?: number | null
    y?: number | null
    holderName?: string | null
    ticketCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventSeatCreateOrConnectWithoutTicketsInput = {
    where: EventSeatWhereUniqueInput
    create: XOR<EventSeatCreateWithoutTicketsInput, EventSeatUncheckedCreateWithoutTicketsInput>
  }

  export type EventUpsertWithoutTicketsInput = {
    update: XOR<EventUpdateWithoutTicketsInput, EventUncheckedUpdateWithoutTicketsInput>
    create: XOR<EventCreateWithoutTicketsInput, EventUncheckedCreateWithoutTicketsInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutTicketsInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutTicketsInput, EventUncheckedUpdateWithoutTicketsInput>
  }

  export type EventUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    categories?: NullableJsonNullValueInput | InputJsonValue
    paymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizer?: UserUpdateOneRequiredWithoutOrganizedEventsNestedInput
    zones?: EventZoneUpdateManyWithoutEventNestedInput
    seats?: EventSeatUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    categories?: NullableJsonNullValueInput | InputJsonValue
    paymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    organizerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zones?: EventZoneUncheckedUpdateManyWithoutEventNestedInput
    seats?: EventSeatUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventZoneUpsertWithoutTicketsInput = {
    update: XOR<EventZoneUpdateWithoutTicketsInput, EventZoneUncheckedUpdateWithoutTicketsInput>
    create: XOR<EventZoneCreateWithoutTicketsInput, EventZoneUncheckedCreateWithoutTicketsInput>
    where?: EventZoneWhereInput
  }

  export type EventZoneUpdateToOneWithWhereWithoutTicketsInput = {
    where?: EventZoneWhereInput
    data: XOR<EventZoneUpdateWithoutTicketsInput, EventZoneUncheckedUpdateWithoutTicketsInput>
  }

  export type EventZoneUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    rows?: IntFieldUpdateOperationsInput | number
    cols?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumZoneTypeFieldUpdateOperationsInput | $Enums.ZoneType
    layout?: NullableJsonNullValueInput | InputJsonValue
    seatGap?: NullableIntFieldUpdateOperationsInput | number | null
    startNumber?: IntFieldUpdateOperationsInput | number
    numberingDirection?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutZonesNestedInput
    seats?: EventSeatUpdateManyWithoutZoneNestedInput
  }

  export type EventZoneUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    rows?: IntFieldUpdateOperationsInput | number
    cols?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumZoneTypeFieldUpdateOperationsInput | $Enums.ZoneType
    layout?: NullableJsonNullValueInput | InputJsonValue
    seatGap?: NullableIntFieldUpdateOperationsInput | number | null
    startNumber?: IntFieldUpdateOperationsInput | number
    numberingDirection?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seats?: EventSeatUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type EventSeatUpsertWithoutTicketsInput = {
    update: XOR<EventSeatUpdateWithoutTicketsInput, EventSeatUncheckedUpdateWithoutTicketsInput>
    create: XOR<EventSeatCreateWithoutTicketsInput, EventSeatUncheckedCreateWithoutTicketsInput>
    where?: EventSeatWhereInput
  }

  export type EventSeatUpdateToOneWithWhereWithoutTicketsInput = {
    where?: EventSeatWhereInput
    data: XOR<EventSeatUpdateWithoutTicketsInput, EventSeatUncheckedUpdateWithoutTicketsInput>
  }

  export type EventSeatUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rowLabel?: StringFieldUpdateOperationsInput | string
    colLabel?: StringFieldUpdateOperationsInput | string
    status?: EnumSeatStatusFieldUpdateOperationsInput | $Enums.SeatStatus
    type?: EnumSeatTypeFieldUpdateOperationsInput | $Enums.SeatType
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    x?: NullableIntFieldUpdateOperationsInput | number | null
    y?: NullableIntFieldUpdateOperationsInput | number | null
    holderName?: NullableStringFieldUpdateOperationsInput | string | null
    ticketCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutSeatsNestedInput
    zone?: EventZoneUpdateOneRequiredWithoutSeatsNestedInput
  }

  export type EventSeatUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    rowLabel?: StringFieldUpdateOperationsInput | string
    colLabel?: StringFieldUpdateOperationsInput | string
    status?: EnumSeatStatusFieldUpdateOperationsInput | $Enums.SeatStatus
    type?: EnumSeatTypeFieldUpdateOperationsInput | $Enums.SeatType
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    x?: NullableIntFieldUpdateOperationsInput | number | null
    y?: NullableIntFieldUpdateOperationsInput | number | null
    holderName?: NullableStringFieldUpdateOperationsInput | string | null
    ticketCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelCreateManyOwnerInput = {
    id?: string
    title: string
    description?: string | null
    websiteUrl?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: string | null
    icon?: string
    parentId?: string | null
    organizationId: string
    isPublic?: boolean
    isHidden?: boolean
    searchExactOnly?: boolean
    passwordHash?: string | null
    referenceCode?: string | null
    verificationStatus?: $Enums.VerificationStatus
    approvalPolicy?: $Enums.ApprovalPolicy
    memberCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateManySenderInput = {
    id?: string
    channelId: string
    categoryId: string
    content: string
    durationSeconds?: number
    expiresAt?: Date | string | null
    isEmergency?: boolean
    isImmediate?: boolean
    priority?: $Enums.MessagePriority
    approvalOverride?: $Enums.ApprovalPolicy | null
    approvalOverrideSetBy?: string | null
    approvalOverrideSetAt?: Date | string | null
    deliveryMethod?: $Enums.DeliveryMethod
    eventAt?: Date | string | null
    publishedAt?: Date | string | null
    state?: $Enums.MessageState
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateManyOverrideSetterInput = {
    id?: string
    channelId: string
    senderId: string
    categoryId: string
    content: string
    durationSeconds?: number
    expiresAt?: Date | string | null
    isEmergency?: boolean
    isImmediate?: boolean
    priority?: $Enums.MessagePriority
    approvalOverride?: $Enums.ApprovalPolicy | null
    approvalOverrideSetAt?: Date | string | null
    deliveryMethod?: $Enums.DeliveryMethod
    eventAt?: Date | string | null
    publishedAt?: Date | string | null
    state?: $Enums.MessageState
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChannelSubscriptionCreateManyUserInput = {
    id?: string
    channelId: string
    subscribedAt?: Date | string
    isActive?: boolean
    isFavorite?: boolean
    receiveMessages?: boolean
  }

  export type InvitationLinkCreateManyCreatorInput = {
    id?: string
    channelId: string
    linkCode: string
    expiresAt?: Date | string | null
    maxUses?: number | null
    currentUses?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type QrCodeCreateManyCreatorInput = {
    id?: string
    channelId: string
    qrData: string
    expiresAt?: Date | string | null
    scanCount?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type MessageDeliveryCreateManyUserInput = {
    id?: string
    messageId: string
    deliveryStatus?: $Enums.DeliveryStatus
    deliveryMethod?: $Enums.DeliveryMethod | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MessageApprovalCreateManyApproverInput = {
    id?: string
    messageId: string
    status?: $Enums.ApprovalStatus
    decidedAt?: Date | string | null
  }

  export type MessageRevisionCreateManyEditorInput = {
    id?: string
    messageId: string
    previousContent: string
    previousCategoryId?: string | null
    previousPriority: $Enums.MessagePriority
    previousIsImmediate: boolean
    previousDeliveryMethod: $Enums.DeliveryMethod
    changedAt?: Date | string
  }

  export type UserMessagingSettingCreateManyUserInput = {
    id?: string
    platform: $Enums.MessagingPlatform
    handle?: string | null
    isEnabled?: boolean
    verified?: boolean
    createdAt?: Date | string
  }

  export type ChannelApproverCreateManyUserInput = {
    id?: string
    channelId: string
    isActive?: boolean
    removedAt?: Date | string | null
    removedBy?: string | null
    createdAt?: Date | string
  }

  export type MessageCategoryCreateManyCreatorInput = {
    id?: string
    name: string
    scope?: $Enums.CategoryScope
    channelId?: string | null
    createdAt?: Date | string
  }

  export type MessageViewCreateManyUserInput = {
    id?: string
    messageId: string
    viewedAt?: Date | string
  }

  export type ChannelVisitCreateManyUserInput = {
    id?: string
    channelId: string
    visitedAt?: Date | string
  }

  export type FormCreateManyUserInput = {
    id?: string
    title: string
    description?: string | null
    slug: string
    headerContent?: string | null
    footerContent?: string | null
    successMessage?: string | null
    isActive?: boolean
    isPublished?: boolean
    wasPublished?: boolean
    isDeleted?: boolean
    collectUserInfo?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventCreateManyOrganizerInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    location: string
    imageUrl?: string | null
    status?: $Enums.EventStatus
    categories?: NullableJsonNullValueInput | InputJsonValue
    paymentInfo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChannelUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    searchExactOnly?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    approvalPolicy?: EnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy
    memberCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutChannelsNestedInput
    parent?: ChannelUpdateOneWithoutSubchannelsNestedInput
    subchannels?: ChannelUpdateManyWithoutParentNestedInput
    messages?: MessageUpdateManyWithoutChannelNestedInput
    subscriptions?: ChannelSubscriptionUpdateManyWithoutChannelNestedInput
    invitationLinks?: InvitationLinkUpdateManyWithoutChannelNestedInput
    qrCodes?: QrCodeUpdateManyWithoutChannelNestedInput
    approvers?: ChannelApproverUpdateManyWithoutChannelNestedInput
    verificationDocs?: ChannelVerificationDocumentUpdateManyWithoutChannelNestedInput
    categories?: ChannelCategoryAssignmentUpdateManyWithoutChannelNestedInput
    messageCategories?: MessageCategoryUpdateManyWithoutChannelNestedInput
    visits?: ChannelVisitUpdateManyWithoutChannelNestedInput
  }

  export type ChannelUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    searchExactOnly?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    approvalPolicy?: EnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy
    memberCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subchannels?: ChannelUncheckedUpdateManyWithoutParentNestedInput
    messages?: MessageUncheckedUpdateManyWithoutChannelNestedInput
    subscriptions?: ChannelSubscriptionUncheckedUpdateManyWithoutChannelNestedInput
    invitationLinks?: InvitationLinkUncheckedUpdateManyWithoutChannelNestedInput
    qrCodes?: QrCodeUncheckedUpdateManyWithoutChannelNestedInput
    approvers?: ChannelApproverUncheckedUpdateManyWithoutChannelNestedInput
    verificationDocs?: ChannelVerificationDocumentUncheckedUpdateManyWithoutChannelNestedInput
    categories?: ChannelCategoryAssignmentUncheckedUpdateManyWithoutChannelNestedInput
    messageCategories?: MessageCategoryUncheckedUpdateManyWithoutChannelNestedInput
    visits?: ChannelVisitUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type ChannelUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    searchExactOnly?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    approvalPolicy?: EnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy
    memberCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    durationSeconds?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    isImmediate?: BoolFieldUpdateOperationsInput | boolean
    priority?: EnumMessagePriorityFieldUpdateOperationsInput | $Enums.MessagePriority
    approvalOverride?: NullableEnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy | null
    approvalOverrideSetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    eventAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    state?: EnumMessageStateFieldUpdateOperationsInput | $Enums.MessageState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: ChannelUpdateOneRequiredWithoutMessagesNestedInput
    category?: MessageCategoryUpdateOneRequiredWithoutMessagesNestedInput
    overrideSetter?: UserUpdateOneWithoutMessagesOverrideSetNestedInput
    deliveries?: MessageDeliveryUpdateManyWithoutMessageNestedInput
    approvals?: MessageApprovalUpdateManyWithoutMessageNestedInput
    attachments?: MessageAttachmentUpdateManyWithoutMessageNestedInput
    revisions?: MessageRevisionUpdateManyWithoutMessageNestedInput
    views?: MessageViewUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    durationSeconds?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    isImmediate?: BoolFieldUpdateOperationsInput | boolean
    priority?: EnumMessagePriorityFieldUpdateOperationsInput | $Enums.MessagePriority
    approvalOverride?: NullableEnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy | null
    approvalOverrideSetBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvalOverrideSetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    eventAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    state?: EnumMessageStateFieldUpdateOperationsInput | $Enums.MessageState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: MessageDeliveryUncheckedUpdateManyWithoutMessageNestedInput
    approvals?: MessageApprovalUncheckedUpdateManyWithoutMessageNestedInput
    attachments?: MessageAttachmentUncheckedUpdateManyWithoutMessageNestedInput
    revisions?: MessageRevisionUncheckedUpdateManyWithoutMessageNestedInput
    views?: MessageViewUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    durationSeconds?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    isImmediate?: BoolFieldUpdateOperationsInput | boolean
    priority?: EnumMessagePriorityFieldUpdateOperationsInput | $Enums.MessagePriority
    approvalOverride?: NullableEnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy | null
    approvalOverrideSetBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvalOverrideSetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    eventAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    state?: EnumMessageStateFieldUpdateOperationsInput | $Enums.MessageState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutOverrideSetterInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    durationSeconds?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    isImmediate?: BoolFieldUpdateOperationsInput | boolean
    priority?: EnumMessagePriorityFieldUpdateOperationsInput | $Enums.MessagePriority
    approvalOverride?: NullableEnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy | null
    approvalOverrideSetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    eventAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    state?: EnumMessageStateFieldUpdateOperationsInput | $Enums.MessageState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: ChannelUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutMessagesSentNestedInput
    category?: MessageCategoryUpdateOneRequiredWithoutMessagesNestedInput
    deliveries?: MessageDeliveryUpdateManyWithoutMessageNestedInput
    approvals?: MessageApprovalUpdateManyWithoutMessageNestedInput
    attachments?: MessageAttachmentUpdateManyWithoutMessageNestedInput
    revisions?: MessageRevisionUpdateManyWithoutMessageNestedInput
    views?: MessageViewUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutOverrideSetterInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    durationSeconds?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    isImmediate?: BoolFieldUpdateOperationsInput | boolean
    priority?: EnumMessagePriorityFieldUpdateOperationsInput | $Enums.MessagePriority
    approvalOverride?: NullableEnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy | null
    approvalOverrideSetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    eventAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    state?: EnumMessageStateFieldUpdateOperationsInput | $Enums.MessageState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: MessageDeliveryUncheckedUpdateManyWithoutMessageNestedInput
    approvals?: MessageApprovalUncheckedUpdateManyWithoutMessageNestedInput
    attachments?: MessageAttachmentUncheckedUpdateManyWithoutMessageNestedInput
    revisions?: MessageRevisionUncheckedUpdateManyWithoutMessageNestedInput
    views?: MessageViewUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutOverrideSetterInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    durationSeconds?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    isImmediate?: BoolFieldUpdateOperationsInput | boolean
    priority?: EnumMessagePriorityFieldUpdateOperationsInput | $Enums.MessagePriority
    approvalOverride?: NullableEnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy | null
    approvalOverrideSetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    eventAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    state?: EnumMessageStateFieldUpdateOperationsInput | $Enums.MessageState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelSubscriptionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscribedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    receiveMessages?: BoolFieldUpdateOperationsInput | boolean
    channel?: ChannelUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type ChannelSubscriptionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    subscribedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    receiveMessages?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ChannelSubscriptionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    subscribedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    receiveMessages?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvitationLinkUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    linkCode?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    currentUses?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: ChannelUpdateOneRequiredWithoutInvitationLinksNestedInput
  }

  export type InvitationLinkUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    linkCode?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    currentUses?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationLinkUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    linkCode?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    currentUses?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QrCodeUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrData?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scanCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: ChannelUpdateOneRequiredWithoutQrCodesNestedInput
  }

  export type QrCodeUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    qrData?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scanCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QrCodeUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    qrData?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scanCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageDeliveryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    deliveryStatus?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    deliveryMethod?: NullableEnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneRequiredWithoutDeliveriesNestedInput
  }

  export type MessageDeliveryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    deliveryStatus?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    deliveryMethod?: NullableEnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageDeliveryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    deliveryStatus?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    deliveryMethod?: NullableEnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageApprovalUpdateWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: MessageUpdateOneRequiredWithoutApprovalsNestedInput
  }

  export type MessageApprovalUncheckedUpdateWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageApprovalUncheckedUpdateManyWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageRevisionUpdateWithoutEditorInput = {
    id?: StringFieldUpdateOperationsInput | string
    previousContent?: StringFieldUpdateOperationsInput | string
    previousCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    previousPriority?: EnumMessagePriorityFieldUpdateOperationsInput | $Enums.MessagePriority
    previousIsImmediate?: BoolFieldUpdateOperationsInput | boolean
    previousDeliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneRequiredWithoutRevisionsNestedInput
  }

  export type MessageRevisionUncheckedUpdateWithoutEditorInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    previousContent?: StringFieldUpdateOperationsInput | string
    previousCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    previousPriority?: EnumMessagePriorityFieldUpdateOperationsInput | $Enums.MessagePriority
    previousIsImmediate?: BoolFieldUpdateOperationsInput | boolean
    previousDeliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageRevisionUncheckedUpdateManyWithoutEditorInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    previousContent?: StringFieldUpdateOperationsInput | string
    previousCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    previousPriority?: EnumMessagePriorityFieldUpdateOperationsInput | $Enums.MessagePriority
    previousIsImmediate?: BoolFieldUpdateOperationsInput | boolean
    previousDeliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserMessagingSettingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: EnumMessagingPlatformFieldUpdateOperationsInput | $Enums.MessagingPlatform
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserMessagingSettingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: EnumMessagingPlatformFieldUpdateOperationsInput | $Enums.MessagingPlatform
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserMessagingSettingUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: EnumMessagingPlatformFieldUpdateOperationsInput | $Enums.MessagingPlatform
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelApproverUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: ChannelUpdateOneRequiredWithoutApproversNestedInput
  }

  export type ChannelApproverUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelApproverUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCategoryUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    scope?: EnumCategoryScopeFieldUpdateOperationsInput | $Enums.CategoryScope
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: ChannelUpdateOneWithoutMessageCategoriesNestedInput
    messages?: MessageUpdateManyWithoutCategoryNestedInput
  }

  export type MessageCategoryUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    scope?: EnumCategoryScopeFieldUpdateOperationsInput | $Enums.CategoryScope
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type MessageCategoryUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    scope?: EnumCategoryScopeFieldUpdateOperationsInput | $Enums.CategoryScope
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageViewUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneRequiredWithoutViewsNestedInput
  }

  export type MessageViewUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageViewUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelVisitUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: ChannelUpdateOneRequiredWithoutVisitsNestedInput
  }

  export type ChannelVisitUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    visitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelVisitUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    visitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    headerContent?: NullableStringFieldUpdateOperationsInput | string | null
    footerContent?: NullableStringFieldUpdateOperationsInput | string | null
    successMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    wasPublished?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    collectUserInfo?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fields?: FormFieldUpdateManyWithoutFormNestedInput
    submissions?: FormSubmissionUpdateManyWithoutFormNestedInput
  }

  export type FormUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    headerContent?: NullableStringFieldUpdateOperationsInput | string | null
    footerContent?: NullableStringFieldUpdateOperationsInput | string | null
    successMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    wasPublished?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    collectUserInfo?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fields?: FormFieldUncheckedUpdateManyWithoutFormNestedInput
    submissions?: FormSubmissionUncheckedUpdateManyWithoutFormNestedInput
  }

  export type FormUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    headerContent?: NullableStringFieldUpdateOperationsInput | string | null
    footerContent?: NullableStringFieldUpdateOperationsInput | string | null
    successMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    wasPublished?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    collectUserInfo?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUpdateWithoutOrganizerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    categories?: NullableJsonNullValueInput | InputJsonValue
    paymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zones?: EventZoneUpdateManyWithoutEventNestedInput
    seats?: EventSeatUpdateManyWithoutEventNestedInput
    tickets?: TicketUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutOrganizerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    categories?: NullableJsonNullValueInput | InputJsonValue
    paymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zones?: EventZoneUncheckedUpdateManyWithoutEventNestedInput
    seats?: EventSeatUncheckedUpdateManyWithoutEventNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateManyWithoutOrganizerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    categories?: NullableJsonNullValueInput | InputJsonValue
    paymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelCreateManyParentInput = {
    id?: string
    title: string
    description?: string | null
    websiteUrl?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: string | null
    icon?: string
    ownerId: string
    organizationId: string
    isPublic?: boolean
    isHidden?: boolean
    searchExactOnly?: boolean
    passwordHash?: string | null
    referenceCode?: string | null
    verificationStatus?: $Enums.VerificationStatus
    approvalPolicy?: $Enums.ApprovalPolicy
    memberCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateManyChannelInput = {
    id?: string
    senderId: string
    categoryId: string
    content: string
    durationSeconds?: number
    expiresAt?: Date | string | null
    isEmergency?: boolean
    isImmediate?: boolean
    priority?: $Enums.MessagePriority
    approvalOverride?: $Enums.ApprovalPolicy | null
    approvalOverrideSetBy?: string | null
    approvalOverrideSetAt?: Date | string | null
    deliveryMethod?: $Enums.DeliveryMethod
    eventAt?: Date | string | null
    publishedAt?: Date | string | null
    state?: $Enums.MessageState
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChannelSubscriptionCreateManyChannelInput = {
    id?: string
    userId: string
    subscribedAt?: Date | string
    isActive?: boolean
    isFavorite?: boolean
    receiveMessages?: boolean
  }

  export type InvitationLinkCreateManyChannelInput = {
    id?: string
    createdBy: string
    linkCode: string
    expiresAt?: Date | string | null
    maxUses?: number | null
    currentUses?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type QrCodeCreateManyChannelInput = {
    id?: string
    createdBy: string
    qrData: string
    expiresAt?: Date | string | null
    scanCount?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ChannelApproverCreateManyChannelInput = {
    id?: string
    userId: string
    isActive?: boolean
    removedAt?: Date | string | null
    removedBy?: string | null
    createdAt?: Date | string
  }

  export type ChannelVerificationDocumentCreateManyChannelInput = {
    id?: string
    title: string
    docUrl: string
    issuer?: string | null
    issuedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ChannelCategoryAssignmentCreateManyChannelInput = {
    id?: string
    categoryId: string
  }

  export type MessageCategoryCreateManyChannelInput = {
    id?: string
    name: string
    scope?: $Enums.CategoryScope
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type ChannelVisitCreateManyChannelInput = {
    id?: string
    userId?: string | null
    visitedAt?: Date | string
  }

  export type ChannelUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    searchExactOnly?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    approvalPolicy?: EnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy
    memberCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedChannelsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutChannelsNestedInput
    subchannels?: ChannelUpdateManyWithoutParentNestedInput
    messages?: MessageUpdateManyWithoutChannelNestedInput
    subscriptions?: ChannelSubscriptionUpdateManyWithoutChannelNestedInput
    invitationLinks?: InvitationLinkUpdateManyWithoutChannelNestedInput
    qrCodes?: QrCodeUpdateManyWithoutChannelNestedInput
    approvers?: ChannelApproverUpdateManyWithoutChannelNestedInput
    verificationDocs?: ChannelVerificationDocumentUpdateManyWithoutChannelNestedInput
    categories?: ChannelCategoryAssignmentUpdateManyWithoutChannelNestedInput
    messageCategories?: MessageCategoryUpdateManyWithoutChannelNestedInput
    visits?: ChannelVisitUpdateManyWithoutChannelNestedInput
  }

  export type ChannelUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    searchExactOnly?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    approvalPolicy?: EnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy
    memberCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subchannels?: ChannelUncheckedUpdateManyWithoutParentNestedInput
    messages?: MessageUncheckedUpdateManyWithoutChannelNestedInput
    subscriptions?: ChannelSubscriptionUncheckedUpdateManyWithoutChannelNestedInput
    invitationLinks?: InvitationLinkUncheckedUpdateManyWithoutChannelNestedInput
    qrCodes?: QrCodeUncheckedUpdateManyWithoutChannelNestedInput
    approvers?: ChannelApproverUncheckedUpdateManyWithoutChannelNestedInput
    verificationDocs?: ChannelVerificationDocumentUncheckedUpdateManyWithoutChannelNestedInput
    categories?: ChannelCategoryAssignmentUncheckedUpdateManyWithoutChannelNestedInput
    messageCategories?: MessageCategoryUncheckedUpdateManyWithoutChannelNestedInput
    visits?: ChannelVisitUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type ChannelUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    searchExactOnly?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    approvalPolicy?: EnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy
    memberCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    durationSeconds?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    isImmediate?: BoolFieldUpdateOperationsInput | boolean
    priority?: EnumMessagePriorityFieldUpdateOperationsInput | $Enums.MessagePriority
    approvalOverride?: NullableEnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy | null
    approvalOverrideSetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    eventAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    state?: EnumMessageStateFieldUpdateOperationsInput | $Enums.MessageState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutMessagesSentNestedInput
    category?: MessageCategoryUpdateOneRequiredWithoutMessagesNestedInput
    overrideSetter?: UserUpdateOneWithoutMessagesOverrideSetNestedInput
    deliveries?: MessageDeliveryUpdateManyWithoutMessageNestedInput
    approvals?: MessageApprovalUpdateManyWithoutMessageNestedInput
    attachments?: MessageAttachmentUpdateManyWithoutMessageNestedInput
    revisions?: MessageRevisionUpdateManyWithoutMessageNestedInput
    views?: MessageViewUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    durationSeconds?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    isImmediate?: BoolFieldUpdateOperationsInput | boolean
    priority?: EnumMessagePriorityFieldUpdateOperationsInput | $Enums.MessagePriority
    approvalOverride?: NullableEnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy | null
    approvalOverrideSetBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvalOverrideSetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    eventAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    state?: EnumMessageStateFieldUpdateOperationsInput | $Enums.MessageState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: MessageDeliveryUncheckedUpdateManyWithoutMessageNestedInput
    approvals?: MessageApprovalUncheckedUpdateManyWithoutMessageNestedInput
    attachments?: MessageAttachmentUncheckedUpdateManyWithoutMessageNestedInput
    revisions?: MessageRevisionUncheckedUpdateManyWithoutMessageNestedInput
    views?: MessageViewUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    durationSeconds?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    isImmediate?: BoolFieldUpdateOperationsInput | boolean
    priority?: EnumMessagePriorityFieldUpdateOperationsInput | $Enums.MessagePriority
    approvalOverride?: NullableEnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy | null
    approvalOverrideSetBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvalOverrideSetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    eventAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    state?: EnumMessageStateFieldUpdateOperationsInput | $Enums.MessageState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelSubscriptionUpdateWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscribedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    receiveMessages?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type ChannelSubscriptionUncheckedUpdateWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    subscribedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    receiveMessages?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ChannelSubscriptionUncheckedUpdateManyWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    subscribedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    receiveMessages?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvitationLinkUpdateWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    linkCode?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    currentUses?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutInvitationLinksNestedInput
  }

  export type InvitationLinkUncheckedUpdateWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    linkCode?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    currentUses?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationLinkUncheckedUpdateManyWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    linkCode?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    currentUses?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QrCodeUpdateWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrData?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scanCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutQrCodesNestedInput
  }

  export type QrCodeUncheckedUpdateWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    qrData?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scanCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QrCodeUncheckedUpdateManyWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    qrData?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scanCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelApproverUpdateWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutApproverAssignmentsNestedInput
  }

  export type ChannelApproverUncheckedUpdateWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelApproverUncheckedUpdateManyWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelVerificationDocumentUpdateWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    docUrl?: StringFieldUpdateOperationsInput | string
    issuer?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelVerificationDocumentUncheckedUpdateWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    docUrl?: StringFieldUpdateOperationsInput | string
    issuer?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelVerificationDocumentUncheckedUpdateManyWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    docUrl?: StringFieldUpdateOperationsInput | string
    issuer?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelCategoryAssignmentUpdateWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: ChannelCategoryUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type ChannelCategoryAssignmentUncheckedUpdateWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type ChannelCategoryAssignmentUncheckedUpdateManyWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageCategoryUpdateWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    scope?: EnumCategoryScopeFieldUpdateOperationsInput | $Enums.CategoryScope
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutCreatedCategoriesNestedInput
    messages?: MessageUpdateManyWithoutCategoryNestedInput
  }

  export type MessageCategoryUncheckedUpdateWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    scope?: EnumCategoryScopeFieldUpdateOperationsInput | $Enums.CategoryScope
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type MessageCategoryUncheckedUpdateManyWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    scope?: EnumCategoryScopeFieldUpdateOperationsInput | $Enums.CategoryScope
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelVisitUpdateWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutChannelVisitsNestedInput
  }

  export type ChannelVisitUncheckedUpdateWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    visitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelVisitUncheckedUpdateManyWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    visitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageDeliveryCreateManyMessageInput = {
    id?: string
    userId: string
    deliveryStatus?: $Enums.DeliveryStatus
    deliveryMethod?: $Enums.DeliveryMethod | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MessageApprovalCreateManyMessageInput = {
    id?: string
    approverId: string
    status?: $Enums.ApprovalStatus
    decidedAt?: Date | string | null
  }

  export type MessageAttachmentCreateManyMessageInput = {
    id?: string
    type: $Enums.AttachmentType
    url: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MessageRevisionCreateManyMessageInput = {
    id?: string
    editorId: string
    previousContent: string
    previousCategoryId?: string | null
    previousPriority: $Enums.MessagePriority
    previousIsImmediate: boolean
    previousDeliveryMethod: $Enums.DeliveryMethod
    changedAt?: Date | string
  }

  export type MessageViewCreateManyMessageInput = {
    id?: string
    userId?: string | null
    viewedAt?: Date | string
  }

  export type MessageDeliveryUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    deliveryStatus?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    deliveryMethod?: NullableEnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMessageDeliveriesNestedInput
  }

  export type MessageDeliveryUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    deliveryStatus?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    deliveryMethod?: NullableEnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageDeliveryUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    deliveryStatus?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    deliveryMethod?: NullableEnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageApprovalUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approver?: UserUpdateOneRequiredWithoutMessageApprovalsNestedInput
  }

  export type MessageApprovalUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    approverId?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageApprovalUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    approverId?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageAttachmentUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAttachmentTypeFieldUpdateOperationsInput | $Enums.AttachmentType
    url?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageAttachmentUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAttachmentTypeFieldUpdateOperationsInput | $Enums.AttachmentType
    url?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageAttachmentUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAttachmentTypeFieldUpdateOperationsInput | $Enums.AttachmentType
    url?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageRevisionUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    previousContent?: StringFieldUpdateOperationsInput | string
    previousCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    previousPriority?: EnumMessagePriorityFieldUpdateOperationsInput | $Enums.MessagePriority
    previousIsImmediate?: BoolFieldUpdateOperationsInput | boolean
    previousDeliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editor?: UserUpdateOneRequiredWithoutMessageRevisionsEditedNestedInput
  }

  export type MessageRevisionUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    previousContent?: StringFieldUpdateOperationsInput | string
    previousCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    previousPriority?: EnumMessagePriorityFieldUpdateOperationsInput | $Enums.MessagePriority
    previousIsImmediate?: BoolFieldUpdateOperationsInput | boolean
    previousDeliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageRevisionUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    previousContent?: StringFieldUpdateOperationsInput | string
    previousCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    previousPriority?: EnumMessagePriorityFieldUpdateOperationsInput | $Enums.MessagePriority
    previousIsImmediate?: BoolFieldUpdateOperationsInput | boolean
    previousDeliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageViewUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutMessageViewsNestedInput
  }

  export type MessageViewUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageViewUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelCreateManyOrganizationInput = {
    id?: string
    title: string
    description?: string | null
    websiteUrl?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: string | null
    icon?: string
    parentId?: string | null
    ownerId: string
    isPublic?: boolean
    isHidden?: boolean
    searchExactOnly?: boolean
    passwordHash?: string | null
    referenceCode?: string | null
    verificationStatus?: $Enums.VerificationStatus
    approvalPolicy?: $Enums.ApprovalPolicy
    memberCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChannelUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    searchExactOnly?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    approvalPolicy?: EnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy
    memberCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedChannelsNestedInput
    parent?: ChannelUpdateOneWithoutSubchannelsNestedInput
    subchannels?: ChannelUpdateManyWithoutParentNestedInput
    messages?: MessageUpdateManyWithoutChannelNestedInput
    subscriptions?: ChannelSubscriptionUpdateManyWithoutChannelNestedInput
    invitationLinks?: InvitationLinkUpdateManyWithoutChannelNestedInput
    qrCodes?: QrCodeUpdateManyWithoutChannelNestedInput
    approvers?: ChannelApproverUpdateManyWithoutChannelNestedInput
    verificationDocs?: ChannelVerificationDocumentUpdateManyWithoutChannelNestedInput
    categories?: ChannelCategoryAssignmentUpdateManyWithoutChannelNestedInput
    messageCategories?: MessageCategoryUpdateManyWithoutChannelNestedInput
    visits?: ChannelVisitUpdateManyWithoutChannelNestedInput
  }

  export type ChannelUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    searchExactOnly?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    approvalPolicy?: EnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy
    memberCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subchannels?: ChannelUncheckedUpdateManyWithoutParentNestedInput
    messages?: MessageUncheckedUpdateManyWithoutChannelNestedInput
    subscriptions?: ChannelSubscriptionUncheckedUpdateManyWithoutChannelNestedInput
    invitationLinks?: InvitationLinkUncheckedUpdateManyWithoutChannelNestedInput
    qrCodes?: QrCodeUncheckedUpdateManyWithoutChannelNestedInput
    approvers?: ChannelApproverUncheckedUpdateManyWithoutChannelNestedInput
    verificationDocs?: ChannelVerificationDocumentUncheckedUpdateManyWithoutChannelNestedInput
    categories?: ChannelCategoryAssignmentUncheckedUpdateManyWithoutChannelNestedInput
    messageCategories?: MessageCategoryUncheckedUpdateManyWithoutChannelNestedInput
    visits?: ChannelVisitUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type ChannelUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    searchExactOnly?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    approvalPolicy?: EnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy
    memberCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyCategoryInput = {
    id?: string
    channelId: string
    senderId: string
    content: string
    durationSeconds?: number
    expiresAt?: Date | string | null
    isEmergency?: boolean
    isImmediate?: boolean
    priority?: $Enums.MessagePriority
    approvalOverride?: $Enums.ApprovalPolicy | null
    approvalOverrideSetBy?: string | null
    approvalOverrideSetAt?: Date | string | null
    deliveryMethod?: $Enums.DeliveryMethod
    eventAt?: Date | string | null
    publishedAt?: Date | string | null
    state?: $Enums.MessageState
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    durationSeconds?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    isImmediate?: BoolFieldUpdateOperationsInput | boolean
    priority?: EnumMessagePriorityFieldUpdateOperationsInput | $Enums.MessagePriority
    approvalOverride?: NullableEnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy | null
    approvalOverrideSetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    eventAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    state?: EnumMessageStateFieldUpdateOperationsInput | $Enums.MessageState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: ChannelUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutMessagesSentNestedInput
    overrideSetter?: UserUpdateOneWithoutMessagesOverrideSetNestedInput
    deliveries?: MessageDeliveryUpdateManyWithoutMessageNestedInput
    approvals?: MessageApprovalUpdateManyWithoutMessageNestedInput
    attachments?: MessageAttachmentUpdateManyWithoutMessageNestedInput
    revisions?: MessageRevisionUpdateManyWithoutMessageNestedInput
    views?: MessageViewUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    durationSeconds?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    isImmediate?: BoolFieldUpdateOperationsInput | boolean
    priority?: EnumMessagePriorityFieldUpdateOperationsInput | $Enums.MessagePriority
    approvalOverride?: NullableEnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy | null
    approvalOverrideSetBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvalOverrideSetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    eventAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    state?: EnumMessageStateFieldUpdateOperationsInput | $Enums.MessageState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: MessageDeliveryUncheckedUpdateManyWithoutMessageNestedInput
    approvals?: MessageApprovalUncheckedUpdateManyWithoutMessageNestedInput
    attachments?: MessageAttachmentUncheckedUpdateManyWithoutMessageNestedInput
    revisions?: MessageRevisionUncheckedUpdateManyWithoutMessageNestedInput
    views?: MessageViewUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    durationSeconds?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    isImmediate?: BoolFieldUpdateOperationsInput | boolean
    priority?: EnumMessagePriorityFieldUpdateOperationsInput | $Enums.MessagePriority
    approvalOverride?: NullableEnumApprovalPolicyFieldUpdateOperationsInput | $Enums.ApprovalPolicy | null
    approvalOverrideSetBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvalOverrideSetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    eventAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    state?: EnumMessageStateFieldUpdateOperationsInput | $Enums.MessageState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelCategoryAssignmentCreateManyCategoryInput = {
    id?: string
    channelId: string
  }

  export type ChannelCategoryAssignmentUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: ChannelUpdateOneRequiredWithoutCategoriesNestedInput
  }

  export type ChannelCategoryAssignmentUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
  }

  export type ChannelCategoryAssignmentUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
  }

  export type FormFieldCreateManyFormInput = {
    id?: string
    type: string
    label: string
    placeholder?: string | null
    required?: boolean
    isHidden?: boolean
    options?: NullableJsonNullValueInput | InputJsonValue
    order?: number
    createdAt?: Date | string
  }

  export type FormSubmissionCreateManyFormInput = {
    id?: string
    data: JsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    country?: string | null
    city?: string | null
    userAgent?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type FormFieldUpdateWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    required?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    options?: NullableJsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormFieldUncheckedUpdateWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    required?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    options?: NullableJsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormFieldUncheckedUpdateManyWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    required?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    options?: NullableJsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormSubmissionUpdateWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormSubmissionUncheckedUpdateWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormSubmissionUncheckedUpdateManyWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventZoneCreateManyEventInput = {
    id?: string
    name: string
    color: string
    price: number
    rows: number
    cols: number
    capacity?: number | null
    type?: $Enums.ZoneType
    layout?: NullableJsonNullValueInput | InputJsonValue
    seatGap?: number | null
    startNumber?: number
    numberingDirection?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventSeatCreateManyEventInput = {
    id?: string
    zoneId: string
    rowLabel: string
    colLabel: string
    status?: $Enums.SeatStatus
    type?: $Enums.SeatType
    price?: number | null
    x?: number | null
    y?: number | null
    holderName?: string | null
    ticketCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketCreateManyEventInput = {
    id?: string
    zoneId: string
    seatId?: string | null
    customerName: string
    customerEmail: string
    price: number
    status?: $Enums.TicketStatus
    purchaseDate?: Date | string
    qrCode?: string | null
  }

  export type EventZoneUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    rows?: IntFieldUpdateOperationsInput | number
    cols?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumZoneTypeFieldUpdateOperationsInput | $Enums.ZoneType
    layout?: NullableJsonNullValueInput | InputJsonValue
    seatGap?: NullableIntFieldUpdateOperationsInput | number | null
    startNumber?: IntFieldUpdateOperationsInput | number
    numberingDirection?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seats?: EventSeatUpdateManyWithoutZoneNestedInput
    tickets?: TicketUpdateManyWithoutZoneNestedInput
  }

  export type EventZoneUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    rows?: IntFieldUpdateOperationsInput | number
    cols?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumZoneTypeFieldUpdateOperationsInput | $Enums.ZoneType
    layout?: NullableJsonNullValueInput | InputJsonValue
    seatGap?: NullableIntFieldUpdateOperationsInput | number | null
    startNumber?: IntFieldUpdateOperationsInput | number
    numberingDirection?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seats?: EventSeatUncheckedUpdateManyWithoutZoneNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type EventZoneUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    rows?: IntFieldUpdateOperationsInput | number
    cols?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumZoneTypeFieldUpdateOperationsInput | $Enums.ZoneType
    layout?: NullableJsonNullValueInput | InputJsonValue
    seatGap?: NullableIntFieldUpdateOperationsInput | number | null
    startNumber?: IntFieldUpdateOperationsInput | number
    numberingDirection?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventSeatUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    rowLabel?: StringFieldUpdateOperationsInput | string
    colLabel?: StringFieldUpdateOperationsInput | string
    status?: EnumSeatStatusFieldUpdateOperationsInput | $Enums.SeatStatus
    type?: EnumSeatTypeFieldUpdateOperationsInput | $Enums.SeatType
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    x?: NullableIntFieldUpdateOperationsInput | number | null
    y?: NullableIntFieldUpdateOperationsInput | number | null
    holderName?: NullableStringFieldUpdateOperationsInput | string | null
    ticketCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zone?: EventZoneUpdateOneRequiredWithoutSeatsNestedInput
    tickets?: TicketUpdateManyWithoutSeatNestedInput
  }

  export type EventSeatUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    rowLabel?: StringFieldUpdateOperationsInput | string
    colLabel?: StringFieldUpdateOperationsInput | string
    status?: EnumSeatStatusFieldUpdateOperationsInput | $Enums.SeatStatus
    type?: EnumSeatTypeFieldUpdateOperationsInput | $Enums.SeatType
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    x?: NullableIntFieldUpdateOperationsInput | number | null
    y?: NullableIntFieldUpdateOperationsInput | number | null
    holderName?: NullableStringFieldUpdateOperationsInput | string | null
    ticketCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUncheckedUpdateManyWithoutSeatNestedInput
  }

  export type EventSeatUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    rowLabel?: StringFieldUpdateOperationsInput | string
    colLabel?: StringFieldUpdateOperationsInput | string
    status?: EnumSeatStatusFieldUpdateOperationsInput | $Enums.SeatStatus
    type?: EnumSeatTypeFieldUpdateOperationsInput | $Enums.SeatType
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    x?: NullableIntFieldUpdateOperationsInput | number | null
    y?: NullableIntFieldUpdateOperationsInput | number | null
    holderName?: NullableStringFieldUpdateOperationsInput | string | null
    ticketCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    zone?: EventZoneUpdateOneRequiredWithoutTicketsNestedInput
    seat?: EventSeatUpdateOneWithoutTicketsNestedInput
  }

  export type TicketUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    seatId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TicketUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    seatId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EventSeatCreateManyZoneInput = {
    id?: string
    eventId: string
    rowLabel: string
    colLabel: string
    status?: $Enums.SeatStatus
    type?: $Enums.SeatType
    price?: number | null
    x?: number | null
    y?: number | null
    holderName?: string | null
    ticketCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketCreateManyZoneInput = {
    id?: string
    eventId: string
    seatId?: string | null
    customerName: string
    customerEmail: string
    price: number
    status?: $Enums.TicketStatus
    purchaseDate?: Date | string
    qrCode?: string | null
  }

  export type EventSeatUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    rowLabel?: StringFieldUpdateOperationsInput | string
    colLabel?: StringFieldUpdateOperationsInput | string
    status?: EnumSeatStatusFieldUpdateOperationsInput | $Enums.SeatStatus
    type?: EnumSeatTypeFieldUpdateOperationsInput | $Enums.SeatType
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    x?: NullableIntFieldUpdateOperationsInput | number | null
    y?: NullableIntFieldUpdateOperationsInput | number | null
    holderName?: NullableStringFieldUpdateOperationsInput | string | null
    ticketCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutSeatsNestedInput
    tickets?: TicketUpdateManyWithoutSeatNestedInput
  }

  export type EventSeatUncheckedUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    rowLabel?: StringFieldUpdateOperationsInput | string
    colLabel?: StringFieldUpdateOperationsInput | string
    status?: EnumSeatStatusFieldUpdateOperationsInput | $Enums.SeatStatus
    type?: EnumSeatTypeFieldUpdateOperationsInput | $Enums.SeatType
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    x?: NullableIntFieldUpdateOperationsInput | number | null
    y?: NullableIntFieldUpdateOperationsInput | number | null
    holderName?: NullableStringFieldUpdateOperationsInput | string | null
    ticketCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUncheckedUpdateManyWithoutSeatNestedInput
  }

  export type EventSeatUncheckedUpdateManyWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    rowLabel?: StringFieldUpdateOperationsInput | string
    colLabel?: StringFieldUpdateOperationsInput | string
    status?: EnumSeatStatusFieldUpdateOperationsInput | $Enums.SeatStatus
    type?: EnumSeatTypeFieldUpdateOperationsInput | $Enums.SeatType
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    x?: NullableIntFieldUpdateOperationsInput | number | null
    y?: NullableIntFieldUpdateOperationsInput | number | null
    holderName?: NullableStringFieldUpdateOperationsInput | string | null
    ticketCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    event?: EventUpdateOneRequiredWithoutTicketsNestedInput
    seat?: EventSeatUpdateOneWithoutTicketsNestedInput
  }

  export type TicketUncheckedUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    seatId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TicketUncheckedUpdateManyWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    seatId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TicketCreateManySeatInput = {
    id?: string
    eventId: string
    zoneId: string
    customerName: string
    customerEmail: string
    price: number
    status?: $Enums.TicketStatus
    purchaseDate?: Date | string
    qrCode?: string | null
  }

  export type TicketUpdateWithoutSeatInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    event?: EventUpdateOneRequiredWithoutTicketsNestedInput
    zone?: EventZoneUpdateOneRequiredWithoutTicketsNestedInput
  }

  export type TicketUncheckedUpdateWithoutSeatInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TicketUncheckedUpdateManyWithoutSeatInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChannelCountOutputTypeDefaultArgs instead
     */
    export type ChannelCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChannelCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageCountOutputTypeDefaultArgs instead
     */
    export type MessageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrganizationCountOutputTypeDefaultArgs instead
     */
    export type OrganizationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganizationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageCategoryCountOutputTypeDefaultArgs instead
     */
    export type MessageCategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageCategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChannelCategoryCountOutputTypeDefaultArgs instead
     */
    export type ChannelCategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChannelCategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FormCountOutputTypeDefaultArgs instead
     */
    export type FormCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FormCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventCountOutputTypeDefaultArgs instead
     */
    export type EventCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventZoneCountOutputTypeDefaultArgs instead
     */
    export type EventZoneCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventZoneCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventSeatCountOutputTypeDefaultArgs instead
     */
    export type EventSeatCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventSeatCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChannelDefaultArgs instead
     */
    export type ChannelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChannelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageDefaultArgs instead
     */
    export type MessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChannelSubscriptionDefaultArgs instead
     */
    export type ChannelSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChannelSubscriptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageDeliveryDefaultArgs instead
     */
    export type MessageDeliveryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageDeliveryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvitationLinkDefaultArgs instead
     */
    export type InvitationLinkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvitationLinkDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QrCodeDefaultArgs instead
     */
    export type QrCodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QrCodeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrganizationDefaultArgs instead
     */
    export type OrganizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganizationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChannelApproverDefaultArgs instead
     */
    export type ChannelApproverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChannelApproverDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageApprovalDefaultArgs instead
     */
    export type MessageApprovalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageApprovalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageCategoryDefaultArgs instead
     */
    export type MessageCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageAttachmentDefaultArgs instead
     */
    export type MessageAttachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageAttachmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageRevisionDefaultArgs instead
     */
    export type MessageRevisionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageRevisionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChannelVerificationDocumentDefaultArgs instead
     */
    export type ChannelVerificationDocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChannelVerificationDocumentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserProfileDefaultArgs instead
     */
    export type UserProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserMessagingSettingDefaultArgs instead
     */
    export type UserMessagingSettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserMessagingSettingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChannelCategoryDefaultArgs instead
     */
    export type ChannelCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChannelCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChannelCategoryAssignmentDefaultArgs instead
     */
    export type ChannelCategoryAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChannelCategoryAssignmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageViewDefaultArgs instead
     */
    export type MessageViewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageViewDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChannelVisitDefaultArgs instead
     */
    export type ChannelVisitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChannelVisitDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FormDefaultArgs instead
     */
    export type FormArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FormDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FormFieldDefaultArgs instead
     */
    export type FormFieldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FormFieldDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FormSubmissionDefaultArgs instead
     */
    export type FormSubmissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FormSubmissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventDefaultArgs instead
     */
    export type EventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventZoneDefaultArgs instead
     */
    export type EventZoneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventZoneDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventSeatDefaultArgs instead
     */
    export type EventSeatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventSeatDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TicketDefaultArgs instead
     */
    export type TicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TicketDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}